-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A typeclass and set of functions for working with newtypes
--   
--   Per Conor McBride, the Newtype typeclass represents the packing and
--   unpacking of a newtype, and allows you to operate under that newtype
--   with functions such as ala. Generics support was added in version 0.4,
--   making this package a full replacement for the original newtype
--   package, and a better alternative to newtype-th.
@package newtype-generics
@version 0.6


-- | The <a>Newtype</a> typeclass and related functions. Primarily pulled
--   from Conor McBride's Epigram work. Some examples:
--   
--   <pre>
--   &gt;&gt;&gt; ala Sum foldMap [1,2,3,4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Endo foldMap [(+1), (+2), (subtract 1), (*2)] 3
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; under2 Min (&lt;&gt;) 2 1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over All not (All False)
--   All {getAll = True)
--   </pre>
--   
--   This package includes <a>Newtype</a> instances for all the
--   (non-GHC/foreign) newtypes in base (as seen in the examples). However,
--   there are neat things you can do with this with <i>any</i> newtype and
--   you should definitely define your own <a>Newtype</a> instances for the
--   power of this library. For example, see <tt>ala Cont traverse</tt>,
--   with the proper <a>Newtype</a> instance for Cont. You can easily
--   define new instances for your newtypes with the help of GHC.Generics
--   
--   <pre>
--   import GHC.Generics
--   
--   (...)
--   newtype Example = Example Int
--     deriving (Generic)
--   
--   instance Newtype Example
--   </pre>
--   
--   This avoids the use of Template Haskell (TH) to get new instances.
module Control.Newtype.Generics

-- | As long as the type <tt>n</tt> is an instance of Generic, you can
--   create an instance with just <tt>instance Newtype n</tt>
class Newtype n where {
    type family O n :: Type;
    type O n = GO (Rep n);
}
pack :: Newtype n => O n -> n
pack :: (Newtype n, Generic n, GNewtype (Rep n), O n ~ GO (Rep n)) => O n -> n
unpack :: Newtype n => n -> O n
unpack :: (Newtype n, Generic n, GNewtype (Rep n), O n ~ GO (Rep n)) => n -> O n

-- | This function serves two purposes:
--   
--   <ol>
--   <li>Giving you the unpack of a newtype without you needing to remember
--   the name.</li>
--   <li>Showing that the first parameter is <i>completely ignored</i> on
--   the value level, meaning the only reason you pass in the constructor
--   is to provide type information. Typeclasses sure are neat.</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; op Identity (Identity 3)
--   3
--   </pre>
op :: (Newtype n, o ~ O n) => (o -> n) -> n -> o

-- | The workhorse of the package. Given a "packer" and a "higher order
--   function" (<i>hof</i>), it handles the packing and unpacking, and just
--   sends you back a regular old function, with the type varying based on
--   the <i>hof</i> you passed.
--   
--   The reason for the signature of the <i>hof</i> is due to <a>ala</a>
--   not caring about structure. To illustrate why this is important,
--   consider this alternative implementation of <a>under2</a>:
--   
--   <pre>
--   under2 :: (Newtype n, Newtype n', o' ~ O n', o ~ O n)
--          =&gt; (o -&gt; n) -&gt; (n -&gt; n -&gt; n') -&gt; (o -&gt; o -&gt; o')
--   under2' pa f o0 o1 = ala pa (\p -&gt; uncurry f . bimap p p) (o0, o1)
--   </pre>
--   
--   Being handed the "packer", the <i>hof</i> may apply it in any
--   structure of its choosing â€“ in this case a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; ala Sum foldMap [1,2,3,4]
--   10
--   </pre>
ala :: (Newtype n, Newtype n', o' ~ O n', o ~ O n) => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'

-- | This is the original function seen in Conor McBride's work. The way it
--   differs from the <a>ala</a> function in this package, is that it
--   provides an extra hook into the "packer" passed to the hof. However,
--   this normally ends up being <tt>id</tt>, so <a>ala</a> wraps this
--   function and passes <tt>id</tt> as the final parameter by default. If
--   you want the convenience of being able to hook right into the hof, you
--   may use this function.
--   
--   <pre>
--   &gt;&gt;&gt; ala' Sum foldMap length ["hello", "world"]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala' First foldMap (readMaybe @Int) ["x", "42", "1"]
--   Just 42
--   </pre>
ala' :: (Newtype n, Newtype n', o' ~ O n', o ~ O n) => (o -> n) -> ((a -> n) -> b -> n') -> (a -> o) -> b -> o'

-- | A very simple operation involving running the function 'under' the
--   newtype.
--   
--   <pre>
--   &gt;&gt;&gt; under Product (stimes 3) 3
--   27
--   </pre>
under :: (Newtype n, Newtype n', o' ~ O n', o ~ O n) => (o -> n) -> (n -> n') -> o -> o'

-- | The opposite of <a>under</a>. I.e., take a function which works on the
--   underlying types, and switch it to a function that works on the
--   newtypes.
--   
--   <pre>
--   &gt;&gt;&gt; over All not (All False)
--   All {getAll = True}
--   </pre>
over :: (Newtype n, Newtype n', o' ~ O n', o ~ O n) => (o -> n) -> (o -> o') -> n -> n'

-- | Lower a binary function to operate on the underlying values.
--   
--   <pre>
--   &gt;&gt;&gt; under2 Any (&lt;&gt;) True False
--   True
--   </pre>
under2 :: (Newtype n, Newtype n', o' ~ O n', o ~ O n) => (o -> n) -> (n -> n -> n') -> o -> o -> o'

-- | The opposite of <a>under2</a>.
over2 :: (Newtype n, Newtype n', o' ~ O n', o ~ O n) => (o -> n) -> (o -> o -> o') -> n -> n -> n'

-- | <a>under</a> lifted into a Functor.
underF :: (Newtype n, Newtype n', o' ~ O n', o ~ O n, Functor f, Functor g) => (o -> n) -> (f n -> g n') -> f o -> g o'

-- | <a>over</a> lifted into a Functor.
overF :: (Newtype n, Newtype n', o' ~ O n', o ~ O n, Functor f, Functor g) => (o -> n) -> (f o -> g o') -> f n -> g n'
instance Control.Newtype.Generics.Newtype (Control.Applicative.WrappedMonad m a)
instance Control.Newtype.Generics.Newtype (Control.Applicative.WrappedArrow a b c)
instance Control.Newtype.Generics.Newtype (Control.Applicative.ZipList a)
instance Control.Newtype.Generics.Newtype (Control.Arrow.Kleisli m a b)
instance Control.Newtype.Generics.Newtype (Control.Arrow.ArrowMonad a b)
instance Control.Newtype.Generics.Newtype (Data.Fixed.Fixed a)
instance Control.Newtype.Generics.Newtype (Data.Functor.Compose.Compose f g a)
instance Control.Newtype.Generics.Newtype (Data.Functor.Const.Const a x)
instance Control.Newtype.Generics.Newtype (Data.Functor.Identity.Identity a)
instance Control.Newtype.Generics.Newtype (Data.Semigroup.Internal.Dual a)
instance Control.Newtype.Generics.Newtype (Data.Semigroup.Internal.Endo a)
instance Control.Newtype.Generics.Newtype Data.Semigroup.Internal.All
instance Control.Newtype.Generics.Newtype Data.Semigroup.Internal.Any
instance Control.Newtype.Generics.Newtype (Data.Semigroup.Internal.Sum a)
instance Control.Newtype.Generics.Newtype (Data.Semigroup.Internal.Product a)
instance Control.Newtype.Generics.Newtype (Data.Monoid.First a)
instance Control.Newtype.Generics.Newtype (Data.Monoid.Last a)
instance Control.Newtype.Generics.Newtype (Data.Semigroup.Internal.Alt f a)
instance Control.Newtype.Generics.Newtype (Data.Monoid.Ap f a)
instance Control.Newtype.Generics.Newtype (Data.Ord.Down a)
instance Control.Newtype.Generics.Newtype (Data.Semigroup.Min a)
instance Control.Newtype.Generics.Newtype (Data.Semigroup.Max a)
instance Control.Newtype.Generics.Newtype (Data.Semigroup.First a)
instance Control.Newtype.Generics.Newtype (Data.Semigroup.Last a)
instance Control.Newtype.Generics.Newtype (Data.Semigroup.WrappedMonoid m)
instance Control.Newtype.Generics.Newtype (Data.Semigroup.Option a)
instance Control.Newtype.Generics.GNewtype (GHC.Generics.D1 d (GHC.Generics.C1 c (GHC.Generics.S1 s (GHC.Generics.K1 i a))))
