-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Animation library based on SVGs.
--   
--   Animation library based on SVGs. Can import (and manipulate) SVGs from
--   LaTeX and diagrams. Exports gifs, mp4s, and more. Ships with a
--   webbased viewer and auto-reloader.
@package reanimate
@version 1.1.4.0


-- | Convenience wrapper around <a>CubicBezier</a>
module Geom2D.CubicBezier.Linear

-- | A bezier curve of any degree.
newtype AnyBezier a
AnyBezier :: Vector (V2 a) -> AnyBezier a

-- | A cubic bezier curve.
data CubicBezier a
CubicBezier :: !V2 a -> !V2 a -> !V2 a -> !V2 a -> CubicBezier a
[cubicC0] :: CubicBezier a -> !V2 a
[cubicC1] :: CubicBezier a -> !V2 a
[cubicC2] :: CubicBezier a -> !V2 a
[cubicC3] :: CubicBezier a -> !V2 a

-- | A quadratic bezier curve.
data QuadBezier a
QuadBezier :: !V2 a -> !V2 a -> !V2 a -> QuadBezier a
[quadC0] :: QuadBezier a -> !V2 a
[quadC1] :: QuadBezier a -> !V2 a
[quadC2] :: QuadBezier a -> !V2 a

-- | Open cubicbezier path.
data OpenPath a
OpenPath :: [(V2 a, PathJoin a)] -> V2 a -> OpenPath a

-- | Closed cubicbezier path.
newtype ClosedPath a
ClosedPath :: [(V2 a, PathJoin a)] -> ClosedPath a

-- | Join two points with either a straight line or a bezier curve with two
--   control points.
data PathJoin a
JoinLine :: PathJoin a
JoinCurve :: V2 a -> V2 a -> PathJoin a

-- | Closed meta path.
newtype ClosedMetaPath a
ClosedMetaPath :: [(V2 a, MetaJoin a)] -> ClosedMetaPath a

-- | Open meta path
data OpenMetaPath a
OpenMetaPath :: [(V2 a, MetaJoin a)] -> V2 a -> OpenMetaPath a

-- | Join two meta points with either a bezier curve or tension contraints.
data MetaJoin a
MetaJoin :: MetaNodeType a -> Tension a -> Tension a -> MetaNodeType a -> MetaJoin a
[metaTypeL] :: MetaJoin a -> MetaNodeType a
[tensionL] :: MetaJoin a -> Tension a
[tensionR] :: MetaJoin a -> Tension a
[metaTypeR] :: MetaJoin a -> MetaNodeType a
Controls :: V2 a -> V2 a -> MetaJoin a

-- | Node constraint type.
data MetaNodeType a
Open :: MetaNodeType a
Curl :: a -> MetaNodeType a
[curlgamma] :: MetaNodeType a -> a
Direction :: V2 a -> MetaNodeType a
[nodedir] :: MetaNodeType a -> V2 a

-- | Describe the possible filling algorithms. Map the values of the
--   `fill-rule` attributes.
data FillRule

-- | Corresponds to the <tt>evenodd</tt> value.
FillEvenOdd :: FillRule

-- | Corresponds to the <tt>nonzero</tt> value.
FillNonZero :: FillRule

-- | The tension value specifies how <i>tense</i> the curve is. A higher
--   value means the curve approaches a line segment, while a lower value
--   means the curve is more round. Metafont doesn't allow values below
--   3/4.
data Tension a
Tension :: a -> Tension a
[tensionValue] :: Tension a -> a

-- | Like Tension, but keep the segment inside the bounding triangle
--   defined by the control points, if there is one.
TensionAtLeast :: a -> Tension a
[tensionValue] :: Tension a -> a

-- | Convert a quadratic bezier to a cubic bezier.
quadToCubic :: Fractional a => QuadBezier a -> CubicBezier a

-- | <tt>arcLength c t tol</tt> finds the arclength of the bezier
--   <tt>c</tt> at <tt>t</tt>, within given tolerance <tt>tol</tt>.
arcLength :: CubicBezier Double -> Double -> Double -> Double

-- | <tt>arcLengthParam c len tol</tt> finds the parameter where the curve
--   <tt>c</tt> has the arclength <tt>len</tt>, within tolerance
--   <tt>tol</tt>.
arcLengthParam :: CubicBezier Double -> Double -> Double -> Double

-- | Split a bezier curve into two curves.
splitBezier :: (Unbox a, Fractional a, GenericBezier b) => b a -> a -> (b a, b a)

-- | Return <tt>False</tt> if some points fall outside a line with a
--   thickness of the given tolerance.
colinear :: CubicBezier Double -> Double -> Bool

-- | Calculate a value on the bezier curve.
evalBezier :: (GenericBezier b, Unbox a, Fractional a) => b a -> a -> V2 a

-- | Calculate a value and the first derivative on the curve.
evalBezierDeriv :: (Unbox a, Fractional a, GenericBezier b) => b a -> a -> (V2 a, V2 a)

-- | Find the parameter where the bezier curve is horizontal.
bezierHoriz :: CubicBezier Double -> [Double]

-- | Find the parameter where the bezier curve is vertical.
bezierVert :: CubicBezier Double -> [Double]

-- | Return the subsegment between the two parameters.
bezierSubsegment :: (Ord a, Unbox a, Fractional a, GenericBezier b) => b a -> a -> a -> b a

-- | Reorient to the curve B(1-t).
reorient :: (GenericBezier b, Unbox a) => b a -> b a

-- | Return the closed path as a list of curves.
closedPathCurves :: Fractional a => ClosedPath a -> [CubicBezier a]

-- | Return the open path as a list of curves.
openPathCurves :: Fractional a => OpenPath a -> [CubicBezier a]

-- | Make an open path from a list of curves. The last control point of
--   each curve is ignored.
curvesToClosed :: [CubicBezier a] -> ClosedPath a

-- | Find the closest value on the bezier to the given point, within
--   tolerance. Return the first value found.
closest :: CubicBezier Double -> V2 Double -> Double -> Double

-- | Create a normal path from a metapath.
unmetaOpen :: OpenMetaPath Double -> OpenPath Double

-- | Create a normal path from a metapath.
unmetaClosed :: ClosedMetaPath Double -> ClosedPath Double

-- | `O((n+m)*log(n+m))`, for n segments and m intersections. Union of
--   paths, removing overlap and rounding to the given tolerance.
union :: [ClosedPath Double] -> FillRule -> Double -> [ClosedPath Double]

-- | Find the intersections between two Bezier curves, using the Bezier
--   Clip algorithm. Returns the parameters for both curves.
bezierIntersection :: CubicBezier Double -> CubicBezier Double -> Double -> [(Double, Double)]

-- | Interpolate between two vectors.
interpolateVector :: Num a => V2 a -> V2 a -> a -> V2 a

-- | Distance between two vectors.
vectorDistance :: Floating a => V2 a -> V2 a -> a

-- | Find inflection points on the curve.
findBezierInflection :: CubicBezier Double -> [Double]

-- | Find the cusps of a bezier.
findBezierCusp :: CubicBezier Double -> [Double]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Geom2D.CubicBezier.Linear.CubicBezier a)
instance GHC.Show.Show a => GHC.Show.Show (Geom2D.CubicBezier.Linear.CubicBezier a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Geom2D.CubicBezier.Linear.QuadBezier a)
instance GHC.Show.Show a => GHC.Show.Show (Geom2D.CubicBezier.Linear.QuadBezier a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Geom2D.CubicBezier.Linear.PathJoin a)
instance GHC.Show.Show a => GHC.Show.Show (Geom2D.CubicBezier.Linear.PathJoin a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Geom2D.CubicBezier.Linear.ClosedPath a)
instance GHC.Show.Show a => GHC.Show.Show (Geom2D.CubicBezier.Linear.ClosedPath a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Geom2D.CubicBezier.Linear.OpenPath a)
instance GHC.Show.Show a => GHC.Show.Show (Geom2D.CubicBezier.Linear.OpenPath a)
instance GHC.Show.Show a => GHC.Show.Show (Geom2D.CubicBezier.Linear.Tension a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Geom2D.CubicBezier.Linear.Tension a)
instance Data.Traversable.Traversable Geom2D.CubicBezier.Linear.Tension
instance Data.Foldable.Foldable Geom2D.CubicBezier.Linear.Tension
instance GHC.Base.Functor Geom2D.CubicBezier.Linear.Tension
instance GHC.Classes.Eq a => GHC.Classes.Eq (Geom2D.CubicBezier.Linear.MetaNodeType a)
instance GHC.Show.Show a => GHC.Show.Show (Geom2D.CubicBezier.Linear.MetaNodeType a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Geom2D.CubicBezier.Linear.MetaJoin a)
instance GHC.Show.Show a => GHC.Show.Show (Geom2D.CubicBezier.Linear.MetaJoin a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Geom2D.CubicBezier.Linear.OpenMetaPath a)
instance GHC.Show.Show a => GHC.Show.Show (Geom2D.CubicBezier.Linear.OpenMetaPath a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Geom2D.CubicBezier.Linear.ClosedMetaPath a)
instance GHC.Show.Show a => GHC.Show.Show (Geom2D.CubicBezier.Linear.ClosedMetaPath a)
instance Geom2D.CubicBezier.Basic.GenericBezier Geom2D.CubicBezier.Linear.QuadBezier
instance Geom2D.CubicBezier.Basic.GenericBezier Geom2D.CubicBezier.Linear.CubicBezier
instance Geom2D.CubicBezier.Basic.GenericBezier Geom2D.CubicBezier.Linear.AnyBezier
instance Geom2D.CubicBezier.Linear.Cast a b => Geom2D.CubicBezier.Linear.Cast [a] [b]
instance (Geom2D.CubicBezier.Linear.Cast a a', Geom2D.CubicBezier.Linear.Cast b b') => Geom2D.CubicBezier.Linear.Cast (a, b) (a', b')
instance Geom2D.CubicBezier.Linear.Cast (Linear.V2.V2 a) (Geom2D.Point a)
instance Geom2D.CubicBezier.Linear.Cast Graphics.SvgTree.Types.Basic.FillRule Geom2D.CubicBezier.Overlap.FillRule
instance Geom2D.CubicBezier.Linear.Cast (Geom2D.CubicBezier.Linear.CubicBezier a) (Geom2D.CubicBezier.Basic.CubicBezier a)
instance Geom2D.CubicBezier.Linear.Cast (Geom2D.CubicBezier.Linear.QuadBezier a) (Geom2D.CubicBezier.Basic.QuadBezier a)
instance Data.Vector.Unboxed.Base.Unbox a => Geom2D.CubicBezier.Linear.Cast (Geom2D.CubicBezier.Linear.AnyBezier a) (Geom2D.CubicBezier.Basic.AnyBezier a)
instance Geom2D.CubicBezier.Linear.Cast (Geom2D.CubicBezier.Linear.MetaNodeType a) (Geom2D.CubicBezier.MetaPath.MetaNodeType a)
instance Geom2D.CubicBezier.Linear.Cast (Geom2D.CubicBezier.Linear.Tension a) (Geom2D.CubicBezier.MetaPath.Tension a)
instance Geom2D.CubicBezier.Linear.Cast (Geom2D.CubicBezier.Linear.MetaJoin a) (Geom2D.CubicBezier.MetaPath.MetaJoin a)
instance Geom2D.CubicBezier.Linear.Cast (Geom2D.CubicBezier.Linear.PathJoin a) (Geom2D.CubicBezier.Basic.PathJoin a)
instance Geom2D.CubicBezier.Linear.Cast (Geom2D.CubicBezier.Linear.OpenMetaPath a) (Geom2D.CubicBezier.MetaPath.OpenMetaPath a)
instance Geom2D.CubicBezier.Linear.Cast (Geom2D.CubicBezier.Linear.ClosedMetaPath a) (Geom2D.CubicBezier.MetaPath.ClosedMetaPath a)
instance Geom2D.CubicBezier.Linear.Cast (Geom2D.CubicBezier.Linear.OpenPath a) (Geom2D.CubicBezier.Basic.OpenPath a)
instance Geom2D.CubicBezier.Linear.Cast (Geom2D.CubicBezier.Linear.ClosedPath a) (Geom2D.CubicBezier.Basic.ClosedPath a)


-- | A colormap takes a number between 0 and 1 (inclusive) and spits out a
--   color. The colors do not have an alpha component but one can be added
--   with <a>promotePixel</a>.
module Reanimate.ColorMap

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “turbo” color scheme by Anton Mikhailov.
--   
turbo :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “viridis” perceptually-uniform color scheme designed by van
--   der Walt, Smith and Firing for matplotlib, represented as an RGB
--   string.
--   
viridis :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “magma” perceptually-uniform color scheme designed by van der
--   Walt and Smith for matplotlib, represented as an RGB string.
--   
magma :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “inferno” perceptually-uniform color scheme designed by van
--   der Walt and Smith for matplotlib, represented as an RGB string.
--   
inferno :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “plasma” perceptually-uniform color scheme designed by van
--   der Walt and Smith for matplotlib, represented as an RGB string.
--   
plasma :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “sinebow” color scheme by Jim Bumgardner and Charlie Loyd.
--   
sinebow :: Double -> PixelRGB8

-- | Parula is the default colormap for matlab.
--   
parula :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “cividis” color vision deficiency-optimized color scheme
--   designed by Nuñez, Anderton, and Renslow, represented as an RGB
--   string.
--   
cividis :: Double -> PixelRGB8

-- | Jet colormap. Used to be the default in matlab. Obsolete.
--   
jet :: Double -> PixelRGB8

-- | hsv colormap. Goes from 0 degrees to 360 degrees.
--   
hsv :: Double -> PixelRGB8

-- | Matlab hsv colormap. Goes from 0 degrees to 330 degrees.
--   
hsvMatlab :: Double -> PixelRGB8

-- | Greyscale colormap.
--   
greyscale :: Double -> PixelRGB8


module Reanimate.ColorSpace

-- | Wavelengths in nanometers.
type Nanometer = Integer

-- | Cone sensitivity by light wavelength.
coneSensitivity :: Map Nanometer (Double, Double, Double)

-- | (big) XYZ values for each wavelength of light.
bigXYZCoordinates :: Map Nanometer (Double, Double, Double)

-- | (small) xyz values for each wavelength of light.
lightXYZCoordinates :: Map Nanometer (Double, Double, Double)

-- | Helper function for converting a wavelength of light into the
--   perceived color.
nmToColor :: Nanometer -> Maybe (Colour Double)


-- | Reanimate configures a consistent, default canvas. The values of this
--   default can be observed via the constants in this module. Keep in
--   mind, these values describe the <i>default</i> canvas and will not
--   apply to custom viewports.
module Reanimate.Constants

-- | Number of units from the left-most point to the right-most point on
--   the screen.
screenWidth :: Fractional a => a

-- | Number of units from the bottom to the top of the screen.
screenHeight :: Fractional a => a

-- | Position of the top of the screen.
screenTop :: Fractional a => a

-- | Position of the bottom of the screen.
screenBottom :: Fractional a => a

-- | Position of the left side of the screen.
screenLeft :: Fractional a => a

-- | Position of the right side of the screen.
screenRight :: Fractional a => a

-- | SVG allows measurements in inches which have to be converted to local
--   units. This value describes how many local units there are in an inch.
defaultDPI :: Dpi

-- | Default thickness of lines.
defaultStrokeWidth :: Double


-- | Easing functions modify the rate of change in animations. More
--   examples can be seen here: <a>https://easings.net/</a>.
module Reanimate.Ease

-- | Signals are time-varying variables. Signals can be composed using
--   function composition.
type Signal = Double -> Double

-- | Constant signal.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>constantS</a> 0.5) <a>drawProgress</a>
--   </pre>
--   
constantS :: Double -> Signal

-- | Signal with new starting and end values.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>fromToS</a> 0.8 0.2) <a>drawProgress</a>
--   </pre>
--   
fromToS :: Double -> Double -> Signal

-- | Reverse signal order.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> <a>reverseS</a> <a>drawProgress</a>
--   </pre>
--   
reverseS :: Signal

-- | S-curve signal. Takes a steepness parameter. 2 is a good default.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>curveS</a> 2) <a>drawProgress</a>
--   </pre>
--   
curveS :: Double -> Signal

-- | Power curve signal. Takes a steepness parameter. 2 is a good default.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>powerS</a> 2) <a>drawProgress</a>
--   </pre>
--   
powerS :: Double -> Signal

-- | Bell-curve signal. Takes a steepness parameter. 2 is a good default.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>bellS</a> 2) <a>drawProgress</a>
--   </pre>
--   
bellS :: Double -> Signal

-- | Oscillate signal.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> <a>oscillateS</a> <a>drawProgress</a>
--   </pre>
--   
oscillateS :: Signal

-- | Cubic Bezier signal. Gives you a fair amount of control over how the
--   signal will curve.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>cubicBezierS</a> (0.0, 0.8, 0.9, 1.0)) <a>drawProgress</a>
--   </pre>
--   
cubicBezierS :: (Double, Double, Double, Double) -> Signal


-- | Colors are three dimensional and can be projected into many color
--   spaces with different properties.
--   
--   Interpolating directly in the RGB color space is unintuitive and
--   rarely useful. If you want to transition through color, you most
--   likely want either the XYZ space (for physically accurate color
--   transitions) or the LAB space (for esthetically pleasing colors).
module Reanimate.ColorComponents

-- | Constructor and destructor for color's three components.
data ColorComponents
ColorComponents :: (Colour Double -> (Double, Double, Double)) -> (Double -> Double -> Double -> Colour Double) -> ColorComponents

-- | Unpack a color into its three components.
[colorUnpack] :: ColorComponents -> Colour Double -> (Double, Double, Double)

-- | Restore a color from three coordinates.
[colorPack] :: ColorComponents -> Double -> Double -> Double -> Colour Double

-- | <pre>
--   interpolate rgbComponents yellow blue
--   </pre>
--   
rgbComponents :: ColorComponents

-- | <pre>
--   interpolate hsvComponents yellow blue
--   </pre>
--   
hsvComponents :: ColorComponents

-- | <pre>
--   interpolate labComponents yellow blue
--   </pre>
--   
labComponents :: ColorComponents

-- | <pre>
--   interpolate xyzComponents yellow blue
--   </pre>
--   
xyzComponents :: ColorComponents

-- | <pre>
--   interpolate lchComponents yellow blue
--   </pre>
--   
lchComponents :: ColorComponents

-- | Smoothly interpolate between two colors using the given color
--   components.
interpolate :: ColorComponents -> Colour Double -> Colour Double -> Double -> Colour Double

-- | Convenience interpolation function for RGB8 values.
interpolateRGB8 :: ColorComponents -> PixelRGB8 -> PixelRGB8 -> Double -> PixelRGB8

-- | Convenience interpolation function for RGBA8 values.
interpolateRGBA8 :: ColorComponents -> PixelRGBA8 -> PixelRGBA8 -> Double -> PixelRGBA8

-- | Convenience function for expressing a color as an RGB8 value.
toRGB8 :: Colour Double -> PixelRGB8

-- | Convenience function for expressing an RGB8 value as a color.
fromRGB8 :: PixelRGB8 -> Colour Double


-- | Low-level primitives related to computational geometry.
module Reanimate.Math.Common

-- | Circular collection of pairs.
newtype Ring a
Ring :: Vector (V2 a) -> Ring a

-- | Number of elements in the ring.
ringSize :: Ring a -> Int

-- | Safe method for accessing elements in the ring.
ringAccess :: Ring a -> Int -> V2 a

-- | Clamp index to within the usable range for the ring.
ringClamp :: Ring a -> Int -> Int

-- | Convert ring to a vector.
ringUnpack :: Ring a -> Vector (V2 a)

-- | Convert vector to a ring.
ringPack :: Vector (V2 a) -> Ring a

-- | Map each element of a ring.
ringMap :: (V2 a -> V2 b) -> Ring a -> Ring b

-- | Compute the intersection of two pairs of nodes in the ring.
ringRayIntersect :: Ring Rational -> (Int, Int) -> (Int, Int) -> Maybe (V2 Rational)

-- | Compute area of triangle.
area :: Fractional a => V2 a -> V2 a -> V2 a -> a

-- | Compute 2x area of triangle. This avoids a division.
area2X :: Fractional a => V2 a -> V2 a -> V2 a -> a

-- | Return <tt>True</tt> iff the line from <tt>p1</tt> to <tt>p2</tt>
--   makes a left-turn to <tt>p3</tt>.
isLeftTurn :: (Fractional a, Ord a, Epsilon a) => V2 a -> V2 a -> V2 a -> Bool

-- | Return <tt>True</tt> iff the line from <tt>p1</tt> to <tt>p2</tt> does
--   not make a right-turn to <tt>p3</tt>.
isLeftTurnOrLinear :: (Fractional a, Ord a, Epsilon a) => V2 a -> V2 a -> V2 a -> Bool

-- | Return <tt>True</tt> iff the line from <tt>p1</tt> to <tt>p2</tt>
--   makes a right-turn to <tt>p3</tt>.
isRightTurn :: (Fractional a, Ord a, Epsilon a) => V2 a -> V2 a -> V2 a -> Bool

-- | Return <tt>True</tt> iff the line from <tt>p1</tt> to <tt>p2</tt> does
--   not make a left-turn to <tt>p3</tt>.
isRightTurnOrLinear :: (Fractional a, Ord a, Epsilon a) => V2 a -> V2 a -> V2 a -> Bool

-- | Compute the change in direction in a line between the three points.
direction :: Num a => V2 a -> V2 a -> V2 a -> a

-- | Returns <tt>True</tt> if the fourth argument is inside the triangle or
--   on the border.
isInside :: (Fractional a, Ord a) => V2 a -> V2 a -> V2 a -> V2 a -> Bool

-- | Returns <tt>True</tt> iff the fourth argument is inside the triangle.
isInsideStrict :: (Fractional a, Ord a) => V2 a -> V2 a -> V2 a -> V2 a -> Bool

-- | Compute relative coordinates inside the triangle. Invariant:
--   <tt>a+b+c=1</tt>
barycentricCoords :: Fractional a => V2 a -> V2 a -> V2 a -> V2 a -> (a, a, a)

-- | Compute intersection of two infinite lines.
rayIntersect :: (Fractional a, Ord a) => (V2 a, V2 a) -> (V2 a, V2 a) -> Maybe (V2 a)

-- | Returns <tt>True</tt> iff a point is on a line segment.
isBetween :: (Ord a, Fractional a) => V2 a -> (V2 a, V2 a) -> Bool

-- | Compute intersection of two line segments.
lineIntersect :: (Ord a, Fractional a) => (V2 a, V2 a) -> (V2 a, V2 a) -> Maybe (V2 a)

-- | Compute the square of the distance between two points.
distSquared :: Num a => V2 a -> V2 a -> a

-- | Approximate the distance between two points.
approxDist :: (Real a, Fractional a) => V2 a -> V2 a -> a

-- | Approximate the distance between two points.
distance' :: (Real a, Fractional a) => V2 a -> V2 a -> Double

-- | Approximate the angles of a triangle.
triangleAngles :: V2 Double -> V2 Double -> V2 Double -> (Double, Double, Double)

-- | Provides a fairly subjective test to see if a quantity is near zero.
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-11 :: Double)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-17 :: Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-5 :: Float)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-7 :: Float)
--   True
--   </pre>
class Num a => Epsilon a

-- | Determine if a quantity is near zero.
nearZero :: Epsilon a => a -> Bool
instance Linear.Epsilon.Epsilon GHC.Real.Rational


-- | With animations defined as SVG images over time, it is unfortunately
--   quite easy to write inefficient code where expensive expressions are
--   re-evaluated for every frame even if nothing has changed. This get
--   around this issue, this module defines a global key-value table that
--   can store expensive expressions such that they are evaluated only
--   once.
--   
--   There is currently no way to clear values from the table and it is
--   your own responsibility to not consume all available memory.
module Reanimate.Memo

-- | Keys can either by any boxed object with identity (to be compared with
--   StableNames) or a primitive type with an Eq instance.
data Key
Key :: !a -> Key
KeyPrim :: !a -> Key

-- | Cache expensive value in global store. You must guarantee that the key
--   uniquely determines the value.
memo :: Typeable a => [Key] -> a -> a
instance GHC.Classes.Eq Reanimate.Memo.DynamicName
instance GHC.Classes.Ord Reanimate.Memo.DynamicName


-- | Parameters define the global context of an animation. They are set
--   once before an animation is rendered and may not change during
--   rendering.
module Reanimate.Parameters

-- | Raster engines turn SVG images into pixels.
data Raster

-- | Do not use any external raster engine. Rely on the browser or ffmpeg.
RasterNone :: Raster

-- | Scan for installed raster engines and pick the fastest one.
RasterAuto :: Raster

-- | Use Inkscape to raster SVG images.
RasterInkscape :: Raster

-- | Use rsvg-convert to raster SVG images.
RasterRSvg :: Raster

-- | Use imagemagick to raster SVG images.
RasterMagick :: Raster

-- | Width of animation in pixels.
type Width = Int

-- | Height of animation in pixels.
type Height = Int

-- | Framerate of animation in frames per second.
type FPS = Int

-- | Selected raster engine.
pRaster :: Raster

-- | Selected framerate.
pFPS :: FPS

-- | Width of animation in pixel.
pWidth :: Width

-- | Height of animation in pixel.
pHeight :: Height

-- | This parameter determined whether or not external tools are allowed.
--   If this flag is True then tools such as <a>latex</a> and
--   <a>blender</a> will not be invoked.
pNoExternals :: Bool

-- | Root directory of animation. Images and other data has to be placed
--   here if they are referenced in an SVG image.
pRootDirectory :: FilePath

-- | Set raster engine.
setRaster :: Raster -> IO ()

-- | Set desired framerate.
setFPS :: FPS -> IO ()

-- | Set desired width of animation in pixel.
setWidth :: Width -> IO ()

-- | Set desired height of animation in pixel.
setHeight :: Height -> IO ()

-- | Set whether external tools are allowed.
setNoExternals :: Bool -> IO ()

-- | Set the root animation directory.
setRootDirectory :: FilePath -> IO ()
instance GHC.Classes.Eq Reanimate.Parameters.Raster
instance GHC.Show.Show Reanimate.Parameters.Raster


module Reanimate.Svg.LineCommand

-- | Line command monad used for keeping track of the current location.
type CmdM a = State RPoint a

-- | Simplified version of a PathCommand where all points are absolute.
data LineCommand
LineMove :: RPoint -> LineCommand

-- | LineDraw RPoint
LineBezier :: [RPoint] -> LineCommand
LineEnd :: RPoint -> LineCommand

-- | Estimated length of all segments in a line.
lineLength :: LineCommand -> CmdM Double

-- | Convert from path commands to line commands.
toLineCommands :: [PathCommand] -> [LineCommand]

-- | Convert from line commands to path commands.
lineToPath :: [LineCommand] -> [PathCommand]

-- | Using <tt>n</tt> control points, approximate the path of the curves.
lineToPoints :: Int -> [LineCommand] -> [RPoint]

-- | Create an image showing portion of a path. Note that this only affects
--   paths (see <a>mkPath</a>). You can also use this with other SVG shapes
--   if you convert them to path first (see <a>pathify</a>).
--   
--   Typical usage:
--   
--   <pre>
--   animate $ \t -&gt; partialSvg t myPath
--   </pre>
partialSvg :: Double -> Tree -> Tree
instance GHC.Show.Show Reanimate.Svg.LineCommand.LineCommand


-- | 2D transformation matrices capable of translating, scaling, rotating,
--   and skewing.
module Reanimate.Transform

-- | Identity matrix.
--   
--   <pre>
--   transformPoints identity x = x
--   </pre>
identity :: Matrix Coord

-- | Apply a transformation matrix to a 2D point.
transformPoint :: Matrix Coord -> RPoint -> RPoint

-- | Convert multiple SVG transformations into a single transformation
--   matrix.
mkMatrix :: Maybe [Transformation] -> Matrix Coord

-- | Convert a transformation matrix back into an SVG transformation.
toTransformation :: Matrix Coord -> Transformation


-- | Bounding-boxes can be immensely useful for aligning objects but they
--   are not part of the SVG specification and cannot be computed for all
--   SVG nodes. In particular, you'll get bad results when asking for the
--   bounding boxes of Text nodes (because fonts are difficult), clipped
--   nodes, and filtered nodes.
module Reanimate.Svg.BoundingBox

-- | Return bounding box of SVG tree. The four numbers returned are
--   (minimal X-coordinate, minimal Y-coordinate, width, height)
--   
--   Note: Bounding boxes are computed on a best-effort basis and will not
--   work in all cases. The only supported SVG nodes are: path, circle,
--   polyline, ellipse, line, rectangle, image. All other nodes return
--   (0,0,0,0).
boundingBox :: Tree -> (Double, Double, Double, Double)

-- | Height of SVG node in local units (not pixels). Computed on
--   best-effort basis and will not give accurate results for all SVG
--   nodes.
svgHeight :: Tree -> Double

-- | Width of SVG node in local units (not pixels). Computed on best-effort
--   basis and will not give accurate results for all SVG nodes.
svgWidth :: Tree -> Double


-- | Functions for creating basic SVG elements and applying transformations
--   to them.
module Reanimate.Svg.Constructors

-- | Create a circle with given radius, centered at <tt>(0, 0)</tt>. See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle</a>
mkCircle :: Double -> Tree

-- | Create an ellipse given X-axis radius, and Y-axis radius, with center
--   at <tt>(0, 0)</tt>. See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Element/ellipse</a>
mkEllipse :: Double -> Double -> Tree

-- | <tt>mkRect width height</tt> creates a rectangle with given
--   <tt>with</tt> and <tt>height</tt>, centered at <tt>(0, 0)</tt>. See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect</a>
mkRect :: Double -> Double -> Tree

-- | Create a line segment between two points given by their <tt>(x,
--   y)</tt> coordinates. See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Element/line</a>
mkLine :: (Double, Double) -> (Double, Double) -> Tree

-- | Create a path from the list of path commands. See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#Path_commands</a>
mkPath :: [PathCommand] -> Tree

-- | Similar to <a>mkPathText</a>, but taking SVG path command as a String.
mkPathString :: String -> Tree

-- | Create path from textual representation of SVG path command. If the
--   text doesn't represent valid path command, this function fails with
--   <a>error</a>. Use <a>mkPath</a> for type safe way of creating paths.
mkPathText :: Text -> Tree

-- | Create a path from a list of <tt>(x, y)</tt> coordinates of points
--   along the path.
mkLinePath :: [(Double, Double)] -> Tree

-- | Create a path from a list of <tt>(x, y)</tt> coordinates of points
--   along the path.
mkLinePathClosed :: [(Double, Double)] -> Tree

-- | A clip path restricts the region to which paint can be applied. See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Element/clipPath</a>
mkClipPath :: String -> [Tree] -> Tree

-- | Insert a native text object anchored at the middle.
--   
--   Example:
--   
--   <pre>
--   <a>mkAnimation</a> 2 $ \t -&gt; <a>scale</a> 2 $ <a>withStrokeWidth</a> 0.05 $ <a>mkText</a> (T.take (round $ t*15) "text")
--   </pre>
--   
mkText :: Text -> Tree

-- | Merges multiple images into one. See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Element/g</a>
mkGroup :: [Tree] -> Tree

-- | Create definition of graphical objects that can be used at later time.
--   See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs</a>
mkDefinitions :: [Tree] -> Tree

-- | Create an element by referring to existing element defined previously.
--   For example you can create a graphical element, assign ID to it using
--   <a>withId</a>, wrap it in <a>mkDefinitions</a> and then use it via
--   <tt>use "myId"</tt>. See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Element/use</a>
mkUse :: String -> Tree

-- | Assigns ID attribute to given image.
withId :: String -> Tree -> Tree

-- | See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke</a>
withStrokeColor :: String -> Tree -> Tree

-- | See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke</a>
withStrokeColorPixel :: PixelRGBA8 -> Tree -> Tree

-- | See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray</a>
withStrokeDashArray :: [Double] -> Tree -> Tree

-- | See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-linejoin</a>
withStrokeLineJoin :: LineJoin -> Tree -> Tree

-- | See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill</a>
withFillColor :: String -> Tree -> Tree

-- | See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill</a>
withFillColorPixel :: PixelRGBA8 -> Tree -> Tree

-- | See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity</a>
withFillOpacity :: Double -> Tree -> Tree

-- | See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/opacity</a>
withGroupOpacity :: Double -> Tree -> Tree

-- | See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width</a>
withStrokeWidth :: Double -> Tree -> Tree

-- | See
--   <a>https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/clip-path</a>
withClipPathRef :: ElementRef -> Tree -> Tree

-- | Translate given image so that the center of its bouding box coincides
--   with coordinates <tt>(0, 0)</tt>.
center :: Tree -> Tree

-- | Translate given image so that the X-coordinate of the center of its
--   bouding box is 0.
centerX :: Tree -> Tree

-- | Translate given image so that the Y-coordinate of the center of its
--   bouding box is 0.
centerY :: Tree -> Tree

-- | Center the second argument using the bounding-box of the first.
centerUsing :: Tree -> Tree -> Tree

-- | <tt>translate x y image</tt> moves the <tt>image</tt> by <tt>x</tt>
--   along X-axis and by <tt>y</tt> along Y-axis.
translate :: Double -> Double -> Tree -> Tree

-- | <tt>rotate angle image</tt> rotates the <tt>image</tt> around origin
--   <tt>(0,0)</tt> counterclockwise by <tt>angle</tt> given in degrees.
rotate :: Double -> Tree -> Tree

-- | <tt>rotate angle image</tt> rotates the <tt>image</tt> around the
--   center of its bounding box counterclockwise by <tt>angle</tt> given in
--   degrees.
rotateAroundCenter :: Double -> Tree -> Tree

-- | <tt>rotate angle point image</tt> rotates the <tt>image</tt> around
--   given <tt>point</tt> counterclockwise by <tt>angle</tt> given in
--   degrees.
rotateAround :: Double -> RPoint -> Tree -> Tree

-- | Scale the image uniformly by given factor along both X and Y axes. For
--   example <tt>scale 2 image</tt> makes the image twice as large, while
--   <tt>scale 0.5 image</tt> makes it half the original size. Negative
--   values are also allowed, and lead to flipping the image along both X
--   and Y axes.
scale :: Double -> Tree -> Tree

-- | <tt>scaleToSize width height</tt> resizes the image so that its
--   bounding box has corresponding <tt>width</tt> and <tt>height</tt>.
scaleToSize :: Double -> Double -> Tree -> Tree

-- | <tt>scaleToWidth width</tt> scales the image so that the width of its
--   bounding box ends up having given <tt>width</tt>.
scaleToWidth :: Double -> Tree -> Tree

-- | <tt>scaleToHeight height</tt> scales the image so that the height of
--   its bounding box ends up having given <tt>height</tt>.
scaleToHeight :: Double -> Tree -> Tree

-- | Similar to <a>scale</a>, except scale factors for X and Y axes are
--   specified separately.
scaleXY :: Double -> Double -> Tree -> Tree

-- | Flip the image along vertical axis so that what was on the right will
--   end up on left and vice versa.
flipXAxis :: Tree -> Tree

-- | Flip the image along horizontal so that what was on the top will end
--   up in the bottom and vice versa.
flipYAxis :: Tree -> Tree

-- | <tt>aroundCenter f image</tt> first moves the image so the center of
--   its bounding box is at the origin <tt>(0, 0)</tt>, applies
--   transformation <tt>f</tt> to it and then moves the transformed image
--   back to its original position.
aroundCenter :: (Tree -> Tree) -> Tree -> Tree

-- | Same as <a>aroundCenter</a> but only for the X-axis.
aroundCenterX :: (Tree -> Tree) -> Tree -> Tree

-- | Same as <a>aroundCenter</a> but only for the Y-axis.
aroundCenterY :: (Tree -> Tree) -> Tree -> Tree

-- | Apply list of transformations to given image.
withTransformations :: [Transformation] -> Tree -> Tree

-- | Switch from the default viewbox to a custom viewbox. Nesting custom
--   viewboxes is unlikely to give good results. If you need nested custom
--   viewboxes, you will have to configure them by hand.
--   
--   The viewbox argument is (min-x, min-y, width, height).
--   
--   Example:
--   
--   <pre>
--   <a>withViewBox</a> (0,0,1,1) $ <a>mkBackground</a> "yellow"
--   </pre>
--   
withViewBox :: (Double, Double, Double, Double) -> Tree -> Tree

-- | Create <a>Texture</a> based on SVG color name. See
--   <a>https://en.wikipedia.org/wiki/Web_colors#X11_color_names</a> for
--   the list of available names. If the provided name doesn't correspond
--   to valid SVG color name, white-ish color is used.
mkColor :: String -> Texture

-- | Rectangle with a uniform color and the same size as the screen.
--   
--   Example:
--   
--   <pre>
--   <a>animate</a> $ <a>const</a> $ <a>mkBackground</a> "yellow"
--   </pre>
--   
mkBackground :: String -> Tree

-- | Rectangle with a uniform color and the same size as the screen.
mkBackgroundPixel :: PixelRGBA8 -> Tree

-- | Take list of rows, where each row consists of number of images and
--   display them in regular grid structure. All rows will get equal amount
--   of vertical space. The images within each row will get equal amount of
--   horizontal space, independent of the other rows. Each row can contain
--   different number of cells.
gridLayout :: [[Tree]] -> Tree


module Reanimate.Svg.Unuse

-- | Replace all <tt><a>use</a></tt> nodes with their definition.
replaceUses :: Document -> Document

-- | Transform out viewbox. Definitions and CSS rules are discarded.
unbox :: Document -> Tree

-- | Transform out viewbox and fit image to screen size.
unboxFit :: Document -> Tree

-- | Embed <a>Document</a>. This keeps the entire document intact but makes
--   it more difficult to use, say, <a>pathify</a> on it.
embedDocument :: Document -> Tree


-- | Declarative animation API based on combinators. For a higher-level
--   interface, see <a>Scene</a>.
module Reanimate.Animation

-- | Duration of an animation or effect. Usually measured in seconds.
type Duration = Double

-- | Time signal. Goes from 0 to 1, inclusive.
type Time = Double

-- | SVG node.
type SVG = Tree

-- | Animations are SVGs over a finite time.
data Animation

-- | Construct an animation with a given duration.
mkAnimation :: Duration -> (Time -> SVG) -> Animation

-- | Construct an animation with a duration of <tt>1</tt>.
animate :: (Time -> SVG) -> Animation

-- | Create an animation with provided <tt>duration</tt>, which consists of
--   stationary frame displayed for its entire duration.
staticFrame :: Duration -> SVG -> Animation

-- | Empty animation (no SVG output) with a fixed duration.
--   
--   Example:
--   
--   <pre>
--   <a>pause</a> 1 `<a>seqA</a>` <a>drawProgress</a>
--   </pre>
--   
pause :: Duration -> Animation

-- | Query the duration of an animation.
duration :: Animation -> Duration

-- | Calculate the frame that would be displayed at given point in
--   <tt>time</tt> of running <tt>animation</tt>.
--   
--   The provided time parameter is clamped between 0 and animation
--   duration.
frameAt :: Time -> Animation -> SVG

-- | Play animations in sequence. The <tt>lhs</tt> animation is removed
--   after it has completed. New animation duration is '<tt>duration lhs +
--   duration rhs</tt>'.
--   
--   Example:
--   
--   <pre>
--   <a>drawBox</a> `<a>seqA</a>` <a>drawCircle</a>
--   </pre>
--   
seqA :: Animation -> Animation -> Animation

-- | Play left animation and freeze on the last frame, then play the right
--   animation. New duration is '<tt>duration lhs + duration rhs</tt>'.
--   
--   Example:
--   
--   <pre>
--   <a>drawBox</a> `<a>andThen</a>` <a>drawCircle</a>
--   </pre>
--   
andThen :: Animation -> Animation -> Animation

-- | Play two animation concurrently. Shortest animation freezes on last
--   frame. New animation duration is '<tt>max (duration lhs) (duration
--   rhs)</tt>'.
--   
--   Example:
--   
--   <pre>
--   <a>drawBox</a> `<a>parA</a>` <a>adjustDuration</a> (*2) <a>drawCircle</a>
--   </pre>
--   
parA :: Animation -> Animation -> Animation

-- | Play two animation concurrently. Shortest animation loops. New
--   animation duration is '<tt>max (duration lhs) (duration rhs)</tt>'.
--   
--   Example:
--   
--   <pre>
--   <a>drawBox</a> `<a>parLoopA</a>` <a>adjustDuration</a> (*2) <a>drawCircle</a>
--   </pre>
--   
parLoopA :: Animation -> Animation -> Animation

-- | Play two animation concurrently. Animations disappear after playing
--   once. New animation duration is '<tt>max (duration lhs) (duration
--   rhs)</tt>'.
--   
--   Example:
--   
--   <pre>
--   <a>drawBox</a> `<a>parDropA</a>` <a>adjustDuration</a> (*2) <a>drawCircle</a>
--   </pre>
--   
parDropA :: Animation -> Animation -> Animation

-- | Set the duration of an animation by adjusting its playback rate. The
--   animation is still played from start to finish without being cropped.
setDuration :: Duration -> Animation -> Animation

-- | Change the duration of an animation. Animates are stretched or
--   squished (rather than truncated) to fit the new duration.
adjustDuration :: (Duration -> Duration) -> Animation -> Animation

-- | Map over the SVG produced by an animation at every frame.
--   
--   Example:
--   
--   <pre>
--   <a>mapA</a> (<tt>scale</tt> 0.5) <a>drawCircle</a>
--   </pre>
--   
mapA :: (SVG -> SVG) -> Animation -> Animation

-- | <tt>takeA duration animation</tt> creates a new animation consisting
--   of initial segment of <tt>animation</tt> of given <tt>duration</tt>,
--   played at the same rate as the original animation.
--   
--   The <tt>duration</tt> parameter is clamped to be between 0 and
--   <tt>animation</tt>'s duration. New animation duration is equal to
--   (eventually clamped) <tt>duration</tt>.
takeA :: Duration -> Animation -> Animation

-- | <tt>dropA duration animation</tt> creates a new animation by dropping
--   initial segment of length <tt>duration</tt> from the provided
--   <tt>animation</tt>, played at the same rate as the original animation.
--   
--   The <tt>duration</tt> parameter is clamped to be between 0 and
--   <tt>animation</tt>'s duration. The duration of the resulting animation
--   is duration of provided <tt>animation</tt> minus (eventually clamped)
--   <tt>duration</tt>.
dropA :: Duration -> Animation -> Animation

-- | <tt>lastA duration animation</tt> return the last <tt>duration</tt>
--   seconds of the animation.
lastA :: Duration -> Animation -> Animation

-- | Freeze the last frame for <tt>t</tt> seconds at the end of the
--   animation.
--   
--   Example:
--   
--   <pre>
--   <a>pauseAtEnd</a> 1 <a>drawProgress</a>
--   </pre>
--   
pauseAtEnd :: Duration -> Animation -> Animation

-- | Freeze the first frame for <tt>t</tt> seconds at the beginning of the
--   animation.
--   
--   Example:
--   
--   <pre>
--   <a>pauseAtBeginning</a> 1 <a>drawProgress</a>
--   </pre>
--   
pauseAtBeginning :: Duration -> Animation -> Animation

-- | Freeze the first and the last frame of the animation for a specified
--   duration.
--   
--   Example:
--   
--   <pre>
--   <a>pauseAround</a> 1 1 <a>drawProgress</a>
--   </pre>
--   
pauseAround :: Duration -> Duration -> Animation -> Animation

-- | Loop animation <tt>n</tt> number of times. This number may be
--   fractional and it may be less than 1. It must be greater than or equal
--   to 0, though. New duration is <tt>n*duration input</tt>.
--   
--   Example:
--   
--   <pre>
--   <a>repeatA</a> 1.5 <a>drawCircle</a>
--   </pre>
--   
repeatA :: Double -> Animation -> Animation

-- | Play an animation in reverse. Duration remains unchanged. Shorthand
--   for: <tt><a>signalA</a> <a>reverseS</a></tt>.
--   
--   Example:
--   
--   <pre>
--   <a>reverseA</a> <a>drawCircle</a>
--   </pre>
--   
reverseA :: Animation -> Animation

-- | Play animation before playing it again in reverse. Duration is twice
--   the duration of the input.
--   
--   Example:
--   
--   <pre>
--   <a>playThenReverseA</a> <a>drawCircle</a>
--   </pre>
--   
playThenReverseA :: Animation -> Animation

-- | Modify the time component of an animation. Animation duration is
--   unchanged.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<tt>fromToS</tt> 0.25 0.75) <a>drawCircle</a>
--   </pre>
--   
signalA :: Signal -> Animation -> Animation

-- | <tt>freezeAtPercentage time animation</tt> creates an animation
--   consisting of stationary frame, that would be displayed in the
--   provided <tt>animation</tt> at given <tt>time</tt>. The duration of
--   the new animation is the same as the duration of provided
--   <tt>animation</tt>.
freezeAtPercentage :: Time -> Animation -> Animation

-- | Overlay animation on top of static SVG image.
--   
--   Example:
--   
--   <pre>
--   <a>addStatic</a> (<tt>mkBackground</tt> "lightblue") <a>drawCircle</a>
--   </pre>
--   
addStatic :: SVG -> Animation -> Animation

-- | Ask for an animation frame using a given synchronization policy.
getAnimationFrame :: Sync -> Animation -> Time -> Duration -> SVG

-- | Animation synchronization policies.
data Sync
SyncStretch :: Sync
SyncLoop :: Sync
SyncDrop :: Sync
SyncFreeze :: Sync

-- | Helper function for pretty-printing SVG nodes.
renderTree :: SVG -> String

-- | Helper function for pretty-printing SVG nodes as SVG documents.
renderSvg :: Maybe Number -> Maybe Number -> SVG -> String


-- | Internal tools for rastering SVGs and rendering videos. You are
--   unlikely to ever directly use the functions in this module.
module Reanimate.Render

-- | Render animation to a video file with given parameters.
render :: Animation -> FilePath -> Raster -> Format -> Width -> Height -> FPS -> Bool -> IO ()

-- | Generate SVGs at 60fps and put them in a folder.
renderSvgs :: FilePath -> Int -> Bool -> Animation -> IO ()
renderSvgs_ :: Animation -> (Int -> FilePath -> IO ()) -> IO ()

-- | Render 10 frames and print them to stdout. Used for testing.
--   
--   XXX: Not related to the snippets in the playground.
renderSnippets :: Animation -> IO ()

-- | Render as many frames as possible in 2 seconds. Limited to 20 frames.
renderLimitedFrames :: FilePath -> Int -> Bool -> Int -> Animation -> IO ()

-- | Video formats supported by reanimate.
data Format
RenderMp4 :: Format
RenderGif :: Format
RenderWebm :: Format

-- | Raster engines turn SVG images into pixels.
data Raster

-- | Do not use any external raster engine. Rely on the browser or ffmpeg.
RasterNone :: Raster

-- | Scan for installed raster engines and pick the fastest one.
RasterAuto :: Raster

-- | Use Inkscape to raster SVG images.
RasterInkscape :: Raster

-- | Use rsvg-convert to raster SVG images.
RasterRSvg :: Raster

-- | Use imagemagick to raster SVG images.
RasterMagick :: Raster

-- | Width of animation in pixels.
type Width = Int

-- | Height of animation in pixels.
type Height = Int

-- | Framerate of animation in frames per second.
type FPS = Int

-- | Resolve RasterNone and RasterAuto. If no valid raster can be found,
--   exit with an error message.
requireRaster :: Raster -> IO Raster

-- | Resolve RasterNone and RasterAuto. If no valid raster can be found,
--   return RasterNone.
selectRaster :: Raster -> IO Raster

-- | Convert SVG file to a PNG file with selected raster engine. If raster
--   engine is RasterAuto or RasterNone, do nothing.
applyRaster :: Raster -> FilePath -> IO ()
instance GHC.Show.Show Reanimate.Render.Format


-- | Tools for generating, manipulating, and embedding raster images.
module Reanimate.Raster

-- | Load an external image. Width and height must be specified, ignoring
--   the image's aspect ratio. The center of the image is placed at
--   position (0,0).
--   
--   For security reasons, must SVG renderer do not allow arbitrary image
--   links. For some renderers, we can get around this by placing the
--   images in the same root directory as the parent SVG file. Other
--   renderers (like Chrome and ffmpeg) requires that the image is inlined
--   as base64 data. External SVG files are an exception, though, as must
--   always be inlined directly. <a>mkImage</a> attempts to hide all the
--   complexity but edge-cases may exist.
--   
--   Example:
--   
--   <pre>
--   <a>mkImage</a> <a>screenWidth</a> <a>screenHeight</a> "../data/haskell.svg"
--   </pre>
--   
mkImage :: Double -> Double -> FilePath -> SVG

-- | Write in-memory image to cache file if (and only if) such cache file
--   doesn't already exist.
cacheImage :: (PngSavable pixel, Hashable a) => a -> Image pixel -> FilePath

-- | Render SVG node to a PNG file and return a new node containing that
--   image. For static SVG nodes, this can hugely improve performance. The
--   first argument is the key that determines SVG uniqueness. It is
--   entirely your responsibility to ensure that all keys are unique. If
--   they are not, you will be served stale results from the cache.
prerenderSvg :: Hashable a => a -> SVG -> SVG

-- | Same as <a>prerenderSvg</a> but returns the location of the rendered
--   image as a FilePath.
prerenderSvgFile :: Hashable a => a -> Width -> Height -> SVG -> FilePath

-- | Embed an in-memory PNG image. Note, the pixel size of the image is
--   used as the dimensions. As such, embedding a 100x100 PNG will result
--   in an image 100 units wide and 100 units high. Consider using with
--   <tt>scaleToSize</tt>.
embedImage :: PngSavable a => Image a -> SVG

-- | Embed an in-memory image. Note, the pixel size of the image is used as
--   the dimensions. As such, embedding a 100x100 image will result in an
--   image 100 units wide and 100 units high. Consider using with
--   <tt>scaleToSize</tt>.
embedDynamicImage :: DynamicImage -> SVG

-- | Embed in-memory PNG bytestring without parsing it.
embedPng :: Double -> Double -> ByteString -> SVG

-- | Convert an SVG object to a pixel-based image. The default resolution
--   is 2560x1440. See also <a>rasterSized</a>. Multiple raster engines are
--   supported and are selected using the '--raster' flag in the driver.
raster :: SVG -> DynamicImage

-- | Convert an SVG object to a pixel-based image.
rasterSized :: Width -> Height -> SVG -> DynamicImage

-- | Use 'potrace' to trace edges in a raster image and convert them to SVG
--   polygons.
vectorize :: FilePath -> SVG

-- | Same as <a>vectorize</a> but takes a list of arguments for 'potrace'.
vectorize_ :: [String] -> FilePath -> SVG

-- | Convert an SVG object to a pixel-based image and save it to disk,
--   returning the filepath. The default resolution is 2560x1440. See also
--   <a>svgAsPngFile'</a>. Multiple raster engines are supported and are
--   selected using the '--raster' flag in the driver.
svgAsPngFile :: SVG -> FilePath

-- | Convert an SVG object to a pixel-based image and save it to disk,
--   returning the filepath.
svgAsPngFile' :: Width -> Height -> SVG -> FilePath

module Reanimate.External

-- | Resource address
type URL = String

-- | Resource hash
type SHA256 = String

-- | Download and unpack zip archive. The returned path is the unpacked
--   folder.
zipArchive :: URL -> SHA256 -> FilePath

-- | Download and unpack tarball. The returned path is the unpacked folder.
tarball :: URL -> SHA256 -> FilePath

-- | Icons from <a>https://simpleicons.org/</a>. Version 3.11.0. License:
--   CC0
--   
--   <pre>
--   let icon = "cplusplus" in <a>mkGroup</a>
--   [ <a>mkBackgroundPixel</a> (<a>promotePixel</a> $ <a>simpleIconColor</a> icon)
--   , <a>withFillOpacity</a> 1 $ <a>simpleIcon</a> icon ]
--   </pre>
--   
simpleIcon :: String -> SVG

-- | Simple Icons svgs do not contain color. Instead, each icon has an
--   associated color value.
simpleIconColor :: String -> PixelRGB8

-- | Complete list of all Simple Icons.
simpleIcons :: [String]

-- | Icons from <a>https://svgporn.com/</a>. Version 2018.01. License: CC0
--   
--   <pre>
--   <a>svgLogo</a> "cassandra"
--   </pre>
--   
svgLogo :: String -> SVG

-- | Complete list of all SVG Icons.
svgLogos :: [String]


-- | <a>Povray</a> is a scriptable raytracer. All povray functions are
--   cached and will reuse images when scripts stay the same.
module Reanimate.Povray

-- | Run the povray raytracer with a default resolution of 320x180 and
--   antialiasing enabled. The resulting image is scaled to fit the screen
--   exactly.
povray :: [String] -> Text -> Tree

-- | Run the povray raytracer with a default resolution of 320x180 but
--   without antialiasing. The resulting image is scaled to fit the screen
--   exactly.
povrayQuick :: [String] -> Text -> Tree

-- | Run the povray raytracer with a default resolution of 1440x2560 and
--   antialiasing enabled. The FilePath points to a PNG file containing the
--   resulting image.
povraySlow :: [String] -> Text -> Tree

-- | Run the povray raytracer with a default resolution of 2160x3840 and
--   antialiasing enabled. The FilePath points to a PNG file containing the
--   resulting image.
povrayExtreme :: [String] -> Text -> Tree

-- | Run the povray raytracer with a default resolution of 320x180 and
--   antialiasing enabled. The FilePath points to a PNG file containing the
--   resulting image.
povray' :: [String] -> Text -> FilePath

-- | Run the povray raytracer with a default resolution of 320x180 but
--   without antialiasing. The FilePath points to a PNG file containing the
--   resulting image.
povrayQuick' :: [String] -> Text -> FilePath

-- | Run the povray raytracer with a default resolution of 1440x2560 and
--   antialiasing enabled. The FilePath points to a PNG file containing the
--   resulting image.
povraySlow' :: [String] -> Text -> FilePath

-- | Run the povray raytracer with a default resolution of 2160x3840 and
--   antialiasing enabled. The FilePath points to a PNG file containing the
--   resulting image.
povrayExtreme' :: [String] -> Text -> FilePath


-- | <a>Blender</a> is a free and open-source 3D graphics toolkit. It is
--   usually used through a graphical user-interface but can also be
--   scripted via Python. These Blender scripts can access 100% of
--   Blender's functionality and offer a convenient way of coding 3D
--   effects.
--   
--   Running Blender can be time-consuming but heavy caching means scripts
--   are only run when they change.
--   
--   Blender cheatsheet:
--   
--   <pre>
--   # To generate with a transparent background, set film_transparent = True:
--   bpy.context.scene.render.film_transparent = True
--   
--   # Filmic is great for photorealism but bad for animations.
--   # If you want your textures to keep their exact color values,
--   # set the view_transform to 'Standard':
--   bpy.context.scene.view_settings.view_transform = 'Standard'
--   
--   # Blender's default render engine is 'EEVEE', fast but not a raytracer.
--   # To switch to raytracing, set the engine to 'CYCLES':
--   bpy.context.scene.render.engine = 'CYCLES'
--   
--   # Rendering at full resolution can be slow. When developing, try
--   # decreasing the resolution_percentage for faster renders.
--   bpy.context.scene.render.resolution_percentage = 10
--   
--   # The resolution of the final image are set by resolution_x and resolution_y:
--   bpy.context.scene.render.resolution_x = 320
--   bpy.context.scene.render.resolution_y = 180
--   </pre>
module Reanimate.Blender

-- | Run a Blender script and embed the resulting image file. The image
--   will be scaled to fit the screen exactly (assuming a default canvas
--   layout). Note that Blender resolution defaults to 1920x1080 but can be
--   changed in the script code.
blender :: Text -> SVG

-- | Generate Blender image as a separate PNG file. Can be embedded with
--   <a>mkImage</a>.
blender' :: Text -> FilePath


module Reanimate.Svg

-- | Remove transformations (such as translations, rotations, scaling) and
--   apply them directly to the SVG nodes. Note, this function may convert
--   nodes (such as Circle or Rect) to paths. Also note that <i>does</i>
--   change how the SVG is rendered. Particularly, stroke width is affected
--   by directly applying scaling.
--   
--   <pre>
--   lowerTransformations (scale 2 (mkCircle 1)) = mkCircle 2
--   </pre>
lowerTransformations :: SVG -> SVG

-- | Remove all <tt>id</tt> attributes.
lowerIds :: SVG -> SVG

-- | Remove all draw attributes such as <tt>stroke</tt>, <tt>fill</tt> and
--   'fill-opacity'.
clearDrawAttributes :: SVG -> SVG

-- | Optimize SVG tree without affecting how it is rendered.
simplify :: SVG -> SVG

-- | Separate grouped items. This is required by clip nodes.
--   
--   <pre>
--   removeGroups (withFillColor "blue" $ mkGroup [mkCircle 1, mkRect 1 1])
--       = [ withFillColor "blue" $ mkCircle 1
--         , withFillColor "blue" $ mkRect 1 1 ]
--   </pre>
removeGroups :: SVG -> [SVG]

-- | Extract all path commands from a node (and its children) and
--   concatenate them.
extractPath :: SVG -> [PathCommand]

-- | Map over indexed symbols.
--   
--   <pre>
--   withSubglyphs [0,2] (scale 2) (mkGroup [mkCircle 1, mkRect 2, mkEllipse 1 2])
--         = mkGroup [scale 2 (mkCircle 1), mkRect 2, scale 2 (mkEllipse 1 2)]
--   </pre>
withSubglyphs :: [Int] -> (SVG -> SVG) -> SVG -> SVG

-- | Split symbols.
--   
--   <pre>
--   splitGlyphs [0,2] (mkGroup [mkCircle 1, mkRect 2, mkEllipse 1 2])
--         = ([mkRect 2], [mkCircle 1, mkEllipse 1 2])
--   </pre>
splitGlyphs :: [Int] -> SVG -> (SVG, SVG)

-- | Split symbols and include their context and drawing attributes.
svgGlyphs :: SVG -> [(SVG -> SVG, DrawAttributes, SVG)]

-- | Convert primitive SVG shapes (like those created by <a>mkCircle</a>,
--   <a>mkRect</a>, <a>mkLine</a> or <a>mkEllipse</a>) into SVG path. This
--   can be useful for creating animations of these shapes being drawn
--   progressively with <a>partialSvg</a>.
--   
--   Example:
--   
--   <pre>
--   pathifyExample :: Animation
--   pathifyExample = animate $ \t -&gt; gridLayout
--       [ [ partialSvg t $ pathify $ mkCircle 1
--         , partialSvg t $ pathify $ mkRect 2 2
--         ]
--       , [ partialSvg t $ pathify $ mkEllipse 1 0.5
--         , partialSvg t $ pathify $ mkLine (-1, -1) (1, 1)
--         ]
--       ]
--   </pre>
--   
pathify :: SVG -> SVG

-- | Map over all recursively-found path commands.
mapSvgPaths :: ([PathCommand] -> [PathCommand]) -> SVG -> SVG

-- | Map over all recursively-found line commands.
mapSvgLines :: ([LineCommand] -> [LineCommand]) -> SVG -> SVG

-- | Map over all line command control points.
mapSvgPoints :: (RPoint -> RPoint) -> SVG -> SVG

-- | Convert coordinate system from degrees to radians.
svgPointsToRadians :: SVG -> SVG

-- | Return bounding box of SVG tree. The four numbers returned are
--   (minimal X-coordinate, minimal Y-coordinate, width, height)
--   
--   Note: Bounding boxes are computed on a best-effort basis and will not
--   work in all cases. The only supported SVG nodes are: path, circle,
--   polyline, ellipse, line, rectangle, image. All other nodes return
--   (0,0,0,0).
boundingBox :: Tree -> (Double, Double, Double, Double)

-- | Height of SVG node in local units (not pixels). Computed on
--   best-effort basis and will not give accurate results for all SVG
--   nodes.
svgHeight :: Tree -> Double

-- | Width of SVG node in local units (not pixels). Computed on best-effort
--   basis and will not give accurate results for all SVG nodes.
svgWidth :: Tree -> Double

-- | Replace all <tt><a>use</a></tt> nodes with their definition.
replaceUses :: Document -> Document

-- | Transform out viewbox. Definitions and CSS rules are discarded.
unbox :: Document -> Tree

-- | Transform out viewbox and fit image to screen size.
unboxFit :: Document -> Tree

-- | Embed <a>Document</a>. This keeps the entire document intact but makes
--   it more difficult to use, say, <a>pathify</a> on it.
embedDocument :: Document -> Tree


-- | A PolyShape is a closed set of curves.
module Reanimate.PolyShape

-- | Shape drawn by continuous line. May have overlap, may be convex.
newtype PolyShape
PolyShape :: ClosedPath Double -> PolyShape
[unPolyShape] :: PolyShape -> ClosedPath Double

-- | Polyshape with smaller, fully-enclosed holes.
data PolyShapeWithHoles

-- | Extract all shapes from SVG nodes. Drawing attributes such as stroke
--   and fill color are discarded.
svgToPolyShapes :: Tree -> [PolyShape]

-- | Extract all polygons from SVG nodes. Curves are approximated to within
--   the given tolerance.
svgToPolygons :: Double -> SVG -> [Polygon]

-- | Render a polyshape as a single SVG path.
renderPolyShape :: PolyShape -> Tree

-- | Render a set of polyshapes as a single SVG path.
renderPolyShapes :: [PolyShape] -> Tree

-- | Render control-points of a polyshape as circles.
renderPolyShapePoints :: PolyShape -> Tree

-- | Convert a polyshape to a list of SVG path commands.
plPathCommands :: PolyShape -> [PathCommand]

-- | Convert a polyshape to a list of line commands.
plLineCommands :: PolyShape -> [LineCommand]

-- | Length of polyshape circumference.
plLength :: PolyShape -> Double

-- | Area of polyshape.
plArea :: PolyShape -> Double

-- | Destruct a polyshape into constituent curves.
plCurves :: PolyShape -> [CubicBezier Double]

-- | True iff lhs is inside of rhs. lhs and rhs may not overlap.
--   Implementation: Trace a vertical line through the origin of A and
--   check of this line intersects and odd number of times on both sides of
--   A.
isInsideOf :: PolyShape -> PolyShape -> Bool

-- | Construct a polyshape from the vertices in a polygon.
plFromPolygon :: [RPoint] -> PolyShape

-- | Approximate a polyshape as a polygon within the given tolerance.
plToPolygon :: Double -> PolyShape -> Polygon

-- | Deconstruct a polyshape into non-intersecting, convex polygons.
plDecompose :: [PolyShape] -> [[RPoint]]

-- | Merge overlapping shapes.
unionPolyShapes :: [PolyShape] -> [PolyShape]

-- | Merge overlapping shapes to within given tolerance.
unionPolyShapes' :: Double -> [PolyShape] -> [PolyShape]

-- | Deconstruct a polyshape into non-intersecting, convex polygons.
plDecompose' :: Double -> [PolyShape] -> [[RPoint]]

-- | Split polygon into smaller, convex polygons.
decomposePolygon :: [RPoint] -> [[RPoint]]

-- | Find holes and group them with their parent.
plGroupShapes :: [PolyShape] -> [PolyShapeWithHoles]

-- | Cut out holes.
mergePolyShapeHoles :: PolyShapeWithHoles -> PolyShape

-- | Partially draw polyshape.
plPartial :: Double -> PolyShape -> PolyShape

-- | Find intersection points.
plGroupTouching :: [PolyShape] -> [[([RPoint], PolyShape)]]
instance GHC.Show.Show Reanimate.PolyShape.PolyShape
instance GHC.Classes.Eq Reanimate.PolyShape.PolyShape


module Reanimate.Morph.Common

-- | Method determining how points in the source polygon align with points
--   in the target polygon.
type PointCorrespondence = Polygon -> Polygon -> (Polygon, Polygon)

-- | Method for interpolating between two aligned polygons.
type Trajectory = (Polygon, Polygon) -> (Double -> Polygon)

-- | Method for pairing sets of polygons.
type ObjectCorrespondence = [GPolygon] -> [GPolygon] -> [(GPolygon, GPolygon)]

-- | Morphing strategy
data Morph
Morph :: Double -> ColorComponents -> PointCorrespondence -> Trajectory -> ObjectCorrespondence -> Morph

-- | Morphing curves is not always possible and sometimes shapes are
--   reduced to polygons or meta-curves. This parameter determined the
--   accuracy of this transformation.
[morphTolerance] :: Morph -> Double

-- | Color components used for color interpolation. LAB is usually the best
--   option here.
[morphColorComponents] :: Morph -> ColorComponents

-- | Desired point-correspondence algorithm.
[morphPointCorrespondence] :: Morph -> PointCorrespondence

-- | Desired interpolation algorithm.
[morphTrajectory] :: Morph -> Trajectory

-- | Desired object-correspondence algorithm.
[morphObjectCorrespondence] :: Morph -> ObjectCorrespondence

-- | Apply morphing strategy to interpolate between two SVG images.
morph :: Morph -> SVG -> SVG -> Double -> SVG

-- | Object-correspondence algorithm that splits objects in smaller pieces
--   as necessary.
splitObjectCorrespondence :: ObjectCorrespondence

-- | Object-correspondence algorithm that duplicate objects as necessary.
dupObjectCorrespondence :: ObjectCorrespondence

-- | Object-correspondence algorithm that spawn objects as necessary.
genesisObjectCorrespondence :: ObjectCorrespondence

-- | Extract shapes and their graphical attributes from an SVG node.
toShapes :: Double -> SVG -> [(DrawAttributes, Polygon)]

-- | Add points to each polygon such that they end up with same size.
normalizePolygons :: (Real a, Fractional a, Epsilon a) => APolygon a -> APolygon a -> (APolygon a, APolygon a)

-- | Map over each polygon in an SVG node.
annotatePolygons :: (Polygon -> SVG) -> SVG -> SVG

-- | Extract the first polygon in an SVG node. Will fail if there are no
--   acceptable shapes.
unsafeSVGToPolygon :: Double -> SVG -> Polygon


module Reanimate.Morph.Rotational

-- | Rotational origin relative to polygon center. (0.5, 0.5) is center of
--   polygon. Top right is (1,1) and bottom left is (0,0)
type Origin = (Double, Double)

-- | Interpolation by rotating around an origin point.
--   
--   Example:
--   
--   <pre>
--   <a>playThenReverseA</a> $ <a>pauseAround</a> 0.5 0.5 $ <a>mkAnimation</a> 3 $ \t -&gt;
--     <a>withStrokeLineJoin</a> <a>JoinRound</a> $
--     let src = <a>scale</a> 8 $ <a>center</a> $ <a>latex</a> "X"
--         dst = <a>scale</a> 8 $ <a>center</a> $ <a>latex</a> "H"
--     in <a>morph</a> <a>linear</a>{<a>morphTrajectory</a>=<a>rotationalTrajectory</a> (0.5,0.5)} src dst t
--   </pre>
--   
rotationalTrajectory :: Origin -> Trajectory

-- | Compute the absolute position of rotational origin point in polygon.
polygonOrigin :: Polygon -> Origin -> V2 Double


module Reanimate.Morph.Linear

-- | Linear interpolation strategy.
--   
--   Example:
--   
--   <pre>
--   <a>playThenReverseA</a> $ <a>pauseAround</a> 0.5 0.5 $ <a>mkAnimation</a> 3 $ \t -&gt;
--     <a>withStrokeLineJoin</a> <a>JoinRound</a> $
--     let src = <a>scale</a> 8 $ <a>center</a> $ <a>latex</a> "X"
--         dst = <a>scale</a> 8 $ <a>center</a> $ <a>latex</a> "H"
--     in <a>morph</a> <a>linear</a> src dst t
--   </pre>
--   
linear :: Morph

-- | Linear interpolation strategy without realigning corners. May give
--   better results if the polygons are already aligned. Usually gives
--   worse results.
--   
--   Example:
--   
--   <pre>
--   <a>playThenReverseA</a> $ <a>pauseAround</a> 0.5 0.5 $ <a>mkAnimation</a> 3 $ \t -&gt;
--     <a>withStrokeLineJoin</a> <a>JoinRound</a> $
--     let src = <a>scale</a> 8 $ <a>center</a> $ <a>latex</a> "X"
--         dst = <a>scale</a> 8 $ <a>center</a> $ <a>latex</a> "H"
--     in <a>morph</a> <a>rawLinear</a> src dst t
--   </pre>
--   
rawLinear :: Morph

-- | Cycle polygons until the sum of the point trajectory path lengths is
--   smallest.
closestLinearCorrespondence :: PointCorrespondence

-- | Cycle polygons until the sum of the point trajectory path lengths is
--   smallest.
closestLinearCorrespondenceA :: (Real a, Fractional a, Epsilon a) => APolygon a -> APolygon a -> (APolygon a, APolygon a)

-- | Strategy for moving points in a linear (straight-line) trajectory.
linearTrajectory :: Trajectory


module Reanimate.Math.Balloon

-- | Inflate SVG shapes like a balloon. This works by hiding corners that
--   are more than <tt>t</tt> percent distant from the starting point
--   relative to the maximum diameter of the shape.
--   
--   Example:
--   
--   <pre>
--   <a>animate</a> $ <a>balloon</a> (<a>scale</a> 8 $ <a>center</a> $ <a>latex</a> "X")
--   </pre>
--   
balloon :: SVG -> Double -> SVG

-- | Same as <tt>balloon'</tt> but with a given tolerance for converting
--   SVG shapes to polygons.
balloon' :: Double -> SVG -> Double -> SVG


module Reanimate.LaTeX

-- | Render TeX script using a given configuration.
latexCfg :: TexConfig -> Text -> SVG

-- | TeX backends. They have different features and capabilities.
data TexEngine
LaTeX :: TexEngine
XeLaTeX :: TexEngine
LuaLaTeX :: TexEngine

-- | TeX configurations can load packages and set up environments for tex
--   scripts.
data TexConfig
TexConfig :: TexEngine -> [Text] -> [Text] -> TexConfig
[texConfigEngine] :: TexConfig -> TexEngine
[texConfigHeaders] :: TexConfig -> [Text]
[texConfigPostScript] :: TexConfig -> [Text]

-- | Invoke latex and import the result as an SVG object. SVG objects are
--   cached to improve performance.
--   
--   Example:
--   
--   <pre>
--   latex "$e^{i\\pi}+1=0$"
--   </pre>
--   
latex :: Text -> Tree

-- | Invoke latex with extra script headers.
latexWithHeaders :: [Text] -> Text -> Tree

-- | Invoke latex and separate results.
latexChunks :: Traversable t => t Text -> t Tree

-- | Invoke latex using a given configuration and separate results.
latexCfgChunks :: Traversable t => TexConfig -> t Text -> t Tree

-- | Invoke latex using a given configuration and separate results. Apply
--   the transformation to the LaTeX segments. See also <a>mathChunks</a>,
--   the transformation is <tt>(s -&gt; "$" &lt;&gt; s &lt;&gt; "$")</tt>.
latexCfgChunksTrans :: Traversable t => TexConfig -> (Text -> Text) -> t Text -> t Tree

-- | Render math formula and separate results.
mathChunks :: Traversable t => t Text -> t Tree

-- | Invoke xelatex and import the result as an SVG object. SVG objects are
--   cached to improve performance. Xelatex has support for non-western
--   scripts.
xelatex :: Text -> Tree

-- | Invoke xelatex with extra script headers.
xelatexWithHeaders :: [Text] -> Text -> Tree

-- | Invoke xelatex with "usepackage[UTF8]{ctex}" and import the result as
--   an SVG object. SVG objects are cached to improve performance. Xelatex
--   has support for non-western scripts.
--   
--   Example:
--   
--   <pre>
--   ctex "中文"
--   </pre>
--   
ctex :: Text -> Tree

-- | Invoke xelatex with extra script headers + ctex headers.
ctexWithHeaders :: [Text] -> Text -> Tree

-- | Invoke latex and import the result as an SVG object. SVG objects are
--   cached to improve performance. This wraps the TeX code in an 'align*'
--   context.
--   
--   Example:
--   
--   <pre>
--   latexAlign "R = \\frac{{\\Delta x}}{{kA}}"
--   </pre>
--   
latexAlign :: Text -> Tree

-- | Chalkduster font. Depends on lualatex. Font files are automatically
--   downloaded.
--   
--   <pre>
--   <a>latexCfg</a> <a>chalkduster</a> "chalkduster"
--   </pre>
--   
chalkduster :: TexConfig

-- | <pre>
--   <a>latexCfg</a> <a>calligra</a> "calligra"
--   </pre>
--   
calligra :: TexConfig

-- | <pre>
--   <a>latexCfg</a> <a>noto</a> "noto"
--   </pre>
--   
noto :: TexConfig

-- | <pre>
--   <a>latexCfg</a> <a>helvet</a> "helvet"
--   </pre>
--   
helvet :: TexConfig

-- | <pre>
--   <a>latexCfg</a> <a>libertine</a> "libertine"
--   </pre>
--   
libertine :: TexConfig

-- | <pre>
--   <a>latexCfg</a> <a>biolinum</a> "biolinum"
--   </pre>
--   
biolinum :: TexConfig

-- | <pre>
--   <a>latexCfg</a> <a>droidSerif</a> "droidSerif"
--   </pre>
--   
droidSerif :: TexConfig

-- | <pre>
--   <a>latexCfg</a> <a>droidSans</a> "droidSans"
--   </pre>
--   
droidSans :: TexConfig
instance GHC.Show.Show Reanimate.LaTeX.TexEngine
instance GHC.Read.Read Reanimate.LaTeX.TexEngine
instance GHC.Classes.Ord Reanimate.LaTeX.TexEngine
instance GHC.Classes.Eq Reanimate.LaTeX.TexEngine
instance Data.Hashable.Class.Hashable Reanimate.LaTeX.TexEngine
instance GHC.Generics.Generic Reanimate.LaTeX.TexEngine
instance GHC.Classes.Ord Reanimate.LaTeX.TexConfig
instance GHC.Classes.Eq Reanimate.LaTeX.TexConfig
instance GHC.Show.Show Reanimate.LaTeX.TexConfig
instance GHC.Read.Read Reanimate.LaTeX.TexConfig
instance Data.Hashable.Class.Hashable Reanimate.LaTeX.TexConfig
instance GHC.Generics.Generic Reanimate.LaTeX.TexConfig


-- | Effects represent modifications applied to frames of the
--   <a>Animation</a>. Effects can (and usually do) depend on time. One or
--   more effects can be applied over the entire duration of animation, or
--   modified to affect only a specific portion at the beginning / middle /
--   end of the animation.
module Reanimate.Effect

-- | An Effect represents a modification of a SVG <a>Tree</a> that can vary
--   with time.
type Effect = Duration " Duration of the effect (in seconds)" -> Time " Time elapsed from when the effect started (in seconds)" -> Tree " Image to be modified" -> Tree " Image after modification"

-- | Change image opacity from 0 to 1.
fadeInE :: Effect

-- | Change image opacity from 1 to 0. Reverse of <a>fadeInE</a>.
fadeOutE :: Effect

-- | Change stroke width from 0 to given value.
fadeLineInE :: Double -> Effect

-- | Change stroke width from given value to 0. Reverse of
--   <a>fadeLineInE</a>.
fadeLineOutE :: Double -> Effect

-- | Change fill opacity from 0 to 1.
fillInE :: Effect

-- | Effect of progressively drawing the image. Note that this will only
--   affect primitive shapes (see <a>pathify</a>).
drawInE :: Effect

-- | Reverse of <a>drawInE</a>.
drawOutE :: Effect

-- | Move the image from its current position to the target x y
--   coordinates.
translateE :: Double -> Double -> Effect

-- | Change scale from 1 to given value.
scaleE :: Double -> Effect

-- | Build an effect from an image-modifying function. This effect does not
--   change as time passes.
constE :: (Tree -> Tree) -> Effect

-- | Modify the effect so that it only applies to the initial part of the
--   animation.
overBeginning :: Duration -> Effect -> Effect

-- | Modify the effect so that it only applies to the ending part of the
--   animation.
overEnding :: Duration -> Effect -> Effect

-- | Modify the effect so that it only applies within given interval of
--   animation's running time.
overInterval :: Time -> Time -> Effect -> Effect

-- | <tt>reverseE effect</tt> starts where the <tt>effect</tt> ends and
--   vice versa.
reverseE :: Effect -> Effect

-- | Delay the effect so that it only starts after specified duration and
--   then runs till the end of animation.
delayE :: Duration -> Effect -> Effect

-- | Transform the effect so that the image passed to the effect's
--   image-modifying function has coordinates (0, 0) shifted to the center
--   of its bounding box. Also see <a>aroundCenter</a>.
aroundCenterE :: Effect -> Effect

-- | Modify the animation by applying the effect. If desired, you can apply
--   multiple effects to single animation by calling this function multiple
--   times.
applyE :: Effect -> Animation -> Animation


module Reanimate.Debug

-- | Add SVG image to trace stack.
traceSVG :: SVG -> a -> a

-- | Add animation to trace stack.
traceA :: Animation -> a -> a

-- | Evaluate argument and play back the trace stack.
playTraces :: a -> Animation


-- | Implementation of ternary plots:
--   <a>https://en.wikipedia.org/wiki/Ternary_plot</a>
module Reanimate.Builtin.TernaryPlot

-- | Left-most coordinate.
type ACoord = Double

-- | Top-most coordinate.
type BCoord = Double

-- | Right-most coordinate.
type CCoord = Double

-- | Creates a centered ternary plot with a width of 5.
--   
--   Example:
--   
--   <pre>
--   <a>ternaryPlot</a> 100 $ \aCoord bCoord cCoord -&gt; <a>promotePixel</a> $
--     let red   = round $ aCoord*255
--         green = round $ bCoord*255
--         blue  = round $ cCoord*255
--     in PixelRGB8 red green blue
--   </pre>
--   
ternaryPlot :: Int -> (ACoord -> BCoord -> CCoord -> PixelRGBA8) -> Tree

-- | Compute the XY coordinates from ternary coordinates. Note that
--   <tt>CCoord</tt> is given because <tt>a+b+c=1</tt>.
toCartesianCoords :: ACoord -> BCoord -> (Double, Double)

-- | Compute the XY coordinates relative from the center of the ternary
--   plot. Note that <tt>CCoord</tt> is given because <tt>a+b+c=1</tt>.
toOffsetCartesianCoords :: ACoord -> BCoord -> (Double, Double)

-- | Compute ternary coordinates from XY coordinates.
fromCartesianCoords :: Double -> Double -> (ACoord, BCoord, CCoord)


-- | Collection of built-in images.
module Reanimate.Builtin.Images

svgLogo :: SVG

haskellLogo :: SVG

githubIcon :: SVG

githubWhiteIcon :: SVG

-- | 300x150 equirectangular earth
--   
smallEarth :: Image PixelRGBA8


-- | This module contains convenience functions used in documention GIFs
--   for a consistent look and feel.
module Reanimate.Builtin.Documentation

-- | Default environment for API documentation GIFs.
docEnv :: Animation -> Animation

drawBox :: Animation

drawCircle :: Animation

drawProgress :: Animation

-- | Render a full-screen view of a color-map.
showColorMap :: (Double -> PixelRGB8) -> SVG

-- | Default background color for videos on reanimate.rtfd.io
rtfdBackgroundColor :: PixelRGBA8


-- | Convenience module for rendering circle plots.
module Reanimate.Builtin.CirclePlot

-- | Circle plots are scaled to <a>screenHeight</a>.
--   
--   Example:
--   
--   <pre>
--   <a>circlePlot</a> 500 $ \ang r -&gt;
--     <a>promotePixel</a> $ toRGB8 $ uncurryRGB sRGB $ hsv (ang/pi*180) r 1
--   </pre>
--   
circlePlot :: Int -> (Double -> Double -> PixelRGBA8) -> Tree


module Reanimate.Transition

-- | A transition transforms one animation into another.
type Transition = Animation -> Animation -> Animation

-- | Apply a signal to the timing of a transition.
signalT :: Signal -> Transition -> Transition

-- | Map the result of a transition.
mapT :: (Animation -> Animation) -> Transition -> Transition

-- | Apply transition only to <tt>N</tt> seconds of the first animation and
--   to the last <tt>N</tt> seconds of the second animation.
--   
--   Example:
--   
--   <pre>
--   <a>overlapT</a> 0.5 <a>fadeT</a> <a>drawBox</a> <a>drawCircle</a>
--   </pre>
--   
overlapT :: Double -> Transition -> Transition

-- | Combine a list of animations using a given transition.
--   
--   Example:
--   
--   <pre>
--   <a>chainT</a> (<a>overlapT</a> 0.5 <a>fadeT</a>) [<a>drawBox</a>, <a>drawCircle</a>, <a>drawProgress</a>]
--   </pre>
--   
chainT :: Transition -> [Animation] -> Animation

-- | Create a transition between two animations by applying an effect to
--   each respective animation.
effectT :: Effect -> Effect -> Transition

-- | Fade out left-hand-side animation while fading in right-hand-side
--   animation.
--   
--   Example:
--   
--   <pre>
--   <a>drawBox</a> `<a>fadeT</a>` <a>drawCircle</a>
--   </pre>
--   
fadeT :: Transition


-- | Scenes are an imperative way of defining animations.
module Reanimate.Scene

-- | A <a>Scene</a> represents a sequence of animations and variables that
--   change over time.
data Scene s a

-- | The ZIndex property specifies the stack order of sprites and
--   animations. Elements with a higher ZIndex will be drawn on top of
--   elements with a lower index.
type ZIndex = Int

-- | Render a <a>Scene</a> to an <a>Animation</a>.
scene :: (forall s. Scene s a) -> Animation

-- | Play an animation once and then remove it. This advances the clock by
--   the duration of the animation.
--   
--   Example:
--   
--   <pre>
--   do <a>play</a> <a>drawBox</a>
--      <a>play</a> <a>drawCircle</a>
--   </pre>
--   
play :: Animation -> Scene s ()

-- | Execute actions in a scene without advancing the clock. Note that
--   scenes do not end before all forked actions have completed.
--   
--   Example:
--   
--   <pre>
--   do <a>fork</a> $ <a>play</a> <a>drawBox</a>
--      <a>play</a> <a>drawCircle</a>
--   </pre>
--   
fork :: Scene s a -> Scene s a

-- | Query the current clock timestamp.
--   
--   Example:
--   
--   <pre>
--   do now &lt;- <a>play</a> <a>drawCircle</a> *&gt; <a>queryNow</a>
--      <a>play</a> $ <tt>staticFrame</tt> 1 $ <tt>scale</tt> 2 $ <tt>withStrokeWidth</tt> 0.05 $
--        <tt>mkText</tt> $ "Now=" &lt;&gt; T.pack (show now)
--   </pre>
--   
queryNow :: Scene s Time

-- | Advance the clock by a given number of seconds.
--   
--   Example:
--   
--   <pre>
--   do <a>fork</a> $ <a>play</a> <a>drawBox</a>
--      <a>wait</a> 1
--      <a>play</a> <a>drawCircle</a>
--   </pre>
--   
wait :: Duration -> Scene s ()

-- | Wait until the clock is equal to the given timestamp.
waitUntil :: Time -> Scene s ()

-- | Wait until all forked and sequential animations have finished.
--   
--   Example:
--   
--   <pre>
--   do <a>waitOn</a> $ <a>fork</a> $ <a>play</a> <a>drawBox</a>
--      <a>play</a> <a>drawCircle</a>
--   </pre>
--   
waitOn :: Scene s a -> Scene s a

-- | Change the ZIndex of a scene.
adjustZ :: (ZIndex -> ZIndex) -> Scene s a -> Scene s a

-- | Query the duration of a scene.
withSceneDuration :: Scene s () -> Scene s Duration

-- | Time dependent variable.
data Var s a

-- | Create a new variable with a default value. Variables always have a
--   defined value even if they are read at a timestamp that is earlier
--   than when the variable was created. For example:
--   
--   <pre>
--   do v &lt;- <a>fork</a> (<a>wait</a> 10 &gt;&gt; <a>newVar</a> 0) -- Create a variable at timestamp '10'.
--      <a>readVar</a> v                       -- Read the variable at timestamp '0'.
--                                      -- The value of the variable will be '0'.
--   </pre>
newVar :: a -> Scene s (Var s a)

-- | Read the value of a variable at the current timestamp.
readVar :: Var s a -> Scene s a

-- | Write the value of a variable at the current timestamp.
--   
--   Example:
--   
--   <pre>
--   do v &lt;- <a>newVar</a> 0
--      <a>newSprite</a> $ <a>mkCircle</a> &lt;$&gt; <a>unVar</a> v
--      <a>writeVar</a> v 1; <a>wait</a> 1
--      <a>writeVar</a> v 2; <a>wait</a> 1
--      <a>writeVar</a> v 3; <a>wait</a> 1
--   </pre>
--   
writeVar :: Var s a -> a -> Scene s ()

-- | Modify the value of a variable at the current timestamp and all future
--   timestamps.
modifyVar :: Var s a -> (a -> a) -> Scene s ()

-- | Modify a variable between <tt>now</tt> and <tt>now+duration</tt>.
tweenVar :: Var s a -> Duration -> (a -> Time -> a) -> Scene s ()

-- | Create and render a variable. The rendering will be born at the
--   current timestamp and will persist until the end of the scene.
--   
--   Example:
--   
--   <pre>
--   do var &lt;- <a>simpleVar</a> <a>mkCircle</a> 0
--      <a>tweenVar</a> var 2 $ \val -&gt; <a>fromToS</a> val (<a>screenHeight</a>/2)
--   </pre>
--   
simpleVar :: (a -> SVG) -> a -> Scene s (Var s a)

-- | Helper function for filtering variables.
findVar :: (a -> Bool) -> [Var s a] -> Scene s (Var s a)

-- | Sprites are animations with a given time of birth as well as a time of
--   death. They can be controlled using variables, tweening, and effects.
data Sprite s

-- | Sprite frame generator. Generates frames over time in a stateful
--   environment.
data Frame s a

-- | Dereference a variable as a Sprite frame.
--   
--   Example:
--   
--   <pre>
--   do v &lt;- <a>newVar</a> 0
--      <a>newSprite</a> $ <a>mkCircle</a> &lt;$&gt; <a>unVar</a> v
--      <a>tweenVar</a> v 1 $ \val -&gt; <a>fromToS</a> val 3
--      <a>tweenVar</a> v 1 $ \val -&gt; <a>fromToS</a> val 0
--   </pre>
--   
unVar :: Var s a -> Frame s a

-- | Dereference seconds since sprite birth.
spriteT :: Frame s Time

-- | Dereference duration of the current sprite.
spriteDuration :: Frame s Duration

-- | Create new sprite defined by a frame generator. Unless otherwise
--   specified using <a>destroySprite</a>, the sprite will die at the end
--   of the scene.
--   
--   Example:
--   
--   <pre>
--   do <a>newSprite</a> $ <a>mkCircle</a> &lt;$&gt; <a>spriteT</a> -- Circle sprite where radius=time.
--      <a>wait</a> 2
--   </pre>
--   
newSprite :: Frame s SVG -> Scene s (Sprite s)

-- | Create new sprite defined by a frame generator. The sprite will die at
--   the end of the scene.
newSprite_ :: Frame s SVG -> Scene s ()

-- | Create a new sprite from an animation. This advances the clock by the
--   duration of the animation. Unless otherwise specified using
--   <a>destroySprite</a>, the sprite will die at the end of the scene.
--   
--   Note: If the scene doesn't end immediately after the duration of the
--   animation, the animation will be stretched to match the lifetime of
--   the sprite. See <a>newSpriteA'</a> and <a>play</a>.
--   
--   Example:
--   
--   <pre>
--   do <a>fork</a> $ <a>newSpriteA</a> <a>drawCircle</a>
--      <a>play</a> <a>drawBox</a>
--      <a>play</a> $ <a>reverseA</a> <a>drawBox</a>
--   </pre>
--   
newSpriteA :: Animation -> Scene s (Sprite s)

-- | Create a new sprite from an animation and specify the synchronization
--   policy. This advances the clock by the duration of the animation.
--   
--   Example:
--   
--   <pre>
--   do <a>fork</a> $ <a>newSpriteA'</a> <a>SyncFreeze</a> <a>drawCircle</a>
--      <a>play</a> <a>drawBox</a>
--      <a>play</a> $ <a>reverseA</a> <a>drawBox</a>
--   </pre>
--   
newSpriteA' :: Sync -> Animation -> Scene s (Sprite s)

-- | Create a sprite from a static SVG image.
--   
--   Example:
--   
--   <pre>
--   do <a>newSpriteSVG</a> $ <a>mkBackground</a> "lightblue"
--      <a>play</a> <a>drawCircle</a>
--   </pre>
--   
newSpriteSVG :: SVG -> Scene s (Sprite s)

-- | Create a permanent sprite from a static SVG image. Same as
--   <a>newSpriteSVG</a> but the sprite isn't returned and thus cannot be
--   destroyed.
newSpriteSVG_ :: SVG -> Scene s ()

-- | Destroy a sprite, preventing it from being rendered in the future of
--   the scene. If <a>destroySprite</a> is invoked multiple times, the
--   earliest time-of-death is used.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>newSpriteSVG</a> $ <a>withFillOpacity</a> 1 $ <a>mkCircle</a> 1
--      <a>fork</a> $ <a>wait</a> 1 &gt;&gt; <a>destroySprite</a> s
--      <a>play</a> <a>drawBox</a>
--   </pre>
--   
destroySprite :: Sprite s -> Scene s ()

-- | Change the rendering of a sprite using data from a variable. If data
--   from several variables is needed, use a frame generator instead.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>fork</a> $ <a>newSpriteA</a> <a>drawBox</a>
--      v &lt;- <a>newVar</a> 0
--      <a>applyVar</a> v s <a>rotate</a>
--      <a>tweenVar</a> v 2 $ \val -&gt; <a>fromToS</a> val 90
--   </pre>
--   
applyVar :: Var s a -> Sprite s -> (a -> SVG -> SVG) -> Scene s ()

-- | Low-level frame modifier.
spriteModify :: Sprite s -> Frame s ((SVG, ZIndex) -> (SVG, ZIndex)) -> Scene s ()

-- | Map the SVG output of a sprite.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>fork</a> $ <a>newSpriteA</a> <a>drawCircle</a>
--      <a>wait</a> 1
--      <a>spriteMap</a> s <a>flipYAxis</a>
--   </pre>
--   
spriteMap :: Sprite s -> (SVG -> SVG) -> Scene s ()

-- | Modify the output of a sprite between <tt>now</tt> and
--   <tt>now+duration</tt>.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>fork</a> $ <a>newSpriteA</a> <a>drawCircle</a>
--      <a>spriteTween</a> s 1 $ \val -&gt; <a>translate</a> (<a>screenWidth</a>*0.3*val) 0
--   </pre>
--   
spriteTween :: Sprite s -> Duration -> (Double -> SVG -> SVG) -> Scene s ()

-- | Create a new variable and apply it to a sprite.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>fork</a> $ <a>newSpriteA</a> <a>drawBox</a>
--      v &lt;- <a>spriteVar</a> s 0 <a>rotate</a>
--      <a>tweenVar</a> v 2 $ \val -&gt; <a>fromToS</a> val 90
--   </pre>
--   
spriteVar :: Sprite s -> a -> (a -> SVG -> SVG) -> Scene s (Var s a)

-- | Apply an effect to a sprite.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>fork</a> $ <a>newSpriteA</a> <a>drawCircle</a>
--      <a>spriteE</a> s $ <a>overBeginning</a> 1 <a>fadeInE</a>
--      <a>spriteE</a> s $ <a>overEnding</a> 0.5 <a>fadeOutE</a>
--   </pre>
--   
spriteE :: Sprite s -> Effect -> Scene s ()

-- | Set new ZIndex of a sprite.
--   
--   Example:
--   
--   <pre>
--   do s1 &lt;- <a>newSpriteSVG</a> $ <a>withFillOpacity</a> 1 $ <a>withFillColor</a> "blue" $ <a>mkCircle</a> 3
--      <a>newSpriteSVG</a> $ <a>withFillOpacity</a> 1 $ <a>withFillColor</a> "red" $ <a>mkRect</a> 8 3
--      <a>wait</a> 1
--      <a>spriteZ</a> s1 1
--      <a>wait</a> 1
--   </pre>
--   
spriteZ :: Sprite s -> ZIndex -> Scene s ()

-- | Destroy all local sprites at the end of a scene.
--   
--   Example:
--   
--   <pre>
--   do -- the rect lives through the entire 3s animation
--      <a>newSpriteSVG_</a> $ <a>translate</a> (-3) 0 $ <a>mkRect</a> 4 4
--      <a>wait</a> 1
--      <a>spriteScope</a> $ do
--        -- the circle only lives for 1 second.
--        local &lt;- <a>newSpriteSVG</a> $ <a>translate</a> 3 0 $ <a>mkCircle</a> 2
--        <a>spriteE</a> local $ <a>overBeginning</a> 0.3 <a>fadeInE</a>
--        <a>spriteE</a> local $ <a>overEnding</a> 0.3 <a>fadeOutE</a>
--        <a>wait</a> 1
--      <a>wait</a> 1
--   </pre>
--   
spriteScope :: Scene s a -> Scene s a

-- | Objects are SVG nodes (represented as Haskell values) with identity,
--   location, and several other properties that can change over time.
data Object s a

-- | Container for object properties.
data ObjectData a

-- | Create new object.
oNew :: Renderable a => a -> Scene s (Object s a)

-- | Create new object.
newObject :: Renderable a => a -> Scene s (Object s a)

-- | Modify object properties.
oModify :: Object s a -> (ObjectData a -> ObjectData a) -> Scene s ()

-- | Modify object properties using a stateful API.
oModifyS :: Object s a -> State (ObjectData a) b -> Scene s ()

-- | Query object property.
oRead :: Object s a -> Getting b (ObjectData a) b -> Scene s b

-- | Modify object properties over a set duration.
oTween :: Object s a -> Duration -> (Double -> ObjectData a -> ObjectData a) -> Scene s ()

-- | Modify object properties over a set duration using a stateful API.
oTweenS :: Object s a -> Duration -> (Double -> State (ObjectData a) b) -> Scene s ()

-- | Modify object value over a set duration. This is a convenience
--   function for modifying <a>oValue</a>.
oTweenV :: Renderable a => Object s a -> Duration -> (Double -> a -> a) -> Scene s ()

-- | Modify object value over a set duration using a stateful API. This is
--   a convenience function for modifying <a>oValue</a>.
oTweenVS :: Renderable a => Object s a -> Duration -> (Double -> State a b) -> Scene s ()

-- | Objects can be any Haskell structure as long as it can be rendered to
--   SVG.
class Renderable a
toSVG :: Renderable a => a -> SVG

-- | Object position. Default: &lt;0,0&gt;
oTranslate :: Lens' (ObjectData a) (V2 Double)

-- | Object X position. Default: 0
oTranslateX :: Lens' (ObjectData a) Double

-- | Object Y position. Default: 0
oTranslateY :: Lens' (ObjectData a) Double

-- | Rendered SVG node of an object. Does not include context or object
--   properties. Read-only.
oSVG :: Getter (ObjectData a) SVG

-- | Custom render context. Is applied to the object for every frame that
--   it is shown.
oContext :: Lens' (ObjectData a) (SVG -> SVG)

-- | Object margins (top, right, bottom, left) in local units.
oMargin :: Lens' (ObjectData a) (Double, Double, Double, Double)

-- | Object's top margin.
oMarginTop :: Lens' (ObjectData a) Double

-- | Object's right margin.
oMarginRight :: Lens' (ObjectData a) Double

-- | Object's bottom margin.
oMarginBottom :: Lens' (ObjectData a) Double

-- | Object's left margin.
oMarginLeft :: Lens' (ObjectData a) Double

-- | Object bounding-box (minimal X-coordinate, minimal Y-coordinate,
--   width, height). Uses <a>boundingBox</a> and has the same limitations.
oBB :: Getter (ObjectData a) (Double, Double, Double, Double)

-- | Object's minimal X-coordinate..
oBBMinX :: Getter (ObjectData a) Double

-- | Object's minimal Y-coordinate..
oBBMinY :: Getter (ObjectData a) Double

-- | Object's width without margin.
oBBWidth :: Getter (ObjectData a) Double

-- | Object's height without margin.
oBBHeight :: Getter (ObjectData a) Double

-- | Object opacity. Default: 1
oOpacity :: Lens' (ObjectData a) Double

-- | Toggle for whether or not the object should be rendered. Default:
--   False
oShown :: Lens' (ObjectData a) Bool

-- | Object's z-index.
oZIndex :: Lens' (ObjectData a) Int

-- | Easing function used when modifying object properties. Default:
--   <tt><a>curveS</a> 2</tt>
oEasing :: Lens' (ObjectData a) Signal

-- | Object's scale. Default: 1
oScale :: Lens' (ObjectData a) Double

-- | Origin point for scaling. Default: &lt;0,0&gt;
oScaleOrigin :: Lens' (ObjectData a) (V2 Double)

-- | Derived location of the top-most point of an object + margin.
oTopY :: Lens' (ObjectData a) Double

-- | Derived location of the bottom-most point of an object + margin.
oBottomY :: Lens' (ObjectData a) Double

-- | Derived location of the left-most point of an object + margin.
oLeftX :: Lens' (ObjectData a) Double

-- | Derived location of the right-most point of an object + margin.
oRightX :: Lens' (ObjectData a) Double

-- | Derived location of an object's center point.
oCenterXY :: Lens' (ObjectData a) (V2 Double)

-- | Derived location of an object's center X value.
oCenterX :: Lens' (ObjectData a) Double

-- | Derived location of an object's center Y value.
oCenterY :: Lens' (ObjectData a) Double

-- | Lens for the source value contained in an object.
oValue :: Renderable a => Lens' (ObjectData a) a

-- | Instantly show object.
oShow :: Object s a -> Scene s ()

-- | Instantly hide object.
oHide :: Object s a -> Scene s ()

-- | Show object with an animator function. The animator is responsible for
--   transitioning the object from invisible to having its final shape. If
--   this doesn't hold true for the animator function then the final
--   animation will be discontinuous.
oShowWith :: Object s a -> (SVG -> Animation) -> Scene s ()

-- | Hide object with an animator function. The animator is responsible for
--   transitioning the object from visible to invisible. If this doesn't
--   hold true for the animator function then the final animation will be
--   discontinuous.
oHideWith :: Object s a -> (SVG -> Animation) -> Scene s ()

-- | Fade in object over a set duration.
oFadeIn :: SVG -> Animation

-- | Fade out object over a set duration.
oFadeOut :: SVG -> Animation

-- | Scale in object over a set duration.
--   
--   Example:
--   
--   <pre>
--   do txt &lt;- <a>oNew</a> $ <a>withStrokeWidth</a> 0 $ <a>withFillOpacity</a> 1 $
--        <a>center</a> $ <a>scale</a> 3 $ <a>latex</a> "oGrow"
--      <a>oShowWith</a> txt <a>oGrow</a>
--      <a>wait</a> 1; <a>oHideWith</a> txt <a>oFadeOut</a>
--   </pre>
--   
oGrow :: SVG -> Animation

-- | Scale out object over a set duration.
oShrink :: SVG -> Animation

-- | Morph source object into target object over a set duration.
oTransform :: Object s a -> Object s b -> Duration -> Scene s ()

-- | Relative coordinates for an SVG node.
type Origin = (Double, Double)

-- | Scale in children from left to right, with an origin at the top of
--   each child.
--   
--   Example:
--   
--   <pre>
--   do txt &lt;- <a>oNew</a> $ <a>withStrokeWidth</a> 0 $ <a>withFillOpacity</a> 1 $
--        <a>center</a> $ <a>scale</a> 3 $ <a>latex</a> "oScaleIn"
--      <a>oShowWith</a> txt $ <a>adjustDuration</a> (*2) . <a>oScaleIn</a>
--      <a>wait</a> 1; <a>oHideWith</a> txt <a>oFadeOut</a>
--   </pre>
--   
oScaleIn :: SVG -> Animation

-- | Like <a>oScaleIn</a> but takes an easing function and an origin.
oScaleIn' :: Signal -> Origin -> SVG -> Animation

-- | Scale out children from left to right, with an origin at the bottom of
--   each child.
--   
--   Example:
--   
--   <pre>
--   do txt &lt;- <a>oNew</a> $ <a>withStrokeWidth</a> 0 $ <a>withFillOpacity</a> 1 $
--        <a>center</a> $ <a>scale</a> 3 $ <a>latex</a> "oScaleOut"
--      <a>oShowWith</a> txt <a>oFadeIn</a>
--      <a>oHideWith</a> txt $ <a>adjustDuration</a> (*2) . <a>oScaleOut</a>
--   </pre>
--   
oScaleOut :: SVG -> Animation

-- | Like <a>oScaleOut</a> but takes an easing function and an origin.
oScaleOut' :: Signal -> Origin -> SVG -> Animation

-- | Render SVG by first drawing outlines and then filling shapes.
--   
--   Example:
--   
--   <pre>
--   do txt &lt;- <a>oNew</a> $ <a>withStrokeWidth</a> 0 $ <a>withFillOpacity</a> 1 $
--        <a>center</a> $ <a>scale</a> 4 $ <a>latex</a> "oDraw"
--      <a>oModify</a> txt $ <a>oEasing</a> .~ id
--      <a>oShowWith</a> txt <a>oDraw</a>; <a>wait</a> 1
--      <a>oHideWith</a> txt <a>oFadeOut</a>
--   </pre>
--   
oDraw :: SVG -> Animation

-- | Animate each child node in parallel.
oSim :: (SVG -> Animation) -> SVG -> Animation

-- | Animate each child node in parallel, staggered by 0.2 seconds.
oStagger :: (SVG -> Animation) -> SVG -> Animation

-- | Animate each child node in parallel, staggered by 0.2 seconds and in
--   reverse order.
oStaggerRev :: (SVG -> Animation) -> SVG -> Animation

-- | Animate each child node in parallel, staggered by a given duration.
oStagger' :: Duration -> (SVG -> Animation) -> SVG -> Animation

-- | Animate each child node in parallel, staggered by given duration and
--   in reverse order.
oStaggerRev' :: Duration -> (SVG -> Animation) -> SVG -> Animation

-- | Basic object mapping to &lt;circle/&gt; in SVG.
newtype Circle
Circle :: Double -> Circle
[_circleRadius] :: Circle -> Double

-- | Circle radius in local units.
circleRadius :: Lens' Circle Double

-- | Basic object mapping to &lt;rect/&gt; in SVG.
data Rectangle
Rectangle :: Double -> Double -> Rectangle
[_rectWidth] :: Rectangle -> Double
[_rectHeight] :: Rectangle -> Double

-- | Rectangle width in local units.
rectWidth :: Lens' Rectangle Double

-- | Rectangle height in local units.
rectHeight :: Lens' Rectangle Double

-- | Object representing an interpolation between SVG nodes.
data Morph
Morph :: Double -> SVG -> SVG -> Morph
[_morphDelta] :: Morph -> Double
[_morphSrc] :: Morph -> SVG
[_morphDst] :: Morph -> SVG

-- | Control variable for the interpolation. A value of 0 gives the source
--   SVG and 1 gives the target svg.
morphDelta :: Lens' Morph Double

-- | Source shape.
morphSrc :: Lens' Morph SVG

-- | Target shape.
morphDst :: Lens' Morph SVG

-- | Cameras can take control of objects and manipulate them with
--   convenient pan and zoom operations.
data Camera
Camera :: Camera

-- | Connect an object to a camera such that camera settings (position,
--   zoom, and rotation) is applied to the object.
--   
--   Example
--   
--   <pre>
--   do cam &lt;- <a>newObject</a> <a>Camera</a>
--      circ &lt;- <a>newObject</a> $ <a>Circle</a> 2
--      <a>oModifyS</a> circ $
--        <a>oContext</a> .= <a>withFillOpacity</a> 1 . <a>withFillColor</a> "blue"
--      <a>oShow</a> circ
--      <a>cameraAttach</a> cam circ
--      <a>cameraZoom</a> cam 1 2
--      <a>cameraZoom</a> cam 1 1
--   </pre>
--   
cameraAttach :: Object s Camera -> Object s a -> Scene s ()

-- | Example
--   
--   <pre>
--   do cam &lt;- <a>newObject</a> <a>Camera</a>
--      circ &lt;- <a>newObject</a> $ <a>Circle</a> 2; <a>oShow</a> circ
--      <a>oModify</a> circ $ <a>oTranslate</a> .~ (-3,0)
--      box &lt;- <a>newObject</a> $ <a>Rectangle</a> 4 4; <a>oShow</a> box
--      <a>oModify</a> box $ <a>oTranslate</a> .~ (3,0)
--      <a>cameraAttach</a> cam circ
--      <a>cameraAttach</a> cam box
--      <a>cameraFocus</a> cam (-3,0)
--      <a>cameraZoom</a> cam 2 2      -- Zoom in
--      <a>cameraZoom</a> cam 2 1      -- Zoom out
--      <a>cameraFocus</a> cam (3,0)
--      <a>cameraZoom</a> cam 2 2      -- Zoom in
--      <a>cameraZoom</a> cam 2 1      -- Zoom out
--   </pre>
--   
cameraFocus :: Object s Camera -> V2 Double -> Scene s ()

-- | Instantaneously set camera zoom level.
cameraSetZoom :: Object s Camera -> Double -> Scene s ()

-- | Change camera zoom level over a set duration.
cameraZoom :: Object s Camera -> Duration -> Double -> Scene s ()

-- | Instantaneously set camera location.
cameraSetPan :: Object s Camera -> V2 Double -> Scene s ()

-- | Change camera location over a set duration.
cameraPan :: Object s Camera -> Duration -> V2 Double -> Scene s ()

-- | Lift ST action into the Scene monad.
liftST :: ST s a -> Scene s a

-- | Apply a transformation with a given overlap. This makes sure to keep
--   timestamps intact such that events can still be timed by transcripts.
transitionO :: Transition -> Double -> (forall s'. Scene s' a) -> (forall s'. Scene s' b) -> Scene s ()

-- | Evaluate the value of a scene.
evalScene :: (forall s. Scene s a) -> a


-- | Reanimate is an animation library based on SVGs. It is designed to act
--   like glue between external components such as 'latex', 'ffmpeg',
--   'gnuplot', 'diagrams', and 'povray'.
--   
--   <h1>Canvas</h1>
--   
--   Reanimate uses its own internal, Cartesian coordinate system for
--   animations, with a fixed canvas size of 16x9, where X and Y are real
--   numbers. (0, 0) is located in the center of the canvas, with positive
--   X going to the right, and positive Y going up. This means that e.g.
--   (8, 4.5) is the top right corner and (-8, -4.5) is the bottom left
--   corner. Note that this canvas size does not affect how large or small
--   output resolution will be, although it <i>does</i> affect aspect
--   ratio.
--   
--   <h1>Driver</h1>
--   
--   Reanimate features a web-based viewer which is opened by default if no
--   other parameters are given. Key features:
--   
--   <ul>
--   <li>This viewer listens for changes to the source file and recompiles
--   the code automatically as needed.</li>
--   <li>Animations are rendered with increasing fidelity until the frame
--   rate reaches 60 fps.</li>
--   <li>Key commands for pausing, frame stepping, forward/rewind. To pause
--   press SPACE, to move -1/+1/-10/+10 frames use LEFT/RIGHT/DOWN/UP arrow
--   keys.</li>
--   </ul>
module Reanimate

-- | Main entry-point for accessing an animation. Creates a program that
--   takes the following command-line arguments:
--   
--   <pre>
--   Usage: PROG [COMMAND]
--     This program contains an animation which can either be viewed in a web-browser
--     or rendered to disk.
--   
--   Available options:
--     -h,--help                Show this help text
--   
--   Available commands:
--     check                    Run a system's diagnostic and report any missing
--                              external dependencies.
--     view                     Play animation in browser window.
--     render                   Render animation to file.
--   </pre>
--   
--   Neither the 'check' nor the 'view' command take any additional
--   arguments. Rendering animation can be controlled with these arguments:
--   
--   <pre>
--   Usage: PROG render [-o|--target FILE] [--fps FPS] [-w|--width PIXELS]
--                      [-h|--height PIXELS] [--compile] [--format FMT]
--                      [--preset TYPE]
--     Render animation to file.
--   
--   Available options:
--     -o,--target FILE         Write output to FILE
--     --fps FPS                Set frames per second.
--     -w,--width PIXELS        Set video width.
--     -h,--height PIXELS       Set video height.
--     --compile                Compile source code before rendering.
--     --format FMT             Video format: mp4, gif, webm
--     --preset TYPE            Parameter presets: youtube, gif, quick
--     -h,--help                Show this help text
--   </pre>
reanimate :: Animation -> IO ()

-- | Load a reanimate program in GHCi and make sure <tt>main</tt> is
--   available. Then run: <tt> :cmd reanimateLive </tt>
--   
--   This works by sending the commands ':r' and ':main' to your GHCi
--   instance when any source file is changed.
reanimateLive :: IO String

-- | Load an animation in GHCi. Anything of type <tt>Animation</tt> can be
--   live reloaded.
--   
--   <pre>
--   :cmd reanimateLiveEntry "drawCircle"
--   </pre>
--   
--   This works by sending the commands ':r' and 'Reanimate.reanimate
--   {entry}' to your GHCi instance when any source file is changed.
reanimateLiveEntry :: String -> IO String

-- | SVG node.
type SVG = Tree

-- | Time signal. Goes from 0 to 1, inclusive.
type Time = Double

-- | Duration of an animation or effect. Usually measured in seconds.
type Duration = Double

-- | Animations are SVGs over a finite time.
data Animation

-- | Construct an animation with a given duration.
mkAnimation :: Duration -> (Time -> SVG) -> Animation

-- | Construct an animation with a duration of <tt>1</tt>.
animate :: (Time -> SVG) -> Animation

-- | Create an animation with provided <tt>duration</tt>, which consists of
--   stationary frame displayed for its entire duration.
staticFrame :: Duration -> SVG -> Animation

-- | Query the duration of an animation.
duration :: Animation -> Duration

-- | Calculate the frame that would be displayed at given point in
--   <tt>time</tt> of running <tt>animation</tt>.
--   
--   The provided time parameter is clamped between 0 and animation
--   duration.
frameAt :: Time -> Animation -> SVG

-- | Play animations in sequence. The <tt>lhs</tt> animation is removed
--   after it has completed. New animation duration is '<tt>duration lhs +
--   duration rhs</tt>'.
--   
--   Example:
--   
--   <pre>
--   <a>drawBox</a> `<a>seqA</a>` <a>drawCircle</a>
--   </pre>
--   
seqA :: Animation -> Animation -> Animation

-- | Play two animation concurrently. Shortest animation freezes on last
--   frame. New animation duration is '<tt>max (duration lhs) (duration
--   rhs)</tt>'.
--   
--   Example:
--   
--   <pre>
--   <a>drawBox</a> `<a>parA</a>` <a>adjustDuration</a> (*2) <a>drawCircle</a>
--   </pre>
--   
parA :: Animation -> Animation -> Animation

-- | Play two animation concurrently. Shortest animation loops. New
--   animation duration is '<tt>max (duration lhs) (duration rhs)</tt>'.
--   
--   Example:
--   
--   <pre>
--   <a>drawBox</a> `<a>parLoopA</a>` <a>adjustDuration</a> (*2) <a>drawCircle</a>
--   </pre>
--   
parLoopA :: Animation -> Animation -> Animation

-- | Play two animation concurrently. Animations disappear after playing
--   once. New animation duration is '<tt>max (duration lhs) (duration
--   rhs)</tt>'.
--   
--   Example:
--   
--   <pre>
--   <a>drawBox</a> `<a>parDropA</a>` <a>adjustDuration</a> (*2) <a>drawCircle</a>
--   </pre>
--   
parDropA :: Animation -> Animation -> Animation

-- | Empty animation (no SVG output) with a fixed duration.
--   
--   Example:
--   
--   <pre>
--   <a>pause</a> 1 `<a>seqA</a>` <a>drawProgress</a>
--   </pre>
--   
pause :: Duration -> Animation

-- | Play left animation and freeze on the last frame, then play the right
--   animation. New duration is '<tt>duration lhs + duration rhs</tt>'.
--   
--   Example:
--   
--   <pre>
--   <a>drawBox</a> `<a>andThen</a>` <a>drawCircle</a>
--   </pre>
--   
andThen :: Animation -> Animation -> Animation

-- | Map over the SVG produced by an animation at every frame.
--   
--   Example:
--   
--   <pre>
--   <a>mapA</a> (<tt>scale</tt> 0.5) <a>drawCircle</a>
--   </pre>
--   
mapA :: (SVG -> SVG) -> Animation -> Animation

-- | Freeze the last frame for <tt>t</tt> seconds at the end of the
--   animation.
--   
--   Example:
--   
--   <pre>
--   <a>pauseAtEnd</a> 1 <a>drawProgress</a>
--   </pre>
--   
pauseAtEnd :: Duration -> Animation -> Animation

-- | Freeze the first frame for <tt>t</tt> seconds at the beginning of the
--   animation.
--   
--   Example:
--   
--   <pre>
--   <a>pauseAtBeginning</a> 1 <a>drawProgress</a>
--   </pre>
--   
pauseAtBeginning :: Duration -> Animation -> Animation

-- | Freeze the first and the last frame of the animation for a specified
--   duration.
--   
--   Example:
--   
--   <pre>
--   <a>pauseAround</a> 1 1 <a>drawProgress</a>
--   </pre>
--   
pauseAround :: Duration -> Duration -> Animation -> Animation

-- | Change the duration of an animation. Animates are stretched or
--   squished (rather than truncated) to fit the new duration.
adjustDuration :: (Duration -> Duration) -> Animation -> Animation

-- | Set the duration of an animation by adjusting its playback rate. The
--   animation is still played from start to finish without being cropped.
setDuration :: Duration -> Animation -> Animation

-- | Play an animation in reverse. Duration remains unchanged. Shorthand
--   for: <tt><a>signalA</a> <a>reverseS</a></tt>.
--   
--   Example:
--   
--   <pre>
--   <a>reverseA</a> <a>drawCircle</a>
--   </pre>
--   
reverseA :: Animation -> Animation

-- | Play animation before playing it again in reverse. Duration is twice
--   the duration of the input.
--   
--   Example:
--   
--   <pre>
--   <a>playThenReverseA</a> <a>drawCircle</a>
--   </pre>
--   
playThenReverseA :: Animation -> Animation

-- | Loop animation <tt>n</tt> number of times. This number may be
--   fractional and it may be less than 1. It must be greater than or equal
--   to 0, though. New duration is <tt>n*duration input</tt>.
--   
--   Example:
--   
--   <pre>
--   <a>repeatA</a> 1.5 <a>drawCircle</a>
--   </pre>
--   
repeatA :: Double -> Animation -> Animation

-- | <tt>freezeAtPercentage time animation</tt> creates an animation
--   consisting of stationary frame, that would be displayed in the
--   provided <tt>animation</tt> at given <tt>time</tt>. The duration of
--   the new animation is the same as the duration of provided
--   <tt>animation</tt>.
freezeAtPercentage :: Time -> Animation -> Animation

-- | Overlay animation on top of static SVG image.
--   
--   Example:
--   
--   <pre>
--   <a>addStatic</a> (<tt>mkBackground</tt> "lightblue") <a>drawCircle</a>
--   </pre>
--   
addStatic :: SVG -> Animation -> Animation

-- | Modify the time component of an animation. Animation duration is
--   unchanged.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<tt>fromToS</tt> 0.25 0.75) <a>drawCircle</a>
--   </pre>
--   
signalA :: Signal -> Animation -> Animation

-- | Signals are time-varying variables. Signals can be composed using
--   function composition.
type Signal = Double -> Double

-- | Constant signal.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>constantS</a> 0.5) <a>drawProgress</a>
--   </pre>
--   
constantS :: Double -> Signal

-- | Signal with new starting and end values.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>fromToS</a> 0.8 0.2) <a>drawProgress</a>
--   </pre>
--   
fromToS :: Double -> Double -> Signal

-- | Reverse signal order.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> <a>reverseS</a> <a>drawProgress</a>
--   </pre>
--   
reverseS :: Signal

-- | S-curve signal. Takes a steepness parameter. 2 is a good default.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>curveS</a> 2) <a>drawProgress</a>
--   </pre>
--   
curveS :: Double -> Signal

-- | Power curve signal. Takes a steepness parameter. 2 is a good default.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>powerS</a> 2) <a>drawProgress</a>
--   </pre>
--   
powerS :: Double -> Signal

-- | Bell-curve signal. Takes a steepness parameter. 2 is a good default.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>bellS</a> 2) <a>drawProgress</a>
--   </pre>
--   
bellS :: Double -> Signal

-- | Oscillate signal.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> <a>oscillateS</a> <a>drawProgress</a>
--   </pre>
--   
oscillateS :: Signal

-- | Cubic Bezier signal. Gives you a fair amount of control over how the
--   signal will curve.
--   
--   Example:
--   
--   <pre>
--   <a>signalA</a> (<a>cubicBezierS</a> (0.0, 0.8, 0.9, 1.0)) <a>drawProgress</a>
--   </pre>
--   
cubicBezierS :: (Double, Double, Double, Double) -> Signal

-- | A <a>Scene</a> represents a sequence of animations and variables that
--   change over time.
data Scene s a

-- | The ZIndex property specifies the stack order of sprites and
--   animations. Elements with a higher ZIndex will be drawn on top of
--   elements with a lower index.
type ZIndex = Int

-- | Render a <a>Scene</a> to an <a>Animation</a>.
scene :: (forall s. Scene s a) -> Animation

-- | Play an animation once and then remove it. This advances the clock by
--   the duration of the animation.
--   
--   Example:
--   
--   <pre>
--   do <a>play</a> <a>drawBox</a>
--      <a>play</a> <a>drawCircle</a>
--   </pre>
--   
play :: Animation -> Scene s ()

-- | Execute actions in a scene without advancing the clock. Note that
--   scenes do not end before all forked actions have completed.
--   
--   Example:
--   
--   <pre>
--   do <a>fork</a> $ <a>play</a> <a>drawBox</a>
--      <a>play</a> <a>drawCircle</a>
--   </pre>
--   
fork :: Scene s a -> Scene s a

-- | Query the current clock timestamp.
--   
--   Example:
--   
--   <pre>
--   do now &lt;- <a>play</a> <a>drawCircle</a> *&gt; <a>queryNow</a>
--      <a>play</a> $ <tt>staticFrame</tt> 1 $ <tt>scale</tt> 2 $ <tt>withStrokeWidth</tt> 0.05 $
--        <tt>mkText</tt> $ "Now=" &lt;&gt; T.pack (show now)
--   </pre>
--   
queryNow :: Scene s Time

-- | Advance the clock by a given number of seconds.
--   
--   Example:
--   
--   <pre>
--   do <a>fork</a> $ <a>play</a> <a>drawBox</a>
--      <a>wait</a> 1
--      <a>play</a> <a>drawCircle</a>
--   </pre>
--   
wait :: Duration -> Scene s ()

-- | Wait until the clock is equal to the given timestamp.
waitUntil :: Time -> Scene s ()

-- | Wait until all forked and sequential animations have finished.
--   
--   Example:
--   
--   <pre>
--   do <a>waitOn</a> $ <a>fork</a> $ <a>play</a> <a>drawBox</a>
--      <a>play</a> <a>drawCircle</a>
--   </pre>
--   
waitOn :: Scene s a -> Scene s a

-- | Change the ZIndex of a scene.
adjustZ :: (ZIndex -> ZIndex) -> Scene s a -> Scene s a

-- | Query the duration of a scene.
withSceneDuration :: Scene s () -> Scene s Duration

-- | Time dependent variable.
data Var s a

-- | Create a new variable with a default value. Variables always have a
--   defined value even if they are read at a timestamp that is earlier
--   than when the variable was created. For example:
--   
--   <pre>
--   do v &lt;- <a>fork</a> (<a>wait</a> 10 &gt;&gt; <a>newVar</a> 0) -- Create a variable at timestamp '10'.
--      <a>readVar</a> v                       -- Read the variable at timestamp '0'.
--                                      -- The value of the variable will be '0'.
--   </pre>
newVar :: a -> Scene s (Var s a)

-- | Read the value of a variable at the current timestamp.
readVar :: Var s a -> Scene s a

-- | Write the value of a variable at the current timestamp.
--   
--   Example:
--   
--   <pre>
--   do v &lt;- <a>newVar</a> 0
--      <a>newSprite</a> $ <a>mkCircle</a> &lt;$&gt; <a>unVar</a> v
--      <a>writeVar</a> v 1; <a>wait</a> 1
--      <a>writeVar</a> v 2; <a>wait</a> 1
--      <a>writeVar</a> v 3; <a>wait</a> 1
--   </pre>
--   
writeVar :: Var s a -> a -> Scene s ()

-- | Modify the value of a variable at the current timestamp and all future
--   timestamps.
modifyVar :: Var s a -> (a -> a) -> Scene s ()

-- | Modify a variable between <tt>now</tt> and <tt>now+duration</tt>.
tweenVar :: Var s a -> Duration -> (a -> Time -> a) -> Scene s ()

-- | Create and render a variable. The rendering will be born at the
--   current timestamp and will persist until the end of the scene.
--   
--   Example:
--   
--   <pre>
--   do var &lt;- <a>simpleVar</a> <a>mkCircle</a> 0
--      <a>tweenVar</a> var 2 $ \val -&gt; <a>fromToS</a> val (<a>screenHeight</a>/2)
--   </pre>
--   
simpleVar :: (a -> SVG) -> a -> Scene s (Var s a)

-- | Helper function for filtering variables.
findVar :: (a -> Bool) -> [Var s a] -> Scene s (Var s a)

-- | Sprites are animations with a given time of birth as well as a time of
--   death. They can be controlled using variables, tweening, and effects.
data Sprite s

-- | Sprite frame generator. Generates frames over time in a stateful
--   environment.
data Frame s a

-- | Dereference a variable as a Sprite frame.
--   
--   Example:
--   
--   <pre>
--   do v &lt;- <a>newVar</a> 0
--      <a>newSprite</a> $ <a>mkCircle</a> &lt;$&gt; <a>unVar</a> v
--      <a>tweenVar</a> v 1 $ \val -&gt; <a>fromToS</a> val 3
--      <a>tweenVar</a> v 1 $ \val -&gt; <a>fromToS</a> val 0
--   </pre>
--   
unVar :: Var s a -> Frame s a

-- | Dereference seconds since sprite birth.
spriteT :: Frame s Time

-- | Dereference duration of the current sprite.
spriteDuration :: Frame s Duration

-- | Create new sprite defined by a frame generator. Unless otherwise
--   specified using <a>destroySprite</a>, the sprite will die at the end
--   of the scene.
--   
--   Example:
--   
--   <pre>
--   do <a>newSprite</a> $ <a>mkCircle</a> &lt;$&gt; <a>spriteT</a> -- Circle sprite where radius=time.
--      <a>wait</a> 2
--   </pre>
--   
newSprite :: Frame s SVG -> Scene s (Sprite s)

-- | Create new sprite defined by a frame generator. The sprite will die at
--   the end of the scene.
newSprite_ :: Frame s SVG -> Scene s ()

-- | Create a new sprite from an animation. This advances the clock by the
--   duration of the animation. Unless otherwise specified using
--   <a>destroySprite</a>, the sprite will die at the end of the scene.
--   
--   Note: If the scene doesn't end immediately after the duration of the
--   animation, the animation will be stretched to match the lifetime of
--   the sprite. See <a>newSpriteA'</a> and <a>play</a>.
--   
--   Example:
--   
--   <pre>
--   do <a>fork</a> $ <a>newSpriteA</a> <a>drawCircle</a>
--      <a>play</a> <a>drawBox</a>
--      <a>play</a> $ <a>reverseA</a> <a>drawBox</a>
--   </pre>
--   
newSpriteA :: Animation -> Scene s (Sprite s)

-- | Create a new sprite from an animation and specify the synchronization
--   policy. This advances the clock by the duration of the animation.
--   
--   Example:
--   
--   <pre>
--   do <a>fork</a> $ <a>newSpriteA'</a> <a>SyncFreeze</a> <a>drawCircle</a>
--      <a>play</a> <a>drawBox</a>
--      <a>play</a> $ <a>reverseA</a> <a>drawBox</a>
--   </pre>
--   
newSpriteA' :: Sync -> Animation -> Scene s (Sprite s)

-- | Create a sprite from a static SVG image.
--   
--   Example:
--   
--   <pre>
--   do <a>newSpriteSVG</a> $ <a>mkBackground</a> "lightblue"
--      <a>play</a> <a>drawCircle</a>
--   </pre>
--   
newSpriteSVG :: SVG -> Scene s (Sprite s)

-- | Create a permanent sprite from a static SVG image. Same as
--   <a>newSpriteSVG</a> but the sprite isn't returned and thus cannot be
--   destroyed.
newSpriteSVG_ :: SVG -> Scene s ()

-- | Destroy a sprite, preventing it from being rendered in the future of
--   the scene. If <a>destroySprite</a> is invoked multiple times, the
--   earliest time-of-death is used.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>newSpriteSVG</a> $ <a>withFillOpacity</a> 1 $ <a>mkCircle</a> 1
--      <a>fork</a> $ <a>wait</a> 1 &gt;&gt; <a>destroySprite</a> s
--      <a>play</a> <a>drawBox</a>
--   </pre>
--   
destroySprite :: Sprite s -> Scene s ()

-- | Change the rendering of a sprite using data from a variable. If data
--   from several variables is needed, use a frame generator instead.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>fork</a> $ <a>newSpriteA</a> <a>drawBox</a>
--      v &lt;- <a>newVar</a> 0
--      <a>applyVar</a> v s <a>rotate</a>
--      <a>tweenVar</a> v 2 $ \val -&gt; <a>fromToS</a> val 90
--   </pre>
--   
applyVar :: Var s a -> Sprite s -> (a -> SVG -> SVG) -> Scene s ()

-- | Low-level frame modifier.
spriteModify :: Sprite s -> Frame s ((SVG, ZIndex) -> (SVG, ZIndex)) -> Scene s ()

-- | Map the SVG output of a sprite.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>fork</a> $ <a>newSpriteA</a> <a>drawCircle</a>
--      <a>wait</a> 1
--      <a>spriteMap</a> s <a>flipYAxis</a>
--   </pre>
--   
spriteMap :: Sprite s -> (SVG -> SVG) -> Scene s ()

-- | Modify the output of a sprite between <tt>now</tt> and
--   <tt>now+duration</tt>.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>fork</a> $ <a>newSpriteA</a> <a>drawCircle</a>
--      <a>spriteTween</a> s 1 $ \val -&gt; <a>translate</a> (<a>screenWidth</a>*0.3*val) 0
--   </pre>
--   
spriteTween :: Sprite s -> Duration -> (Double -> SVG -> SVG) -> Scene s ()

-- | Create a new variable and apply it to a sprite.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>fork</a> $ <a>newSpriteA</a> <a>drawBox</a>
--      v &lt;- <a>spriteVar</a> s 0 <a>rotate</a>
--      <a>tweenVar</a> v 2 $ \val -&gt; <a>fromToS</a> val 90
--   </pre>
--   
spriteVar :: Sprite s -> a -> (a -> SVG -> SVG) -> Scene s (Var s a)

-- | Apply an effect to a sprite.
--   
--   Example:
--   
--   <pre>
--   do s &lt;- <a>fork</a> $ <a>newSpriteA</a> <a>drawCircle</a>
--      <a>spriteE</a> s $ <a>overBeginning</a> 1 <a>fadeInE</a>
--      <a>spriteE</a> s $ <a>overEnding</a> 0.5 <a>fadeOutE</a>
--   </pre>
--   
spriteE :: Sprite s -> Effect -> Scene s ()

-- | Set new ZIndex of a sprite.
--   
--   Example:
--   
--   <pre>
--   do s1 &lt;- <a>newSpriteSVG</a> $ <a>withFillOpacity</a> 1 $ <a>withFillColor</a> "blue" $ <a>mkCircle</a> 3
--      <a>newSpriteSVG</a> $ <a>withFillOpacity</a> 1 $ <a>withFillColor</a> "red" $ <a>mkRect</a> 8 3
--      <a>wait</a> 1
--      <a>spriteZ</a> s1 1
--      <a>wait</a> 1
--   </pre>
--   
spriteZ :: Sprite s -> ZIndex -> Scene s ()

-- | Destroy all local sprites at the end of a scene.
--   
--   Example:
--   
--   <pre>
--   do -- the rect lives through the entire 3s animation
--      <a>newSpriteSVG_</a> $ <a>translate</a> (-3) 0 $ <a>mkRect</a> 4 4
--      <a>wait</a> 1
--      <a>spriteScope</a> $ do
--        -- the circle only lives for 1 second.
--        local &lt;- <a>newSpriteSVG</a> $ <a>translate</a> 3 0 $ <a>mkCircle</a> 2
--        <a>spriteE</a> local $ <a>overBeginning</a> 0.3 <a>fadeInE</a>
--        <a>spriteE</a> local $ <a>overEnding</a> 0.3 <a>fadeOutE</a>
--        <a>wait</a> 1
--      <a>wait</a> 1
--   </pre>
--   
spriteScope :: Scene s a -> Scene s a

-- | An Effect represents a modification of a SVG <a>Tree</a> that can vary
--   with time.
type Effect = Duration " Duration of the effect (in seconds)" -> Time " Time elapsed from when the effect started (in seconds)" -> Tree " Image to be modified" -> Tree " Image after modification"

-- | Modify the effect so that it only applies to the initial part of the
--   animation.
overBeginning :: Duration -> Effect -> Effect

-- | Modify the effect so that it only applies to the ending part of the
--   animation.
overEnding :: Duration -> Effect -> Effect

-- | Modify the effect so that it only applies within given interval of
--   animation's running time.
overInterval :: Time -> Time -> Effect -> Effect

-- | <tt>reverseE effect</tt> starts where the <tt>effect</tt> ends and
--   vice versa.
reverseE :: Effect -> Effect

-- | Delay the effect so that it only starts after specified duration and
--   then runs till the end of animation.
delayE :: Duration -> Effect -> Effect

-- | Modify the animation by applying the effect. If desired, you can apply
--   multiple effects to single animation by calling this function multiple
--   times.
applyE :: Effect -> Animation -> Animation

-- | Build an effect from an image-modifying function. This effect does not
--   change as time passes.
constE :: (Tree -> Tree) -> Effect

-- | Change image opacity from 0 to 1.
fadeInE :: Effect

-- | Change image opacity from 1 to 0. Reverse of <a>fadeInE</a>.
fadeOutE :: Effect

-- | Change stroke width from 0 to given value.
fadeLineInE :: Double -> Effect

-- | Change stroke width from given value to 0. Reverse of
--   <a>fadeLineInE</a>.
fadeLineOutE :: Double -> Effect

-- | Effect of progressively drawing the image. Note that this will only
--   affect primitive shapes (see <a>pathify</a>).
drawInE :: Effect

-- | Reverse of <a>drawInE</a>.
drawOutE :: Effect

-- | Change fill opacity from 0 to 1.
fillInE :: Effect

-- | Change scale from 1 to given value.
scaleE :: Double -> Effect

-- | Move the image from its current position to the target x y
--   coordinates.
translateE :: Double -> Double -> Effect

-- | Transform the effect so that the image passed to the effect's
--   image-modifying function has coordinates (0, 0) shifted to the center
--   of its bounding box. Also see <a>aroundCenter</a>.
aroundCenterE :: Effect -> Effect

-- | Load an external image. Width and height must be specified, ignoring
--   the image's aspect ratio. The center of the image is placed at
--   position (0,0).
--   
--   For security reasons, must SVG renderer do not allow arbitrary image
--   links. For some renderers, we can get around this by placing the
--   images in the same root directory as the parent SVG file. Other
--   renderers (like Chrome and ffmpeg) requires that the image is inlined
--   as base64 data. External SVG files are an exception, though, as must
--   always be inlined directly. <a>mkImage</a> attempts to hide all the
--   complexity but edge-cases may exist.
--   
--   Example:
--   
--   <pre>
--   <a>mkImage</a> <a>screenWidth</a> <a>screenHeight</a> "../data/haskell.svg"
--   </pre>
--   
mkImage :: Double -> Double -> FilePath -> SVG

-- | Embed an in-memory PNG image. Note, the pixel size of the image is
--   used as the dimensions. As such, embedding a 100x100 PNG will result
--   in an image 100 units wide and 100 units high. Consider using with
--   <tt>scaleToSize</tt>.
embedImage :: PngSavable a => Image a -> SVG

-- | Embed an in-memory image. Note, the pixel size of the image is used as
--   the dimensions. As such, embedding a 100x100 image will result in an
--   image 100 units wide and 100 units high. Consider using with
--   <tt>scaleToSize</tt>.
embedDynamicImage :: DynamicImage -> SVG

-- | Embed in-memory PNG bytestring without parsing it.
embedPng :: Double -> Double -> ByteString -> SVG

-- | Convert an SVG object to a pixel-based image. The default resolution
--   is 2560x1440. See also <a>rasterSized</a>. Multiple raster engines are
--   supported and are selected using the '--raster' flag in the driver.
raster :: SVG -> DynamicImage

-- | Convert an SVG object to a pixel-based image.
rasterSized :: Width -> Height -> SVG -> DynamicImage

-- | Convert an SVG object to a pixel-based image and save it to disk,
--   returning the filepath. The default resolution is 2560x1440. See also
--   <a>svgAsPngFile'</a>. Multiple raster engines are supported and are
--   selected using the '--raster' flag in the driver.
svgAsPngFile :: SVG -> FilePath

-- | Convert an SVG object to a pixel-based image and save it to disk,
--   returning the filepath.
svgAsPngFile' :: Width -> Height -> SVG -> FilePath

-- | Use 'potrace' to trace edges in a raster image and convert them to SVG
--   polygons.
vectorize :: FilePath -> SVG

-- | Same as <a>vectorize</a> but takes a list of arguments for 'potrace'.
vectorize_ :: [String] -> FilePath -> SVG

-- | Invoke latex and import the result as an SVG object. SVG objects are
--   cached to improve performance.
--   
--   Example:
--   
--   <pre>
--   latex "$e^{i\\pi}+1=0$"
--   </pre>
--   
latex :: Text -> Tree

-- | Invoke latex and import the result as an SVG object. SVG objects are
--   cached to improve performance. This wraps the TeX code in an 'align*'
--   context.
--   
--   Example:
--   
--   <pre>
--   latexAlign "R = \\frac{{\\Delta x}}{{kA}}"
--   </pre>
--   
latexAlign :: Text -> Tree

-- | Invoke xelatex and import the result as an SVG object. SVG objects are
--   cached to improve performance. Xelatex has support for non-western
--   scripts.
xelatex :: Text -> Tree

-- | Invoke xelatex with "usepackage[UTF8]{ctex}" and import the result as
--   an SVG object. SVG objects are cached to improve performance. Xelatex
--   has support for non-western scripts.
--   
--   Example:
--   
--   <pre>
--   ctex "中文"
--   </pre>
--   
ctex :: Text -> Tree

-- | Run the povray raytracer with a default resolution of 320x180 and
--   antialiasing enabled. The resulting image is scaled to fit the screen
--   exactly.
povray :: [String] -> Text -> Tree

-- | Run the povray raytracer with a default resolution of 320x180 and
--   antialiasing enabled. The FilePath points to a PNG file containing the
--   resulting image.
povray' :: [String] -> Text -> FilePath

-- | Run a Blender script and embed the resulting image file. The image
--   will be scaled to fit the screen exactly (assuming a default canvas
--   layout). Note that Blender resolution defaults to 1920x1080 but can be
--   changed in the script code.
blender :: Text -> SVG

-- | Generate Blender image as a separate PNG file. Can be embedded with
--   <a>mkImage</a>.
blender' :: Text -> FilePath

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “turbo” color scheme by Anton Mikhailov.
--   
turbo :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “viridis” perceptually-uniform color scheme designed by van
--   der Walt, Smith and Firing for matplotlib, represented as an RGB
--   string.
--   
viridis :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “magma” perceptually-uniform color scheme designed by van der
--   Walt and Smith for matplotlib, represented as an RGB string.
--   
magma :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “inferno” perceptually-uniform color scheme designed by van
--   der Walt and Smith for matplotlib, represented as an RGB string.
--   
inferno :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “plasma” perceptually-uniform color scheme designed by van
--   der Walt and Smith for matplotlib, represented as an RGB string.
--   
plasma :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “sinebow” color scheme by Jim Bumgardner and Charlie Loyd.
--   
sinebow :: Double -> PixelRGB8

-- | Parula is the default colormap for matlab.
--   
parula :: Double -> PixelRGB8

-- | Given a number t in the range [0,1], returns the corresponding color
--   from the “cividis” color vision deficiency-optimized color scheme
--   designed by Nuñez, Anderton, and Renslow, represented as an RGB
--   string.
--   
cividis :: Double -> PixelRGB8

-- | Jet colormap. Used to be the default in matlab. Obsolete.
--   
jet :: Double -> PixelRGB8

-- | hsv colormap. Goes from 0 degrees to 360 degrees.
--   
hsv :: Double -> PixelRGB8

-- | Matlab hsv colormap. Goes from 0 degrees to 330 degrees.
--   
hsvMatlab :: Double -> PixelRGB8

-- | Greyscale colormap.
--   
greyscale :: Double -> PixelRGB8

-- | Number of units from the left-most point to the right-most point on
--   the screen.
screenWidth :: Fractional a => a

-- | Number of units from the bottom to the top of the screen.
screenHeight :: Fractional a => a

-- | Position of the top of the screen.
screenTop :: Fractional a => a

-- | Position of the bottom of the screen.
screenBottom :: Fractional a => a

-- | Position of the left side of the screen.
screenLeft :: Fractional a => a

-- | Position of the right side of the screen.
screenRight :: Fractional a => a

-- | SVG allows measurements in inches which have to be converted to local
--   units. This value describes how many local units there are in an inch.
defaultDPI :: Dpi

-- | Default thickness of lines.
defaultStrokeWidth :: Double

-- | Selected framerate.
pFPS :: FPS

-- | Height of animation in pixel.
pHeight :: Height

-- | Width of animation in pixel.
pWidth :: Width


-- | This module provides functions for mapping the surface of a sphere on
--   to a 2D plane. It also has convenience functions for loading GeoJSON
--   data.
module Reanimate.GeoProjection

-- | Projections are named bi-directional mappings between a sphere and a
--   2D plane.
data Projection
Projection :: String -> !LonLat -> XYCoord -> !XYCoord -> LonLat -> Projection

-- | Name of the projection.
[projectionLabel] :: Projection -> String

-- | Mapping from longitude and latitude on a sphere to XY coordinates on a
--   2D plane.
[projectionForward] :: Projection -> !LonLat -> XYCoord

-- | Mapping from XY coordinates on a 2D plane to longitude and latitude on
--   a sphere.
[projectionInverse] :: Projection -> !XYCoord -> LonLat

-- | XY coordinates on a 2D plane. Valid ranges go from 0 to 1, inclusive.
data XYCoord
XYCoord :: !Double -> !Double -> XYCoord

-- | Longitude and latitude. Valid range for longitude is -pi to +pi. Valid
--   range for latitude is -pi<i>2 to +pi</i>2.
data LonLat
LonLat :: !Double -> !Double -> LonLat

-- | Apply on an image in equirectangular format. The source image therfore
--   must have an aspect ratio of 2:1.
project :: Image PixelRGBA8 -> Projection -> Image PixelRGBA8

-- | Interpolate between two projections and apply the result to an image
--   in equirectangular format. The source image must have an aspect ratio
--   of 2:1.
interpP :: Image PixelRGBA8 -> Projection -> Projection -> Double -> Image PixelRGBA8

-- | Interpolate between two projections and apply the result to an image
--   in equirectangular format. The source image must have an aspect ratio
--   of 2:1. Only the areas inside of the two bounding boxes (applying to
--   the source and target projection, respectively) are mapped. Pixels
--   outside of these bounding-boxes are undefined.
interpBBP :: Image PixelRGBA8 -> Projection -> Projection -> (Double, Double, Double, Double) -> (Double, Double, Double, Double) -> Double -> Image PixelRGBA8

-- | Attempt to smoothly interpolate two projections. The result may not be
--   continuous and <a>interpP</a> may give prettier results.
mergeP :: Projection -> Projection -> Double -> Projection

-- | Returns <tt>True</tt> iff a projection is consistent and complete.
isValidP :: Projection -> Bool

-- | Scale X and Y axis of projection.
scaleP :: Double -> Double -> Projection -> Projection

-- | Invert the Y axis of projection.
flipYAxisP :: Projection -> Projection

-- | Translate the lower-most point of a projection by an offset.
moveBottomP :: Double -> Projection -> Projection

-- | Translate the top-most point of a projection by an offset.
moveTopP :: Double -> Projection -> Projection

equirectangularP :: Projection

mercatorP :: Projection

mollweideP :: Projection

hammerP :: Projection

cylindricalEqualAreaP :: Double -> Projection

lambertP :: Projection

bottomleyP :: Double -> Projection

sinusoidalP :: Projection

wernerP :: Projection

bonneP :: Double -> Projection

orthoP :: LonLat -> Projection

cassiniP :: Projection

augustP :: Projection

collignonP :: Projection

eckert1P :: Projection

eckert3P :: Projection

eckert5P :: Projection

faheyP :: Projection

foucautP :: Projection

lagrangeP :: Projection

-- | Map for all features and render the geometry.
drawFeatureCollection :: GeoFeatureCollection a -> (a -> SVG -> SVG) -> SVG

-- | Load GeoJSON from a filepath and render the geometry.
loadFeatureCollection :: FromJSON a => FilePath -> (a -> SVG -> SVG) -> SVG

-- | Apply a projection to an SVG image. This is a lossy transformation but
--   the default tolerance is low enough that inaccuracies should not be
--   visible.
applyProjection :: Projection -> SVG -> SVG

-- | Apply a projection to an SVG image with a specified tolerance.
--   Projections may turn straight lines into disjointed curves and the
--   tolerance argument determined the accuracy of this transformation.
applyProjection' :: Double -> Projection -> SVG -> SVG

-- | Render GeoJSON geometry as SVG.
renderGeometry :: GeospatialGeometry -> SVG
instance GHC.Classes.Ord Reanimate.GeoProjection.XYCoord
instance GHC.Classes.Eq Reanimate.GeoProjection.XYCoord
instance GHC.Show.Show Reanimate.GeoProjection.XYCoord
instance GHC.Read.Read Reanimate.GeoProjection.XYCoord
instance GHC.Classes.Ord Reanimate.GeoProjection.LonLat
instance GHC.Classes.Eq Reanimate.GeoProjection.LonLat
instance GHC.Show.Show Reanimate.GeoProjection.LonLat
instance GHC.Read.Read Reanimate.GeoProjection.LonLat
instance Data.Hashable.Class.Hashable Reanimate.GeoProjection.LonLat


module Reanimate.Builtin.Slide

slideLeftT :: Transition

slideDownT :: Transition

slideUpT :: Transition


module Reanimate.Builtin.Flip

-- | Control structure with parameters for the blender script.
data FlipSprite s
FlipSprite :: Sprite s -> Var s Double -> Var s Double -> Var s Double -> FlipSprite s
[fsSprite] :: FlipSprite s -> Sprite s
[fsBend] :: FlipSprite s -> Var s Double
[fsZoom] :: FlipSprite s -> Var s Double
[fsWobble] :: FlipSprite s -> Var s Double

-- | Project two animations on each side of a plane and flip the plane
--   upside down.
flipSprite :: Animation -> Animation -> Scene s (FlipSprite s)

-- | 3D flip transition.
flipTransition :: Transition


-- | Reanimate can automatically synchronize animations to your voice if
--   you have a transcript and an audio recording. This works with the help
--   of Gentle (<a>https://lowerquality.com/gentle/</a>). Accuracy is not
--   perfect but it is pretty close, and it is by far the easiest way of
--   adding narration to an animation.
module Reanimate.Voice

-- | Aligned transcript. Contains the transcript text as well as timing
--   data for each word.
data Transcript
Transcript :: Text -> Map Text Int -> [TWord] -> Transcript
[transcriptText] :: Transcript -> Text
[transcriptKeys] :: Transcript -> Map Text Int
[transcriptWords] :: Transcript -> [TWord]

-- | Spoken word. Includes information about when it was spoken, its
--   duration, and its phonemes.
data TWord
TWord :: Text -> Text -> Double -> Int -> Double -> Int -> [Phone] -> Text -> TWord
[wordAligned] :: TWord -> Text
[wordCase] :: TWord -> Text

-- | Start of pronunciation in seconds
[wordStart] :: TWord -> Double

-- | Character index of word in transcript
[wordStartOffset] :: TWord -> Int

-- | End of pronunciation in seconds
[wordEnd] :: TWord -> Double

-- | Last character index of word in transcript
[wordEndOffset] :: TWord -> Int
[wordPhones] :: TWord -> [Phone]

-- | The word being pronounced.
[wordReference] :: TWord -> Text

-- | Phoneme type
data Phone
Phone :: Double -> Text -> Phone
[phoneDuration] :: Phone -> Double
[phoneType] :: Phone -> Text

-- | Locate the first word that occurs after all the given keys. An error
--   is thrown if no such word exists. An error is thrown if the keys do
--   not exist in the transcript.
findWord :: Transcript -> [Text] -> Text -> TWord

-- | Locate all words that occur after all the given keys. May return an
--   empty list. An error is thrown if the keys do not exist in the
--   transcript.
findWords :: Transcript -> [Text] -> Text -> [TWord]

-- | Loading a transcript does three things depending on which files are
--   available with the same basename as the input argument: 1. If a JSON
--   file is available, it is parsed and returned. 2. If an audio file is
--   available, reanimate tries to align it by calling out to Gentle on
--   localhost:8765/. If Gentle is not running, an error will be thrown. 3.
--   If only the text transcript is available, a fake transcript is
--   returned, with timings roughly at 120 words per minute.
loadTranscript :: FilePath -> Transcript

-- | Fake transcript timings at roughly 120 words per minute.
fakeTranscript :: Text -> Transcript

-- | Convert the transcript text to an SVG image using LaTeX and associate
--   each word image with its timing information.
splitTranscript :: Transcript -> [(SVG, TWord)]

-- | Helper function for rendering a transcript.
annotateWithTranscript :: Transcript -> Scene s ()
instance GHC.Show.Show Reanimate.Voice.Phone
instance GHC.Show.Show Reanimate.Voice.TWord
instance GHC.Show.Show Reanimate.Voice.Transcript
instance GHC.Show.Show Reanimate.Voice.Token
instance Data.Aeson.Types.FromJSON.FromJSON Reanimate.Voice.Transcript
instance Data.Aeson.Types.FromJSON.FromJSON Reanimate.Voice.TWord
instance Data.Aeson.Types.FromJSON.FromJSON Reanimate.Voice.Phone
