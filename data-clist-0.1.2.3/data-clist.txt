-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple functional ring type.
--   
--   Simple functional bidirectional ring type. Given that the ring
--   terminiology clashes with certain mathematical branches, we're using
--   the term CList or CircularList instead.
@package data-clist
@version 0.1.2.3


-- | A simple purely functional circular list, or ring, data type.
--   
--   Lets describe what we mean by <tt>ring</tt>. A ring is a circular data
--   structure such that if you continue rotating the ring, you'll
--   eventually return to the element you first observed.
--   
--   All of our analogies involve sitting at a table who's top surface
--   rotates about its center axis (think of those convenient rotating
--   platforms one often finds in an (Americanized) Chinese Restaurant).
--   
--   Only the closest item on the table is avialable to us. In order to
--   reach other elements on the table, we need to rotate the table to the
--   left or the right.
--   
--   Our convention for this problem says that rotations to the right are a
--   forward motion while rotations to the left are backward motions.
--   
--   We'll use the following circular list for our examples:
--   
--   <pre>
--     8 7 6
--    9     5
--   A       4
--   B       3
--    C     2
--     D 0 1
--       ^
--   </pre>
--   
--   The pointer at the bottom represents our position at the table. The
--   element currently in front of is is referred to as the <a>focus</a>.
--   So, in this case, our focus is 0.
--   
--   If we were to rotate the table to the right using the <a>rotR</a>
--   operation, we'd have the following table.
--   
--   <pre>
--     9 8 7
--    A     6
--   B       5
--   C       4
--    D     3
--     0 1 2
--       ^
--   </pre>
--   
--   This yields 1 as our new focus. Rotating this table left would return
--   0 to the focus position.
module Data.CircularList

-- | A functional ring type.
data CList a

-- | An empty CList.
empty :: CList a

-- | Make a (balanced) CList from a list.
fromList :: [a] -> CList a
singleton :: a -> CList a

-- | Replaces the current focus with a new focus.
update :: a -> CList a -> CList a

-- | Reverse the direction of rotation.
reverseDirection :: CList a -> CList a

-- | Starting with the focus, go left and accumulate all elements of the
--   CList in a list.
leftElements :: CList a -> [a]

-- | Starting with the focus, go right and accumulate all elements of the
--   CList in a list.
rightElements :: CList a -> [a]

-- | Make a list from a CList.
toList :: CList a -> [a]

-- | Make a CList into an infinite list.
toInfList :: CList a -> [a]

-- | Return the focus of the CList.
focus :: CList a -> Maybe a

-- | Insert an element into the CList as the new focus. The old focus is
--   now the next element to the left.
insertL :: a -> CList a -> CList a

-- | Insert an element into the CList as the new focus. The old focus is
--   now the next element to the right.
insertR :: a -> CList a -> CList a

-- | Remove the focus from the CList. The new focus is the next element to
--   the left.
removeL :: CList a -> CList a

-- | Remove the focus from the CList.
removeR :: CList a -> CList a

-- | Return all possible rotations of the provided <a>CList</a>, where the
--   focus is the provided <a>CList</a>.
allRotations :: CList a -> CList (CList a)

-- | Rotate the focus to the next (right) element.
rotR :: CList a -> CList a

-- | Rotate the focus to the previous (left) element.
rotL :: CList a -> CList a

-- | Rotate the focus the specified number of times; if the index is
--   positive then it is rotated to the right; otherwise it is rotated to
--   the left.
rotN :: Int -> CList a -> CList a

-- | A wrapper around <a>rotN</a> that doesn't rotate the CList if <tt>n
--   &lt;= 0</tt>.
rotNR :: Int -> CList a -> CList a

-- | Rotate the focus the specified number of times to the left (but don't
--   rotate if <tt>n &lt;= 0</tt>).
rotNL :: Int -> CList a -> CList a

-- | Rotate the <a>CList</a> such that the specified element (if it exists)
--   is focused.
rotateTo :: Eq a => a -> CList a -> Maybe (CList a)

-- | Attempt to rotate the <a>CList</a> such that focused element matches
--   the supplied predicate.
findRotateTo :: (a -> Bool) -> CList a -> Maybe (CList a)

-- | Remove those elements that do not satisfy the supplied predicate,
--   rotating to the right if the focus does not satisfy the predicate.
filterR :: (a -> Bool) -> CList a -> CList a

-- | As with <a>filterR</a>, but rotates to the <i>left</i> if the focus
--   does not satisfy the predicate.
filterL :: (a -> Bool) -> CList a -> CList a

-- | A right-fold, rotating to the right through the CList.
foldrR :: (a -> b -> b) -> b -> CList a -> b

-- | A right-fold, rotating to the left through the CList.
foldrL :: (a -> b -> b) -> b -> CList a -> b

-- | A (strict) left-fold, rotating to the right through the CList.
foldlR :: (a -> b -> a) -> a -> CList b -> a

-- | A (strict) left-fold, rotating to the left through the CList.
foldlL :: (a -> b -> a) -> a -> CList b -> a

-- | Balance the CList. Equivalent to `fromList . toList`
balance :: CList a -> CList a

-- | Move all elements to the left side of the CList.
packL :: CList a -> CList a

-- | Move all elements to the right side of the CList.
packR :: CList a -> CList a

-- | Returns true if the CList is empty.
isEmpty :: CList a -> Bool

-- | Return the size of the CList.
size :: CList a -> Int
instance GHC.Show.Show a => GHC.Show.Show (Data.CircularList.CList a)
instance GHC.Read.Read a => GHC.Read.Read (Data.CircularList.CList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.CircularList.CList a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.CircularList.CList a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.CircularList.CList a)
instance GHC.Base.Functor Data.CircularList.CList
instance Data.Foldable.Foldable Data.CircularList.CList
instance Data.Traversable.Traversable Data.CircularList.CList
