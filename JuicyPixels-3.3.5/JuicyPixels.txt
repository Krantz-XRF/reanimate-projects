-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)
--   
--   
--   This library can load and store images in PNG,Bitmap, Jpeg, Radiance,
--   Tiff and Gif images.
@package JuicyPixels
@version 3.3.5


-- | This module provide a totally partial and incomplete maping of Exif
--   values. Used for Tiff parsing and reused for Exif extraction.
module Codec.Picture.Metadata.Exif

-- | Tag values used for exif fields. Completly incomplete
data ExifTag
TagPhotometricInterpretation :: ExifTag

-- | Short type
TagCompression :: ExifTag

-- | Short or long type
TagImageWidth :: ExifTag

-- | Short or long type
TagImageLength :: ExifTag

-- | Rational type
TagXResolution :: ExifTag

-- | Rational type
TagYResolution :: ExifTag
TagResolutionUnit :: ExifTag

-- | Short or long type
TagRowPerStrip :: ExifTag

-- | Short or long
TagStripByteCounts :: ExifTag

-- | Short or long
TagStripOffsets :: ExifTag
TagBitsPerSample :: ExifTag

-- | Short
TagColorMap :: ExifTag
TagTileWidth :: ExifTag
TagTileLength :: ExifTag
TagTileOffset :: ExifTag
TagTileByteCount :: ExifTag

-- | Short
TagSamplesPerPixel :: ExifTag
TagArtist :: ExifTag
TagDocumentName :: ExifTag
TagSoftware :: ExifTag

-- | Short
TagPlanarConfiguration :: ExifTag
TagOrientation :: ExifTag

-- | Short
TagSampleFormat :: ExifTag
TagInkSet :: ExifTag
TagSubfileType :: ExifTag
TagFillOrder :: ExifTag
TagYCbCrCoeff :: ExifTag
TagYCbCrSubsampling :: ExifTag
TagYCbCrPositioning :: ExifTag
TagReferenceBlackWhite :: ExifTag
TagXPosition :: ExifTag
TagYPosition :: ExifTag
TagExtraSample :: ExifTag
TagImageDescription :: ExifTag
TagPredictor :: ExifTag
TagCopyright :: ExifTag
TagMake :: ExifTag
TagModel :: ExifTag
TagDateTime :: ExifTag
TagGPSInfo :: ExifTag

-- | Short
TagLightSource :: ExifTag

-- | Short
TagFlash :: ExifTag
TagJpegProc :: ExifTag
TagJPEGInterchangeFormat :: ExifTag
TagJPEGInterchangeFormatLength :: ExifTag
TagJPEGRestartInterval :: ExifTag
TagJPEGLosslessPredictors :: ExifTag
TagJPEGPointTransforms :: ExifTag
TagJPEGQTables :: ExifTag
TagJPEGDCTables :: ExifTag
TagJPEGACTables :: ExifTag
TagExifOffset :: ExifTag
TagUnknown :: !Word16 -> ExifTag

-- | Possible data held by an Exif tag
data ExifData
ExifNone :: ExifData
ExifLong :: !Word32 -> ExifData
ExifShort :: !Word16 -> ExifData
ExifString :: !ByteString -> ExifData
ExifUndefined :: !ByteString -> ExifData
ExifShorts :: !Vector Word16 -> ExifData
ExifLongs :: !Vector Word32 -> ExifData
ExifRational :: !Word32 -> !Word32 -> ExifData
ExifSignedRational :: !Int32 -> !Int32 -> ExifData
ExifIFD :: ![(ExifTag, ExifData)] -> ExifData

-- | Convert a value to it's corresponding Exif tag. Will often be written
--   as <a>TagUnknown</a>
tagOfWord16 :: Word16 -> ExifTag

-- | Convert a tag to it's corresponding value.
word16OfTag :: ExifTag -> Word16
isInIFD0 :: ExifTag -> Bool
instance GHC.Show.Show Codec.Picture.Metadata.Exif.ExifTag
instance GHC.Classes.Ord Codec.Picture.Metadata.Exif.ExifTag
instance GHC.Classes.Eq Codec.Picture.Metadata.Exif.ExifTag
instance GHC.Show.Show Codec.Picture.Metadata.Exif.ExifData
instance Control.DeepSeq.NFData Codec.Picture.Metadata.Exif.ExifData
instance Control.DeepSeq.NFData Codec.Picture.Metadata.Exif.ExifTag


-- | This module expose a common "metadata" storage for various image type.
--   Different format can generate different metadatas, and write only a
--   part of them.
--   
--   Since version 3.2.5
module Codec.Picture.Metadata

-- | Dependent storage used for metadatas. All metadatas of a given kind
--   are unique within this container.
--   
--   The current data structure is based on list, so bad performances can
--   be expected.
data Metadatas

-- | Store various additional information about an image. If something is
--   not recognized, it can be stored in an unknown tag.
--   
--   <ul>
--   <li><a>DpiX</a> Dot per inch on this x axis.</li>
--   <li><a>DpiY</a> Dot per inch on this y axis.</li>
--   <li><a>Width</a> Image width in pixel. Relying on the metadata for
--   this information can avoid the full decompression of the image.
--   Ignored for image writing.</li>
--   <li><a>Height</a> Image height in pixels. Relying on the metadata for
--   this information can void the full decompression of the image. Ignored
--   for image writing.</li>
--   <li><tt>ColorProfile</tt> An unparsed ICC color profile. Currently
--   only supported by the Bitmap format.</li>
--   <li><a>Unknown</a> unlikely to be decoded, but usefull for metadata
--   writing</li>
--   <li><a>Exif</a> Exif tag and associated data.</li>
--   </ul>
data Keys a
[Gamma] :: Keys Double
[ColorSpace] :: Keys ColorSpace
[Format] :: Keys SourceFormat
[DpiX] :: Keys Word
[DpiY] :: Keys Word
[Width] :: Keys Word
[Height] :: Keys Word
[Title] :: Keys String
[Description] :: Keys String
[Author] :: Keys String
[Copyright] :: Keys String
[Software] :: Keys String
[Comment] :: Keys String
[Disclaimer] :: Keys String
[Source] :: Keys String
[Warning] :: Keys String
[Exif] :: !ExifTag -> Keys ExifData
[Unknown] :: !String -> Keys Value

-- | Encode values for unknown information
data Value
Int :: !Int -> Value
Double :: !Double -> Value
String :: !String -> Value

-- | Element describing a metadata and it's (typed) associated value.
data Elem k
(:=>) :: !k a -> a -> Elem k

-- | Type describing the original file format of the file.
data SourceFormat
SourceJpeg :: SourceFormat
SourceGif :: SourceFormat
SourceBitmap :: SourceFormat
SourceTiff :: SourceFormat
SourcePng :: SourceFormat
SourceHDR :: SourceFormat
SourceTGA :: SourceFormat

-- | The same color values may result in slightly different colors on
--   different devices. To get consistent colors accross multiple devices
--   we need a way of mapping color values from a source device into their
--   equivalents on the target device.
--   
--   The solution is essentially to define, for each device, a family of
--   mappings that convert between device colors and standard CIEXYZ or
--   CIELAB colors. The collection of mappings for a device is known as the
--   'color-profile' of that device, and each color-profile can be thought
--   of as describing a 'color-space'.
--   
--   If we know the color-space of the input pixels, and the color space of
--   the output device, then we can convert the colors in the image to
--   their equivalents on the output device.
--   
--   JuicyPixels does not parse color-profiles or attempt to perform color
--   correction.
--   
--   The following color space types are recognised:
--   
--   <ul>
--   <li>sRGB: Standard RGB color space.</li>
--   <li>Windows BMP color space: Color space information embedded within a
--   V4 Windows BMP file.</li>
--   <li>ICC profile: An ICC color profile.</li>
--   </ul>
data ColorSpace
SRGB :: ColorSpace
WindowsBitmapColorSpace :: !ByteString -> ColorSpace
ICCProfile :: !ByteString -> ColorSpace

-- | Search a metadata with the given key.
lookup :: Keys a -> Metadatas -> Maybe a

-- | Empty metadatas. Favor <a>mempty</a>
empty :: Metadatas

-- | Insert an element in the metadatas, if an element with the same key is
--   present, it is overwritten.
insert :: (Show a, NFData a) => Keys a -> a -> Metadatas -> Metadatas

-- | Remove an element of the given keys from the metadatas. If not present
--   does nothing.
delete :: Keys a -> Metadatas -> Metadatas

-- | Create metadatas with a single element.
singleton :: (Show a, NFData a) => Keys a -> a -> Metadatas

-- | Strict left fold of the metadatas
foldl' :: (acc -> Elem Keys -> acc) -> acc -> Metadatas -> acc

-- | foldMap equivalent for metadatas.
foldMap :: Monoid m => (Elem Keys -> m) -> Metadatas -> m

-- | Create metadatas indicating the resolution, with DpiX == DpiY
mkDpiMetadata :: Word -> Metadatas

-- | Create metadatas holding width and height information.
mkSizeMetadata :: Integral n => n -> n -> Metadatas

-- | Create simple metadatas with Format, Width &amp; Height
basicMetadata :: Integral nSize => SourceFormat -> nSize -> nSize -> Metadatas

-- | Create simple metadatas with Format, Width, Height, DpiX &amp; DpiY
simpleMetadata :: (Integral nSize, Integral nDpi) => SourceFormat -> nSize -> nSize -> nDpi -> nDpi -> Metadatas

-- | Extract all Exif specific metadatas
extractExifMetas :: Metadatas -> [(ExifTag, ExifData)]

-- | Conversion from dpm to dpi
dotsPerMeterToDotPerInch :: Word -> Word

-- | Conversion from dpi to dpm
dotPerInchToDotsPerMeter :: Word -> Word

-- | Conversion dpcm -&gt; dpi
dotsPerCentiMeterToDotPerInch :: Word -> Word
instance GHC.Show.Show Codec.Picture.Metadata.SourceFormat
instance GHC.Classes.Eq Codec.Picture.Metadata.SourceFormat
instance GHC.Show.Show Codec.Picture.Metadata.ColorSpace
instance GHC.Classes.Eq Codec.Picture.Metadata.ColorSpace
instance GHC.Show.Show Codec.Picture.Metadata.Value
instance GHC.Classes.Eq Codec.Picture.Metadata.Value
instance Control.DeepSeq.NFData Codec.Picture.Metadata.Metadatas
instance GHC.Show.Show Codec.Picture.Metadata.Metadatas
instance GHC.Show.Show (Codec.Picture.Metadata.Keys a)
instance GHC.Classes.Eq (Codec.Picture.Metadata.Keys a)
instance GHC.Show.Show (Codec.Picture.Metadata.Elem Codec.Picture.Metadata.Keys)
instance GHC.Base.Monoid Codec.Picture.Metadata.Metadatas
instance GHC.Base.Semigroup Codec.Picture.Metadata.Metadatas
instance Control.DeepSeq.NFData (Codec.Picture.Metadata.Elem Codec.Picture.Metadata.Keys)
instance Control.DeepSeq.NFData Codec.Picture.Metadata.Value
instance Control.DeepSeq.NFData Codec.Picture.Metadata.ColorSpace
instance Control.DeepSeq.NFData Codec.Picture.Metadata.SourceFormat

module Codec.Picture.Tiff.Internal.Types

-- | Because having a polymorphic get with endianness is to nice to pass
--   on, introducing this helper type class, which is just a superset of
--   Binary, but formalising a parameter passing into it.
class BinaryParam a b
getP :: BinaryParam a b => a -> Get b
putP :: BinaryParam a b => a -> b -> Put
data Endianness
EndianLittle :: Endianness
EndianBig :: Endianness
data TiffHeader
TiffHeader :: !Endianness -> {-# UNPACK #-} !Word32 -> TiffHeader
[hdrEndianness] :: TiffHeader -> !Endianness
[hdrOffset] :: TiffHeader -> {-# UNPACK #-} !Word32
data TiffPlanarConfiguration
PlanarConfigContig :: TiffPlanarConfiguration
PlanarConfigSeparate :: TiffPlanarConfiguration
data TiffCompression
CompressionNone :: TiffCompression
CompressionModifiedRLE :: TiffCompression
CompressionLZW :: TiffCompression
CompressionJPEG :: TiffCompression
CompressionPackBit :: TiffCompression
data IfdType
TypeByte :: IfdType
TypeAscii :: IfdType
TypeShort :: IfdType
TypeLong :: IfdType
TypeRational :: IfdType
TypeSByte :: IfdType
TypeUndefined :: IfdType
TypeSignedShort :: IfdType
TypeSignedLong :: IfdType
TypeSignedRational :: IfdType
TypeFloat :: IfdType
TypeDouble :: IfdType
data TiffColorspace

-- | 0
TiffMonochromeWhite0 :: TiffColorspace

-- | 1
TiffMonochrome :: TiffColorspace

-- | 2
TiffRGB :: TiffColorspace

-- | 3
TiffPaleted :: TiffColorspace

-- | 4
TiffTransparencyMask :: TiffColorspace

-- | 5
TiffCMYK :: TiffColorspace

-- | 6
TiffYCbCr :: TiffColorspace

-- | 8
TiffCIELab :: TiffColorspace
data TiffSampleFormat
TiffSampleUint :: TiffSampleFormat
TiffSampleInt :: TiffSampleFormat
TiffSampleFloat :: TiffSampleFormat
TiffSampleUnknown :: TiffSampleFormat
data ImageFileDirectory
ImageFileDirectory :: !ExifTag -> !IfdType -> !Word32 -> !Word32 -> !ExifData -> ImageFileDirectory
[ifdIdentifier] :: ImageFileDirectory -> !ExifTag
[ifdType] :: ImageFileDirectory -> !IfdType
[ifdCount] :: ImageFileDirectory -> !Word32
[ifdOffset] :: ImageFileDirectory -> !Word32
[ifdExtended] :: ImageFileDirectory -> !ExifData
data ExtraSample

-- | 0
ExtraSampleUnspecified :: ExtraSample

-- | 1
ExtraSampleAssociatedAlpha :: ExtraSample

-- | 2
ExtraSampleUnassociatedAlpha :: ExtraSample
data Predictor
PredictorNone :: Predictor
PredictorHorizontalDifferencing :: Predictor
planarConfgOfConstant :: Word32 -> Get TiffPlanarConfiguration
constantToPlaneConfiguration :: TiffPlanarConfiguration -> Word16
unpackSampleFormat :: Word32 -> Get TiffSampleFormat
packSampleFormat :: TiffSampleFormat -> Word32

-- | Convert a tag to it's corresponding value.
word16OfTag :: ExifTag -> Word16
unpackPhotometricInterpretation :: Word32 -> Get TiffColorspace
packPhotometricInterpretation :: TiffColorspace -> Word16
codeOfExtraSample :: ExtraSample -> Word16
unPackCompression :: Word32 -> Get TiffCompression
packCompression :: TiffCompression -> Word16
predictorOfConstant :: Word32 -> Get Predictor
instance GHC.Show.Show Codec.Picture.Tiff.Internal.Types.Endianness
instance GHC.Classes.Eq Codec.Picture.Tiff.Internal.Types.Endianness
instance GHC.Show.Show Codec.Picture.Tiff.Internal.Types.TiffHeader
instance GHC.Classes.Eq Codec.Picture.Tiff.Internal.Types.TiffHeader
instance GHC.Show.Show Codec.Picture.Tiff.Internal.Types.IfdType
instance GHC.Classes.Eq Codec.Picture.Tiff.Internal.Types.Predictor
instance GHC.Classes.Eq Codec.Picture.Tiff.Internal.Types.TiffSampleFormat
instance GHC.Show.Show Codec.Picture.Tiff.Internal.Types.ImageFileDirectory
instance Codec.Picture.Tiff.Internal.Types.BinaryParam (Codec.Picture.Tiff.Internal.Types.Endianness, GHC.Types.Int, Codec.Picture.Tiff.Internal.Types.ImageFileDirectory) Codec.Picture.Metadata.Exif.ExifData
instance Codec.Picture.Tiff.Internal.Types.BinaryParam Data.ByteString.Internal.ByteString (Codec.Picture.Tiff.Internal.Types.TiffHeader, [[Codec.Picture.Tiff.Internal.Types.ImageFileDirectory]])
instance Codec.Picture.Tiff.Internal.Types.BinaryParam Codec.Picture.Tiff.Internal.Types.Endianness Codec.Picture.Tiff.Internal.Types.ImageFileDirectory
instance Codec.Picture.Tiff.Internal.Types.BinaryParam Codec.Picture.Tiff.Internal.Types.Endianness [Codec.Picture.Tiff.Internal.Types.ImageFileDirectory]
instance Codec.Picture.Tiff.Internal.Types.BinaryParam Codec.Picture.Tiff.Internal.Types.Endianness Codec.Picture.Tiff.Internal.Types.IfdType
instance Data.Binary.Class.Binary Codec.Picture.Tiff.Internal.Types.TiffHeader
instance Codec.Picture.Tiff.Internal.Types.BinaryParam Codec.Picture.Tiff.Internal.Types.Endianness GHC.Word.Word16
instance Codec.Picture.Tiff.Internal.Types.BinaryParam Codec.Picture.Tiff.Internal.Types.Endianness GHC.Int.Int32
instance Codec.Picture.Tiff.Internal.Types.BinaryParam Codec.Picture.Tiff.Internal.Types.Endianness GHC.Word.Word32
instance Codec.Picture.Tiff.Internal.Types.BinaryParam Codec.Picture.Tiff.Internal.Types.Endianness Codec.Picture.Metadata.Exif.ExifTag
instance Data.Binary.Class.Binary Codec.Picture.Tiff.Internal.Types.Endianness

module Codec.Picture.Tiff.Internal.Metadata
extractTiffMetadata :: [ImageFileDirectory] -> Metadatas
encodeTiffStringMetadata :: Metadatas -> [ImageFileDirectory]
exifOffsetIfd :: ImageFileDirectory


-- | Module provides basic types for image manipulation in the library.
module Codec.Picture.Types

-- | The main type of this package, one that most functions work on, is
--   Image.
--   
--   Parameterized by the underlying pixel format it forms a rigid type. If
--   you wish to store images of different or unknown pixel formats use
--   <a>DynamicImage</a>.
--   
--   Image is essentially a rectangular pixel buffer of specified width and
--   height. The coordinates are assumed to start from the upper-left
--   corner of the image, with the horizontal position first and vertical
--   second.
data Image a
Image :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Vector (PixelBaseComponent a) -> Image a

-- | Width of the image in pixels
[imageWidth] :: Image a -> {-# UNPACK #-} !Int

-- | Height of the image in pixels.
[imageHeight] :: Image a -> {-# UNPACK #-} !Int

-- | Image pixel data. To extract pixels at a given position you should use
--   the helper functions.
--   
--   Internally pixel data is stored as consecutively packed lines from top
--   to bottom, scanned from left to right within individual lines, from
--   first to last color component within each pixel.
[imageData] :: Image a -> Vector (PixelBaseComponent a)

-- | Image or pixel buffer, the coordinates are assumed to start from the
--   upper-left corner of the image, with the horizontal position first,
--   then the vertical one. The image can be transformed in place.
data MutableImage s a
MutableImage :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> STVector s (PixelBaseComponent a) -> MutableImage s a

-- | Width of the image in pixels
[mutableImageWidth] :: MutableImage s a -> {-# UNPACK #-} !Int

-- | Height of the image in pixels.
[mutableImageHeight] :: MutableImage s a -> {-# UNPACK #-} !Int

-- | The real image, to extract pixels at some position you should use the
--   helpers functions.
[mutableImageData] :: MutableImage s a -> STVector s (PixelBaseComponent a)

-- | Image type enumerating all predefined pixel types. It enables loading
--   and use of images of different pixel types.
data DynamicImage

-- | A greyscale image.
ImageY8 :: Image Pixel8 -> DynamicImage

-- | A greyscale image with 16bit components
ImageY16 :: Image Pixel16 -> DynamicImage

-- | A greyscale image with 32bit components
ImageY32 :: Image Pixel32 -> DynamicImage

-- | A greyscale HDR image
ImageYF :: Image PixelF -> DynamicImage

-- | An image in greyscale with an alpha channel.
ImageYA8 :: Image PixelYA8 -> DynamicImage

-- | An image in greyscale with alpha channel on 16 bits.
ImageYA16 :: Image PixelYA16 -> DynamicImage

-- | An image in true color.
ImageRGB8 :: Image PixelRGB8 -> DynamicImage

-- | An image in true color with 16bit depth.
ImageRGB16 :: Image PixelRGB16 -> DynamicImage

-- | An image with HDR pixels
ImageRGBF :: Image PixelRGBF -> DynamicImage

-- | An image in true color and an alpha channel.
ImageRGBA8 :: Image PixelRGBA8 -> DynamicImage

-- | A true color image with alpha on 16 bits.
ImageRGBA16 :: Image PixelRGBA16 -> DynamicImage

-- | An image in the colorspace used by Jpeg images.
ImageYCbCr8 :: Image PixelYCbCr8 -> DynamicImage

-- | An image in the colorspace CMYK
ImageCMYK8 :: Image PixelCMYK8 -> DynamicImage

-- | An image in the colorspace CMYK and 16 bits precision
ImageCMYK16 :: Image PixelCMYK16 -> DynamicImage

-- | Describe an image and it's potential associated palette. If no palette
--   is present, fallback to a DynamicImage
data PalettedImage

-- | Fallback
TrueColorImage :: DynamicImage -> PalettedImage
PalettedY8 :: Image Pixel8 -> Palette' Pixel8 -> PalettedImage
PalettedRGB8 :: Image Pixel8 -> Palette' PixelRGB8 -> PalettedImage
PalettedRGBA8 :: Image Pixel8 -> Palette' PixelRGBA8 -> PalettedImage
PalettedRGB16 :: Image Pixel8 -> Palette' PixelRGB16 -> PalettedImage

-- | Type for the palette used in Gif &amp; PNG files.
type Palette = Image PixelRGB8

-- | Type used to expose a palette extracted during reading. Use
--   <a>palettedAsImage</a> to convert it to a palette usable for writing.
data Palette' px
Palette' :: !Int -> !Vector (PixelBaseComponent px) -> Palette' px

-- | Number of element in pixels.
[_paletteSize] :: Palette' px -> !Int

-- | Real data used by the palette.
[_paletteData] :: Palette' px -> !Vector (PixelBaseComponent px)

-- | Create a mutable image, filled with the given background color.
createMutableImage :: (Pixel px, PrimMonad m) => Int -> Int -> px -> m (MutableImage (PrimState m) px)

-- | Create a mutable image with garbage as content. All data is
--   uninitialized.
newMutableImage :: forall px m. (Pixel px, PrimMonad m) => Int -> Int -> m (MutableImage (PrimState m) px)

-- | `O(n)` Yield an immutable copy of an image by making a copy of it
freezeImage :: (Storable (PixelBaseComponent px), PrimMonad m) => MutableImage (PrimState m) px -> m (Image px)

-- | `O(1)` Unsafe convert a mutable image to an immutable one without
--   copying. The mutable image may not be used after this operation.
unsafeFreezeImage :: (Storable (PixelBaseComponent a), PrimMonad m) => MutableImage (PrimState m) a -> m (Image a)

-- | `O(n)` Yield a mutable copy of an image by making a copy of it.
thawImage :: (Storable (PixelBaseComponent px), PrimMonad m) => Image px -> m (MutableImage (PrimState m) px)

-- | `O(1)` Unsafe convert an imutable image to an mutable one without
--   copying. The source image shouldn't be used after this operation.
unsafeThawImage :: (Storable (PixelBaseComponent px), PrimMonad m) => Image px -> m (MutableImage (PrimState m) px)

-- | Traversal type matching the definition in the Lens package.
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | Traversal in "raster" order, from left to right the top to bottom.
--   This traversal is matching pixelMap in spirit.
--   
--   Since 3.2.4
imagePixels :: forall pxa pxb. (Pixel pxa, Pixel pxb) => Traversal (Image pxa) (Image pxb) pxa pxb

-- | Traversal providing the pixel position with it's value. The traversal
--   in raster order, from lef to right, then top to bottom. The traversal
--   match pixelMapXY in spirit.
--   
--   Since 3.2.4
imageIPixels :: forall pxa pxb. (Pixel pxa, Pixel pxb) => Traversal (Image pxa) (Image pxb) (Int, Int, pxa) pxb

-- | Type alias for 8bit greyscale pixels. For simplicity, greyscale pixels
--   use plain numbers instead of a separate type.
type Pixel8 = Word8

-- | Type alias for 16bit greyscale pixels.
type Pixel16 = Word16

-- | Type alias for 32bit greyscale pixels.
type Pixel32 = Word32

-- | Type alias for 32bit floating point greyscale pixels. The standard
--   bounded value range is mapped to the closed interval [0,1] i.e.
--   
--   <pre>
--   map promotePixel [0, 1 .. 255 :: Pixel8] == [0/255, 1/255 .. 1.0 :: PixelF]
--   </pre>
type PixelF = Float

-- | Pixel type storing 8bit Luminance (Y) and alpha (A) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Luminance</li>
--   <li>Alpha</li>
--   </ul>
data PixelYA8
PixelYA8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelYA8

-- | Pixel type storing 16bit Luminance (Y) and alpha (A) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Luminance</li>
--   <li>Alpha</li>
--   </ul>
data PixelYA16
PixelYA16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelYA16

-- | Classic pixel type storing 8bit red, green and blue (RGB) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGB8
PixelRGB8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelRGB8

-- | Pixel type storing 16bit red, green and blue (RGB) information. Values
--   are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGB16
PixelRGB16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelRGB16

-- | HDR pixel type storing floating point 32bit red, green and blue (RGB)
--   information. Same value range and comments apply as for <a>PixelF</a>.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGBF
PixelRGBF :: {-# UNPACK #-} !PixelF -> {-# UNPACK #-} !PixelF -> {-# UNPACK #-} !PixelF -> PixelRGBF

-- | Classical pixel type storing 8bit red, green, blue and alpha (RGBA)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   <li>Alpha</li>
--   </ul>
data PixelRGBA8
PixelRGBA8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelRGBA8

-- | Pixel type storing 16bit red, green, blue and alpha (RGBA)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   <li>Alpha</li>
--   </ul>
data PixelRGBA16
PixelRGBA16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelRGBA16

-- | Pixel type storing 8bit cyan, magenta, yellow and black (CMYK)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Cyan</li>
--   <li>Magenta</li>
--   <li>Yellow</li>
--   <li>Black</li>
--   </ul>
data PixelCMYK8
PixelCMYK8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelCMYK8

-- | Pixel type storing 16bit cyan, magenta, yellow and black (CMYK)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Cyan</li>
--   <li>Magenta</li>
--   <li>Yellow</li>
--   <li>Black</li>
--   </ul>
data PixelCMYK16
PixelCMYK16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelCMYK16

-- | Pixel type storing 8bit luminance, blue difference and red difference
--   (YCbCr) information. Values are stored in the following order:
--   
--   <ul>
--   <li>Y (luminance)</li>
--   <li>Cb</li>
--   <li>Cr</li>
--   </ul>
data PixelYCbCr8
PixelYCbCr8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelYCbCr8

-- | Pixel type storing value for the YCCK color space:
--   
--   <ul>
--   <li>Y (Luminance)</li>
--   <li>Cb</li>
--   <li>Cr</li>
--   <li>Black</li>
--   </ul>
data PixelYCbCrK8
PixelYCbCrK8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelYCbCrK8

-- | Implement upcasting for pixel types. Minimal declaration of
--   <a>promotePixel</a>. It is strongly recommended to overload
--   promoteImage to keep performance acceptable
class (Pixel a, Pixel b) => ColorConvertible a b

-- | Convert a pixel type to another pixel type. This operation should
--   never lose any data.
promotePixel :: ColorConvertible a b => a -> b

-- | Change the underlying pixel type of an image by performing a full copy
--   of it.
promoteImage :: ColorConvertible a b => Image a -> Image b

-- | Definition of pixels used in images. Each pixel has a color space, and
--   a representative component (Word8 or Float).
class (Storable (PixelBaseComponent a), Num (PixelBaseComponent a), Eq a) => Pixel a where {
    
    -- | Type of the pixel component, "classical" images would have Word8 type
    --   as their PixelBaseComponent, HDR image would have Float for instance
    type family PixelBaseComponent a :: *;
}

-- | Call the function for every component of the pixels. For example for
--   RGB pixels mixWith is declared like this:
--   
--   <pre>
--   mixWith f (PixelRGB8 ra ga ba) (PixelRGB8 rb gb bb) =
--      PixelRGB8 (f 0 ra rb) (f 1 ga gb) (f 2 ba bb)
--   </pre>
mixWith :: Pixel a => (Int -> PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> a -> a -> a

-- | Extension of the <a>mixWith</a> which separate the treatment of the
--   color components of the alpha value (transparency component). For
--   pixel without alpha components, it is equivalent to mixWith.
--   
--   <pre>
--   mixWithAlpha f fa (PixelRGBA8 ra ga ba aa) (PixelRGB8 rb gb bb ab) =
--      PixelRGBA8 (f 0 ra rb) (f 1 ga gb) (f 2 ba bb) (fa aa ab)
--   </pre>
mixWithAlpha :: Pixel a => (Int -> PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> (PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> a -> a -> a

-- | Return the opacity of a pixel, if the pixel has an alpha layer, return
--   the alpha value. If the pixel doesn't have an alpha value, return a
--   value representing the opaqueness.
pixelOpacity :: Pixel a => a -> PixelBaseComponent a

-- | Return the number of components of the pixel
componentCount :: Pixel a => a -> Int

-- | Apply a function to each component of a pixel. If the color type
--   possess an alpha (transparency channel), it is treated like the other
--   color components.
colorMap :: Pixel a => (PixelBaseComponent a -> PixelBaseComponent a) -> a -> a

-- | Calculate the index for the begining of the pixel
pixelBaseIndex :: Pixel a => Image a -> Int -> Int -> Int

-- | Calculate theindex for the begining of the pixel at position x y
mutablePixelBaseIndex :: Pixel a => MutableImage s a -> Int -> Int -> Int

-- | Extract a pixel at a given position, (x, y), the origin is assumed to
--   be at the corner top left, positive y to the bottom of the image
pixelAt :: Pixel a => Image a -> Int -> Int -> a

-- | Same as pixelAt but for mutable images.
readPixel :: (Pixel a, PrimMonad m) => MutableImage (PrimState m) a -> Int -> Int -> m a

-- | Write a pixel in a mutable image at position x y
writePixel :: (Pixel a, PrimMonad m) => MutableImage (PrimState m) a -> Int -> Int -> a -> m ()

-- | Unsafe version of pixelAt, read a pixel at the given index without
--   bound checking (if possible). The index is expressed in number
--   (PixelBaseComponent a)
unsafePixelAt :: Pixel a => Vector (PixelBaseComponent a) -> Int -> a

-- | Unsafe version of readPixel, read a pixel at the given position
--   without bound checking (if possible). The index is expressed in number
--   (PixelBaseComponent a)
unsafeReadPixel :: (Pixel a, PrimMonad m) => STVector (PrimState m) (PixelBaseComponent a) -> Int -> m a

-- | Unsafe version of writePixel, write a pixel at the given position
--   without bound checking. This can be _really_ unsafe. The index is
--   expressed in number (PixelBaseComponent a)
unsafeWritePixel :: (Pixel a, PrimMonad m) => STVector (PrimState m) (PixelBaseComponent a) -> Int -> a -> m ()

-- | This class abstract colorspace conversion. This conversion can be
--   lossy, which ColorConvertible cannot
class (Pixel a, Pixel b) => ColorSpaceConvertible a b

-- | Pass a pixel from a colorspace (say RGB) to the second one (say YCbCr)
convertPixel :: ColorSpaceConvertible a b => a -> b

-- | Helper function to convert a whole image by taking a copy it.
convertImage :: ColorSpaceConvertible a b => Image a -> Image b

-- | Helper class to help extract a luma plane out of an image or a pixel
class (Pixel a, Pixel (PixelBaseComponent a)) => LumaPlaneExtractable a

-- | Compute the luminance part of a pixel
computeLuma :: LumaPlaneExtractable a => a -> PixelBaseComponent a

-- | Extract a luma plane out of an image. This method is in the typeclass
--   to help performant implementation.
--   
--   <pre>
--   jpegToGrayScale :: FilePath -&gt; FilePath -&gt; IO ()
--   jpegToGrayScale source dest
--   </pre>
extractLumaPlane :: LumaPlaneExtractable a => Image a -> Image (PixelBaseComponent a)

-- | Class modeling transparent pixel, should provide a method to combine
--   transparent pixels
class (Pixel a, Pixel b) => TransparentPixel a b | a -> b

-- | Just return the opaque pixel value
dropTransparency :: TransparentPixel a b => a -> b

-- | access the transparency (alpha layer) of a given transparent pixel
--   type.

-- | <i>Deprecated: please use <a>pixelOpacity</a> instead</i>
getTransparency :: TransparentPixel a b => a -> PixelBaseComponent a

-- | <a>map</a> equivalent for an image, working at the pixel level. Little
--   example : a brightness function for an rgb image
--   
--   <pre>
--   brightnessRGB8 :: Int -&gt; Image PixelRGB8 -&gt; Image PixelRGB8
--   brightnessRGB8 add = pixelMap brightFunction
--        where up v = fromIntegral (fromIntegral v + add)
--              brightFunction (PixelRGB8 r g b) =
--                      PixelRGB8 (up r) (up g) (up b)
--   </pre>
pixelMap :: forall a b. (Pixel a, Pixel b) => (a -> b) -> Image a -> Image b

-- | Just like <a>pixelMap</a> only the function takes the pixel
--   coordinates as additional parameters.
pixelMapXY :: forall a b. (Pixel a, Pixel b) => (Int -> Int -> a -> b) -> Image a -> Image b

-- | Fold over the pixel of an image with a raster scan order: from top to
--   bottom, left to right
pixelFold :: forall acc pixel. Pixel pixel => (acc -> Int -> Int -> pixel -> acc) -> acc -> Image pixel -> acc

-- | Fold over the pixel of an image with a raster scan order: from top to
--   bottom, left to right, carrying out a state
pixelFoldM :: (Pixel pixel, Monad m) => (acc -> Int -> Int -> pixel -> m acc) -> acc -> Image pixel -> m acc

-- | Fold over the pixel of an image with a raster scan order: from top to
--   bottom, left to right. This functions is analog to the foldMap from
--   the <a>Foldable</a> typeclass, but due to the Pixel constraint, Image
--   cannot be made an instance of it.
pixelFoldMap :: forall m px. (Pixel px, Monoid m) => (px -> m) -> Image px -> m

-- | Helper function to help extract information from dynamic image. To get
--   the width of a dynamic image, you can use the following snippet:
--   
--   <pre>
--   dynWidth :: DynamicImage -&gt; Int
--   dynWidth img = dynamicMap imageWidth img
--   </pre>
dynamicMap :: (forall pixel. Pixel pixel => Image pixel -> a) -> DynamicImage -> a

-- | Equivalent of the <a>pixelMap</a> function for the dynamic images. You
--   can perform pixel colorspace independant operations with this
--   function.
--   
--   For instance, if you want to extract a square crop of any image,
--   without caring about colorspace, you can use the following snippet.
--   
--   <pre>
--   dynSquare :: DynamicImage -&gt; DynamicImage
--   dynSquare = dynamicPixelMap squareImage
--   
--   squareImage :: Pixel a =&gt; Image a -&gt; Image a
--   squareImage img = generateImage (\x y -&gt; pixelAt img x y) edge edge
--      where edge = min (imageWidth img) (imageHeight img)
--   </pre>
dynamicPixelMap :: (forall pixel. Pixel pixel => Image pixel -> Image pixel) -> DynamicImage -> DynamicImage

-- | Flatten a PalettedImage to a DynamicImage
palettedToTrueColor :: PalettedImage -> DynamicImage

-- | Convert a palette to an image. Used mainly for backward compatibility.
palettedAsImage :: Palette' px -> Image px

-- | For any image with an alpha component (transparency), drop it,
--   returning a pure opaque image.
dropAlphaLayer :: TransparentPixel a b => Image a -> Image b

-- | Create an image using a monadic initializer function. The function
--   will receive values from 0 to width-1 for the x parameter and 0 to
--   height-1 for the y parameter. The coordinates 0,0 are the upper left
--   corner of the image, and (width-1, height-1) the lower right corner.
--   
--   The function is called for each pixel in the line from left to right
--   (0 to width - 1) and for each line (0 to height - 1).
withImage :: forall m pixel. (Pixel pixel, PrimMonad m) => Int -> Int -> (Int -> Int -> m pixel) -> m (Image pixel)

-- | Combine, pixel by pixel and component by component the values of 3
--   different images. Usage example:
--   
--   <pre>
--   averageBrightNess c1 c2 c3 = clamp $ toInt c1 + toInt c2 + toInt c3
--     where clamp = fromIntegral . min 0 . max 255
--           toInt :: a -&gt; Int
--           toInt = fromIntegral
--   ziPixelComponent3 averageBrightNess img1 img2 img3
--   </pre>
zipPixelComponent3 :: forall px. Storable (PixelBaseComponent px) => (PixelBaseComponent px -> PixelBaseComponent px -> PixelBaseComponent px -> PixelBaseComponent px) -> Image px -> Image px -> Image px -> Image px

-- | Create an image given a function to generate pixels. The function will
--   receive values from 0 to width-1 for the x parameter and 0 to height-1
--   for the y parameter. The coordinates 0,0 are the upper left corner of
--   the image, and (width-1, height-1) the lower right corner.
--   
--   for example, to create a small gradient image:
--   
--   <pre>
--   imageCreator :: String -&gt; IO ()
--   imageCreator path = writePng path $ generateImage pixelRenderer 250 300
--      where pixelRenderer x y = PixelRGB8 (fromIntegral x) (fromIntegral y) 128
--   </pre>
generateImage :: forall px. Pixel px => (Int -> Int -> px) -> Int -> Int -> Image px

-- | Create an image given a function to generate pixels. The function will
--   receive values from 0 to width-1 for the x parameter and 0 to height-1
--   for the y parameter. The coordinates 0,0 are the upper left corner of
--   the image, and (width-1, height-1) the lower right corner.
--   
--   the acc parameter is a user defined one.
--   
--   The function is called for each pixel in the line from left to right
--   (0 to width - 1) and for each line (0 to height - 1).
generateFoldImage :: forall a acc. Pixel a => (acc -> Int -> Int -> (acc, a)) -> acc -> Int -> Int -> (acc, Image a)

-- | Perform a gamma correction for an image with HDR pixels.
gammaCorrection :: PixelF -> Image PixelRGBF -> Image PixelRGBF

-- | Perform a tone mapping operation on an High dynamic range image.
toneMapping :: PixelF -> Image PixelRGBF -> Image PixelRGBF

-- | Class used to describle plane present in the pixel type. If a pixel
--   has a plane description associated, you can use the plane name to
--   extract planes independently.
class ColorPlane pixel planeToken

-- | Define the plane for the red color component
data PlaneRed
PlaneRed :: PlaneRed

-- | Define the plane for the green color component
data PlaneGreen
PlaneGreen :: PlaneGreen

-- | Define the plane for the blue color component
data PlaneBlue
PlaneBlue :: PlaneBlue

-- | Define the plane for the alpha (transparency) component
data PlaneAlpha
PlaneAlpha :: PlaneAlpha

-- | Define the plane for the luma component
data PlaneLuma
PlaneLuma :: PlaneLuma

-- | Define the plane for the Cr component
data PlaneCr
PlaneCr :: PlaneCr

-- | Define the plane for the Cb component
data PlaneCb
PlaneCb :: PlaneCb

-- | Define plane for the cyan component of the CMYK color space.
data PlaneCyan
PlaneCyan :: PlaneCyan

-- | Define plane for the magenta component of the CMYK color space.
data PlaneMagenta
PlaneMagenta :: PlaneMagenta

-- | Define plane for the yellow component of the CMYK color space.
data PlaneYellow
PlaneYellow :: PlaneYellow

-- | Define plane for the black component of the CMYK color space.
data PlaneBlack
PlaneBlack :: PlaneBlack

-- | Extract a color plane from an image given a present plane in the image
--   examples:
--   
--   <pre>
--   extractRedPlane :: Image PixelRGB8 -&gt; Image Pixel8
--   extractRedPlane = extractComponent PlaneRed
--   </pre>
extractComponent :: forall px plane. (Pixel px, Pixel (PixelBaseComponent px), PixelBaseComponent (PixelBaseComponent px) ~ PixelBaseComponent px, ColorPlane px plane) => plane -> Image px -> Image (PixelBaseComponent px)

-- | Extract a plane of an image. Returns the requested color component as
--   a greyscale image.
--   
--   If you ask for a component out of bound, the <a>error</a> function
--   will be called.
unsafeExtractComponent :: forall a. (Pixel a, Pixel (PixelBaseComponent a), PixelBaseComponent (PixelBaseComponent a) ~ PixelBaseComponent a) => Int -> Image a -> Image (PixelBaseComponent a)

-- | This typeclass exist for performance reason, it allow to pack a pixel
--   value to a simpler "primitive" data type to allow faster writing to
--   moemory.
class PackeablePixel a where {
    
    -- | Primitive type asociated to the current pixel It's Word32 for
    --   PixelRGBA8 for instance
    type family PackedRepresentation a;
}

-- | The packing function, allowing to transform to a primitive.
packPixel :: PackeablePixel a => a -> PackedRepresentation a

-- | Inverse transformation, to speed up reading
unpackPixel :: PackeablePixel a => PackedRepresentation a -> a

-- | This function will fill an image with a simple packeable pixel. It
--   will be faster than any unsafeWritePixel.
fillImageWith :: (Pixel px, PackeablePixel px, PrimMonad m, Storable (PackedRepresentation px)) => MutableImage (PrimState m) px -> px -> m ()

-- | Read a packeable pixel from an image. Equivalent to unsafeReadPixel
readPackedPixelAt :: forall m px. (Pixel px, PackeablePixel px, Storable (PackedRepresentation px), PrimMonad m) => MutableImage (PrimState m) px -> Int -> m px

-- | Write a packeable pixel into an image. equivalent to unsafeWritePixel.
writePackedPixelAt :: (Pixel px, PackeablePixel px, Storable (PackedRepresentation px), PrimMonad m) => MutableImage (PrimState m) px -> Int -> px -> m ()

-- | Fill a packeable pixel between two bounds.
unsafeWritePixelBetweenAt :: (PrimMonad m, Pixel px, PackeablePixel px, Storable (PackedRepresentation px)) => MutableImage (PrimState m) px -> px -> Int -> Int -> m ()
instance GHC.Show.Show Codec.Picture.Types.PixelYA8
instance GHC.Classes.Ord Codec.Picture.Types.PixelYA8
instance GHC.Classes.Eq Codec.Picture.Types.PixelYA8
instance GHC.Show.Show Codec.Picture.Types.PixelYA16
instance GHC.Classes.Ord Codec.Picture.Types.PixelYA16
instance GHC.Classes.Eq Codec.Picture.Types.PixelYA16
instance GHC.Show.Show Codec.Picture.Types.PixelRGB8
instance GHC.Classes.Ord Codec.Picture.Types.PixelRGB8
instance GHC.Classes.Eq Codec.Picture.Types.PixelRGB8
instance GHC.Show.Show Codec.Picture.Types.PixelYCbCrK8
instance GHC.Classes.Ord Codec.Picture.Types.PixelYCbCrK8
instance GHC.Classes.Eq Codec.Picture.Types.PixelYCbCrK8
instance GHC.Show.Show Codec.Picture.Types.PixelRGB16
instance GHC.Classes.Ord Codec.Picture.Types.PixelRGB16
instance GHC.Classes.Eq Codec.Picture.Types.PixelRGB16
instance GHC.Show.Show Codec.Picture.Types.PixelRGBF
instance GHC.Classes.Ord Codec.Picture.Types.PixelRGBF
instance GHC.Classes.Eq Codec.Picture.Types.PixelRGBF
instance GHC.Show.Show Codec.Picture.Types.PixelYCbCr8
instance GHC.Classes.Ord Codec.Picture.Types.PixelYCbCr8
instance GHC.Classes.Eq Codec.Picture.Types.PixelYCbCr8
instance GHC.Show.Show Codec.Picture.Types.PixelCMYK8
instance GHC.Classes.Ord Codec.Picture.Types.PixelCMYK8
instance GHC.Classes.Eq Codec.Picture.Types.PixelCMYK8
instance GHC.Show.Show Codec.Picture.Types.PixelCMYK16
instance GHC.Classes.Ord Codec.Picture.Types.PixelCMYK16
instance GHC.Classes.Eq Codec.Picture.Types.PixelCMYK16
instance GHC.Show.Show Codec.Picture.Types.PixelRGBA8
instance GHC.Classes.Ord Codec.Picture.Types.PixelRGBA8
instance GHC.Classes.Eq Codec.Picture.Types.PixelRGBA8
instance GHC.Show.Show Codec.Picture.Types.PixelRGBA16
instance GHC.Classes.Ord Codec.Picture.Types.PixelRGBA16
instance GHC.Classes.Eq Codec.Picture.Types.PixelRGBA16
instance GHC.Classes.Eq Codec.Picture.Types.DynamicImage
instance Codec.Picture.Types.PackeablePixel Codec.Picture.Types.Pixel8
instance Codec.Picture.Types.PackeablePixel Codec.Picture.Types.Pixel16
instance Codec.Picture.Types.PackeablePixel Codec.Picture.Types.Pixel32
instance Codec.Picture.Types.PackeablePixel Codec.Picture.Types.PixelF
instance Codec.Picture.Types.PackeablePixel Codec.Picture.Types.PixelRGBA8
instance Codec.Picture.Types.PackeablePixel Codec.Picture.Types.PixelRGBA16
instance Codec.Picture.Types.PackeablePixel Codec.Picture.Types.PixelCMYK8
instance Codec.Picture.Types.PackeablePixel Codec.Picture.Types.PixelCMYK16
instance Codec.Picture.Types.PackeablePixel Codec.Picture.Types.PixelYA16
instance Codec.Picture.Types.PackeablePixel Codec.Picture.Types.PixelYA8
instance Codec.Picture.Types.LumaPlaneExtractable Codec.Picture.Types.Pixel8
instance Codec.Picture.Types.LumaPlaneExtractable Codec.Picture.Types.Pixel16
instance Codec.Picture.Types.LumaPlaneExtractable Codec.Picture.Types.Pixel32
instance Codec.Picture.Types.LumaPlaneExtractable Codec.Picture.Types.PixelF
instance Codec.Picture.Types.LumaPlaneExtractable Codec.Picture.Types.PixelRGBF
instance Codec.Picture.Types.LumaPlaneExtractable Codec.Picture.Types.PixelRGBA8
instance Codec.Picture.Types.LumaPlaneExtractable Codec.Picture.Types.PixelYCbCr8
instance Codec.Picture.Types.LumaPlaneExtractable Codec.Picture.Types.PixelYA8
instance Codec.Picture.Types.LumaPlaneExtractable Codec.Picture.Types.PixelRGB16
instance Codec.Picture.Types.LumaPlaneExtractable Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Types.ColorSpaceConvertible Codec.Picture.Types.PixelRGB16 Codec.Picture.Types.PixelCMYK16
instance Codec.Picture.Types.Pixel a => Codec.Picture.Types.ColorSpaceConvertible a a
instance Codec.Picture.Types.ColorSpaceConvertible Codec.Picture.Types.PixelRGB8 Codec.Picture.Types.PixelYCbCr8
instance Codec.Picture.Types.ColorSpaceConvertible Codec.Picture.Types.PixelYCbCr8 Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Types.ColorSpaceConvertible Codec.Picture.Types.PixelCMYK8 Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Types.ColorSpaceConvertible Codec.Picture.Types.PixelYCbCrK8 Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Types.ColorSpaceConvertible Codec.Picture.Types.PixelYCbCrK8 Codec.Picture.Types.PixelCMYK8
instance Codec.Picture.Types.ColorSpaceConvertible Codec.Picture.Types.PixelRGB8 Codec.Picture.Types.PixelCMYK8
instance Codec.Picture.Types.ColorSpaceConvertible Codec.Picture.Types.PixelCMYK16 Codec.Picture.Types.PixelRGB16
instance Codec.Picture.Types.Pixel a => Codec.Picture.Types.ColorConvertible a a
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.Pixel8 Codec.Picture.Types.PixelYA8
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.Pixel8 Codec.Picture.Types.PixelF
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.Pixel8 Codec.Picture.Types.Pixel16
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.Pixel8 Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.Pixel8 Codec.Picture.Types.PixelRGB16
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.Pixel8 Codec.Picture.Types.PixelRGBA8
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.Pixel16 Codec.Picture.Types.PixelYA16
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.Pixel16 Codec.Picture.Types.PixelRGB16
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.Pixel16 Codec.Picture.Types.PixelRGBA16
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelF Codec.Picture.Types.PixelRGBF
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelYA8 Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelYA8 Codec.Picture.Types.PixelRGB16
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelYA8 Codec.Picture.Types.PixelRGBA8
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelYA16 Codec.Picture.Types.PixelRGB16
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelYA16 Codec.Picture.Types.PixelRGBA16
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelRGB16 Codec.Picture.Types.PixelRGBA16
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelRGB8 Codec.Picture.Types.PixelRGBA8
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelRGB8 Codec.Picture.Types.PixelRGBF
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelRGB8 Codec.Picture.Types.PixelRGB16
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelRGB8 Codec.Picture.Types.PixelRGBA16
instance Codec.Picture.Types.ColorConvertible Codec.Picture.Types.PixelRGBA8 Codec.Picture.Types.PixelRGBA16
instance Control.DeepSeq.NFData Codec.Picture.Types.DynamicImage
instance Codec.Picture.Types.TransparentPixel Codec.Picture.Types.PixelRGBA8 Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Types.TransparentPixel Codec.Picture.Types.PixelYA8 Codec.Picture.Types.Pixel8
instance Codec.Picture.Types.TransparentPixel Codec.Picture.Types.PixelYA16 Codec.Picture.Types.Pixel16
instance Codec.Picture.Types.TransparentPixel Codec.Picture.Types.PixelRGBA16 Codec.Picture.Types.PixelRGB16
instance (GHC.Classes.Eq (Codec.Picture.Types.PixelBaseComponent a), Foreign.Storable.Storable (Codec.Picture.Types.PixelBaseComponent a)) => GHC.Classes.Eq (Codec.Picture.Types.Image a)
instance Control.DeepSeq.NFData (Codec.Picture.Types.Image a)
instance Control.DeepSeq.NFData (Codec.Picture.Types.MutableImage s a)
instance Codec.Picture.Types.Pixel Codec.Picture.Types.Pixel8
instance Codec.Picture.Types.Pixel Codec.Picture.Types.Pixel16
instance Codec.Picture.Types.Pixel Codec.Picture.Types.Pixel32
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelF
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelYA8
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelYA16
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelRGBF
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelRGB16
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelRGBA8
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelRGBA16
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelYCbCr8
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelCMYK8
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelYCbCrK8
instance Codec.Picture.Types.Pixel Codec.Picture.Types.PixelCMYK16
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGBA16 Codec.Picture.Types.PlaneRed
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGBA16 Codec.Picture.Types.PlaneGreen
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGBA16 Codec.Picture.Types.PlaneBlue
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGBA16 Codec.Picture.Types.PlaneAlpha
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGBA8 Codec.Picture.Types.PlaneRed
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGBA8 Codec.Picture.Types.PlaneGreen
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGBA8 Codec.Picture.Types.PlaneBlue
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGBA8 Codec.Picture.Types.PlaneAlpha
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelCMYK16 Codec.Picture.Types.PlaneCyan
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelCMYK16 Codec.Picture.Types.PlaneMagenta
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelCMYK16 Codec.Picture.Types.PlaneYellow
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelCMYK16 Codec.Picture.Types.PlaneBlack
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelCMYK8 Codec.Picture.Types.PlaneCyan
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelCMYK8 Codec.Picture.Types.PlaneMagenta
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelCMYK8 Codec.Picture.Types.PlaneYellow
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelCMYK8 Codec.Picture.Types.PlaneBlack
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelYCbCr8 Codec.Picture.Types.PlaneLuma
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelYCbCr8 Codec.Picture.Types.PlaneCb
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelYCbCr8 Codec.Picture.Types.PlaneCr
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGBF Codec.Picture.Types.PlaneRed
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGBF Codec.Picture.Types.PlaneGreen
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGBF Codec.Picture.Types.PlaneBlue
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGB16 Codec.Picture.Types.PlaneRed
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGB16 Codec.Picture.Types.PlaneGreen
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGB16 Codec.Picture.Types.PlaneBlue
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGB8 Codec.Picture.Types.PlaneRed
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGB8 Codec.Picture.Types.PlaneGreen
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelRGB8 Codec.Picture.Types.PlaneBlue
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelYA16 Codec.Picture.Types.PlaneLuma
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelYA16 Codec.Picture.Types.PlaneAlpha
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelYA8 Codec.Picture.Types.PlaneLuma
instance Codec.Picture.Types.ColorPlane Codec.Picture.Types.PixelYA8 Codec.Picture.Types.PlaneAlpha


-- | Low level png module, you should import <a>Internal</a> instead.
module Codec.Picture.Png.Internal.Type

-- | Generic header used in PNG images.
data PngIHdr
PngIHdr :: !Word32 -> !Word32 -> !Word8 -> !PngImageType -> !Word8 -> !Word8 -> !PngInterlaceMethod -> PngIHdr

-- | Image width in number of pixel
[width] :: PngIHdr -> !Word32

-- | Image height in number of pixel
[height] :: PngIHdr -> !Word32

-- | Number of bit per sample
[bitDepth] :: PngIHdr -> !Word8

-- | Kind of png image (greyscale, true color, indexed...)
[colourType] :: PngIHdr -> !PngImageType

-- | Compression method used
[compressionMethod] :: PngIHdr -> !Word8

-- | Must be 0
[filterMethod] :: PngIHdr -> !Word8

-- | If the image is interlaced (for progressive rendering)
[interlaceMethod] :: PngIHdr -> !PngInterlaceMethod

-- | The pixels value should be : +---+---+ | c | b | +---+---+ | a | x |
--   +---+---+ x being the current filtered pixel
data PngFilter

-- | Filt(x) = Orig(x), Recon(x) = Filt(x)
FilterNone :: PngFilter

-- | Filt(x) = Orig(x) - Orig(a), Recon(x) = Filt(x) + Recon(a)
FilterSub :: PngFilter

-- | Filt(x) = Orig(x) - Orig(b), Recon(x) = Filt(x) + Recon(b)
FilterUp :: PngFilter

-- | Filt(x) = Orig(x) - floor((Orig(a) + Orig(b)) / 2), Recon(x) = Filt(x)
--   + floor((Recon(a) + Recon(b)) / 2)
FilterAverage :: PngFilter

-- | Filt(x) = Orig(x) - PaethPredictor(Orig(a), Orig(b), Orig(c)),
--   Recon(x) = Filt(x) + PaethPredictor(Recon(a), Recon(b), Recon(c))
FilterPaeth :: PngFilter

-- | Different known interlace methods for PNG image
data PngInterlaceMethod

-- | No interlacing, basic data ordering, line by line from left to right.
PngNoInterlace :: PngInterlaceMethod

-- | Use the Adam7 ordering, see <tt>adam7Reordering</tt>
PngInterlaceAdam7 :: PngInterlaceMethod

-- | Palette with indices beginning at 0 to elemcount - 1
type PngPalette = Palette' PixelRGB8

-- | What kind of information is encoded in the IDAT section of the PngFile
data PngImageType
PngGreyscale :: PngImageType
PngTrueColour :: PngImageType
PngIndexedColor :: PngImageType
PngGreyscaleWithAlpha :: PngImageType
PngTrueColourWithAlpha :: PngImageType
data PngPhysicalDimension
PngPhysicalDimension :: !Word32 -> !Word32 -> !PngUnit -> PngPhysicalDimension
[pngDpiX] :: PngPhysicalDimension -> !Word32
[pngDpiY] :: PngPhysicalDimension -> !Word32
[pngUnit] :: PngPhysicalDimension -> !PngUnit
newtype PngGamma
PngGamma :: Double -> PngGamma
[getPngGamma] :: PngGamma -> Double
data PngUnit

-- | 0 value
PngUnitUnknown :: PngUnit

-- | 1 value
PngUnitMeter :: PngUnit
data APngAnimationControl
APngAnimationControl :: !Word32 -> !Word32 -> APngAnimationControl
[animationFrameCount] :: APngAnimationControl -> !Word32
[animationPlayCount] :: APngAnimationControl -> !Word32

-- | Encoded in a Word8
data APngFrameDisposal

-- | No disposal is done on this frame before rendering the next; the
--   contents of the output buffer are left as is. Has Value 0
APngDisposeNone :: APngFrameDisposal

-- | The frame's region of the output buffer is to be cleared to fully
--   transparent black before rendering the next frame. Has Value 1
APngDisposeBackground :: APngFrameDisposal

-- | the frame's region of the output buffer is to be reverted to the
--   previous contents before rendering the next frame. Has Value 2
APngDisposePrevious :: APngFrameDisposal

-- | Encoded in a Word8
data APngBlendOp

-- | Overwrite output buffer. has value '0'
APngBlendSource :: APngBlendOp

-- | Alpha blend to the output buffer. Has value '1'
APngBlendOver :: APngBlendOp
data APngFrameControl
APngFrameControl :: !Word32 -> !Word32 -> !Word32 -> !Word32 -> !Word32 -> !Word16 -> !Word16 -> !APngFrameDisposal -> !APngBlendOp -> APngFrameControl

-- | Starting from 0
[frameSequenceNum] :: APngFrameControl -> !Word32

-- | Width of the following frame
[frameWidth] :: APngFrameControl -> !Word32

-- | Height of the following frame
[frameHeight] :: APngFrameControl -> !Word32
[frameLeft] :: APngFrameControl -> !Word32
[frameTop] :: APngFrameControl -> !Word32
[frameDelayNumerator] :: APngFrameControl -> !Word16
[frameDelayDenuminator] :: APngFrameControl -> !Word16
[frameDisposal] :: APngFrameControl -> !APngFrameDisposal
[frameBlending] :: APngFrameControl -> !APngBlendOp

-- | Parse a palette from a png chunk.
parsePalette :: PngRawChunk -> Either String PngPalette

-- | Compute the CRC of a raw buffer, as described in annex D of the PNG
--   specification.
pngComputeCrc :: [ByteString] -> Word32

-- | Signature for a palette chunk in the pgn file. Must occure before
--   iDAT.
pLTESignature :: ChunkSignature

-- | Signature for a data chuck (with image parts in it)
iDATSignature :: ChunkSignature

-- | Signature for the last chunk of a png image, telling the end.
iENDSignature :: ChunkSignature
tRNSSignature :: ChunkSignature
tEXtSignature :: ChunkSignature
zTXtSignature :: ChunkSignature
gammaSignature :: ChunkSignature
pHYsSignature :: ChunkSignature
animationControlSignature :: ChunkSignature

-- | Value used to identify a png chunk, must be 4 bytes long.
type ChunkSignature = ByteString

-- | Raw parsed image which need to be decoded.
data PngRawImage
PngRawImage :: PngIHdr -> [PngRawChunk] -> PngRawImage
[header] :: PngRawImage -> PngIHdr
[chunks] :: PngRawImage -> [PngRawChunk]

-- | PNG chunk representing some extra information found in the parsed
--   file.
data PngChunk
PngChunk :: ByteString -> ChunkSignature -> PngChunk

-- | The raw data inside the chunk
[pngChunkData] :: PngChunk -> ByteString

-- | The name of the chunk.
[pngChunkSignature] :: PngChunk -> ChunkSignature

-- | Data structure during real png loading/parsing
data PngRawChunk
PngRawChunk :: Word32 -> ChunkSignature -> Word32 -> ByteString -> PngRawChunk
[chunkLength] :: PngRawChunk -> Word32
[chunkType] :: PngRawChunk -> ChunkSignature
[chunkCRC] :: PngRawChunk -> Word32
[chunkData] :: PngRawChunk -> ByteString

-- | Low level access to PNG information
data PngLowLevel a
PngLowLevel :: Image a -> [PngChunk] -> PngLowLevel a

-- | The real uncompressed image
[pngImage] :: PngLowLevel a -> Image a

-- | List of raw chunk where some user data might be present.
[pngChunks] :: PngLowLevel a -> [PngChunk]
chunksWithSig :: PngRawImage -> ChunkSignature -> [ByteString]
mkRawChunk :: ChunkSignature -> ByteString -> PngRawChunk
instance GHC.Show.Show Codec.Picture.Png.Internal.Type.APngAnimationControl
instance GHC.Show.Show Codec.Picture.Png.Internal.Type.APngFrameDisposal
instance GHC.Show.Show Codec.Picture.Png.Internal.Type.APngBlendOp
instance GHC.Show.Show Codec.Picture.Png.Internal.Type.APngFrameControl
instance GHC.Show.Show Codec.Picture.Png.Internal.Type.PngImageType
instance GHC.Show.Show Codec.Picture.Png.Internal.Type.PngFilter
instance GHC.Enum.Enum Codec.Picture.Png.Internal.Type.PngFilter
instance GHC.Show.Show Codec.Picture.Png.Internal.Type.PngInterlaceMethod
instance GHC.Enum.Enum Codec.Picture.Png.Internal.Type.PngInterlaceMethod
instance GHC.Show.Show Codec.Picture.Png.Internal.Type.PngIHdr
instance Data.Binary.Class.Binary Codec.Picture.Png.Internal.Type.PngRawImage
instance Data.Binary.Class.Binary Codec.Picture.Png.Internal.Type.PngIHdr
instance Data.Binary.Class.Binary Codec.Picture.Png.Internal.Type.PngInterlaceMethod
instance Data.Binary.Class.Binary Codec.Picture.Png.Internal.Type.PngFilter
instance Data.Binary.Class.Binary Codec.Picture.Png.Internal.Type.PngRawChunk
instance Data.Binary.Class.Binary Codec.Picture.Png.Internal.Type.PngImageType
instance Data.Binary.Class.Binary Codec.Picture.Png.Internal.Type.PngGamma
instance Data.Binary.Class.Binary Codec.Picture.Png.Internal.Type.PngPhysicalDimension
instance Data.Binary.Class.Binary Codec.Picture.Png.Internal.Type.PngUnit

module Codec.Picture.Png.Internal.Metadata
extractMetadatas :: PngRawImage -> Metadatas
encodeMetadatas :: Metadatas -> [PngRawChunk]
instance GHC.Show.Show Codec.Picture.Png.Internal.Metadata.PngText
instance GHC.Show.Show Codec.Picture.Png.Internal.Metadata.PngZText
instance Data.Binary.Class.Binary Codec.Picture.Png.Internal.Metadata.PngZText
instance Data.Binary.Class.Binary Codec.Picture.Png.Internal.Metadata.PngText


-- | Module implementing function to read and write Targa (*.tga) files.
module Codec.Picture.Tga

-- | Transform a raw tga image to an image, without modifying the
--   underlying pixel type.
--   
--   This function can output the following images:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGBA8</a></li>
--   </ul>
decodeTga :: ByteString -> Either String DynamicImage

-- | Equivalent to decodeTga but also provide metadata
decodeTgaWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Equivalent to decodeTga but with metdata and palette if any
decodeTgaWithPaletteAndMetadata :: ByteString -> Either String (PalettedImage, Metadatas)

-- | This typeclass determine if a pixel can be saved in the TGA format.
class TgaSaveable a

-- | Transform a compatible image to a raw bytestring representing a Targa
--   file.
encodeTga :: TgaSaveable px => Image px -> ByteString

-- | Helper function to directly write an image a tga on disk.
writeTga :: TgaSaveable pixel => FilePath -> Image pixel -> IO ()
instance Codec.Picture.Tga.TgaSaveable Codec.Picture.Types.Pixel8
instance Codec.Picture.Tga.TgaSaveable Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Tga.TgaSaveable Codec.Picture.Types.PixelRGBA8
instance Codec.Picture.Tga.TGAPixel Codec.Picture.Tga.Depth8
instance Codec.Picture.Tga.TGAPixel Codec.Picture.Tga.Depth15
instance Codec.Picture.Tga.TGAPixel Codec.Picture.Tga.Depth24
instance Codec.Picture.Tga.TGAPixel Codec.Picture.Tga.Depth32
instance Data.Binary.Class.Binary Codec.Picture.Tga.TgaFile
instance Data.Binary.Class.Binary Codec.Picture.Tga.TgaHeader
instance Data.Binary.Class.Binary Codec.Picture.Tga.TgaImageDescription
instance Data.Binary.Class.Binary Codec.Picture.Tga.TgaImageType
instance Data.Binary.Class.Binary Codec.Picture.Tga.TgaColorMapType


-- | Module implementing a basic png export, no filtering is applyed, but
--   export at least valid images.
module Codec.Picture.Png.Internal.Export

-- | Encode an image into a png if possible.
class PngSavable a

-- | Transform an image into a png encoded bytestring, ready to be written
--   as a file.
encodePng :: PngSavable a => Image a -> ByteString

-- | Encode a png using some metadatas. The following metadata keys will be
--   stored in a <tt>tEXt</tt> field :
--   
--   <ul>
--   <li><a>Title</a></li>
--   <li><a>Description</a></li>
--   <li><a>Author</a></li>
--   <li><a>Copyright</a></li>
--   <li><a>Software</a></li>
--   <li><a>Comment</a></li>
--   <li><a>Disclaimer</a></li>
--   <li><a>Source</a></li>
--   <li><a>Warning</a></li>
--   <li><a>Unknown</a> using the key present in the constructor.</li>
--   </ul>
--   
--   the followings metadata will bes tored in the <tt>gAMA</tt> chunk.
--   
--   <ul>
--   <li><a>Gamma</a></li>
--   </ul>
--   
--   The followings metadata will be stored in a <tt>pHYs</tt> chunk
--   
--   <ul>
--   <li><a>DpiX</a></li>
--   <li><a>DpiY</a></li>
--   </ul>
encodePngWithMetadata :: PngSavable a => Metadatas -> Image a -> ByteString

-- | Encode a paletted image into a png if possible.
class PngPaletteSaveable a

-- | Encode a paletted image as a color indexed 8-bit PNG. the palette must
--   have between 1 and 256 values in it. Accepts <a>PixelRGB8</a> and
--   <a>PixelRGBA8</a> as palette pixel type
encodePalettedPng :: PngPaletteSaveable a => Image a -> Image Pixel8 -> Either String ByteString

-- | Equivalent to <a>encodePalettedPng</a> but allow writing of metadatas.
--   See <a>encodePngWithMetadata</a> for the details of encoded metadatas
--   Accepts <a>PixelRGB8</a> and <a>PixelRGBA8</a> as palette pixel type
encodePalettedPngWithMetadata :: PngPaletteSaveable a => Metadatas -> Image a -> Image Pixel8 -> Either String ByteString

-- | Helper function to directly write an image as a png on disk.
writePng :: PngSavable pixel => FilePath -> Image pixel -> IO ()

-- | Encode a dynamic image in PNG if possible, supported images are:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageY16</a></li>
--   <li><a>ImageYA8</a></li>
--   <li><a>ImageYA16</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGB16</a></li>
--   <li><a>ImageRGBA8</a></li>
--   <li><a>ImageRGBA16</a></li>
--   </ul>
encodeDynamicPng :: DynamicImage -> Either String ByteString

-- | Write a dynamic image in a .png image file if possible. The same
--   restriction as encodeDynamicPng apply.
writeDynamicPng :: FilePath -> DynamicImage -> IO (Either String Bool)
instance Codec.Picture.Png.Internal.Export.PngSavable Codec.Picture.Types.PixelRGBA8
instance Codec.Picture.Png.Internal.Export.PngSavable Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Png.Internal.Export.PngSavable Codec.Picture.Types.Pixel8
instance Codec.Picture.Png.Internal.Export.PngSavable Codec.Picture.Types.PixelYA8
instance Codec.Picture.Png.Internal.Export.PngSavable Codec.Picture.Types.PixelYA16
instance Codec.Picture.Png.Internal.Export.PngSavable Codec.Picture.Types.Pixel16
instance Codec.Picture.Png.Internal.Export.PngSavable Codec.Picture.Types.PixelRGB16
instance Codec.Picture.Png.Internal.Export.PngSavable Codec.Picture.Types.PixelRGBA16
instance Codec.Picture.Png.Internal.Export.PngPaletteSaveable Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Png.Internal.Export.PngPaletteSaveable Codec.Picture.Types.PixelRGBA8


-- | Module used for loading &amp; writing 'Portable Network Graphics'
--   (PNG) files.
--   
--   A high level API is provided. It loads and saves images for you while
--   hiding all the details about PNG chunks.
--   
--   Basic functions for PNG handling are <a>decodePng</a>,
--   <a>encodePng</a> and <a>encodePalettedPng</a>. Convenience functions
--   are provided for direct file handling and using <a>DynamicImage</a>s.
--   
--   The loader has been validated against the pngsuite
--   (http:/<i>www.libpng.org</i>pub<i>png</i>pngsuite.html)
module Codec.Picture.Png

-- | Encode an image into a png if possible.
class PngSavable a

-- | Transform an image into a png encoded bytestring, ready to be written
--   as a file.
encodePng :: PngSavable a => Image a -> ByteString

-- | Encode a png using some metadatas. The following metadata keys will be
--   stored in a <tt>tEXt</tt> field :
--   
--   <ul>
--   <li><a>Title</a></li>
--   <li><a>Description</a></li>
--   <li><a>Author</a></li>
--   <li><a>Copyright</a></li>
--   <li><a>Software</a></li>
--   <li><a>Comment</a></li>
--   <li><a>Disclaimer</a></li>
--   <li><a>Source</a></li>
--   <li><a>Warning</a></li>
--   <li><a>Unknown</a> using the key present in the constructor.</li>
--   </ul>
--   
--   the followings metadata will bes tored in the <tt>gAMA</tt> chunk.
--   
--   <ul>
--   <li><a>Gamma</a></li>
--   </ul>
--   
--   The followings metadata will be stored in a <tt>pHYs</tt> chunk
--   
--   <ul>
--   <li><a>DpiX</a></li>
--   <li><a>DpiY</a></li>
--   </ul>
encodePngWithMetadata :: PngSavable a => Metadatas -> Image a -> ByteString

-- | Encode a paletted image into a png if possible.
class PngPaletteSaveable a

-- | Encode a paletted image as a color indexed 8-bit PNG. the palette must
--   have between 1 and 256 values in it. Accepts <a>PixelRGB8</a> and
--   <a>PixelRGBA8</a> as palette pixel type
encodePalettedPng :: PngPaletteSaveable a => Image a -> Image Pixel8 -> Either String ByteString

-- | Equivalent to <a>encodePalettedPng</a> but allow writing of metadatas.
--   See <a>encodePngWithMetadata</a> for the details of encoded metadatas
--   Accepts <a>PixelRGB8</a> and <a>PixelRGBA8</a> as palette pixel type
encodePalettedPngWithMetadata :: PngPaletteSaveable a => Metadatas -> Image a -> Image Pixel8 -> Either String ByteString

-- | Transform a raw png image to an image, without modifying the
--   underlying pixel type. If the image is greyscale and &lt; 8 bits, a
--   transformation to RGBA8 is performed. This should change in the
--   future. The resulting image let you manage the pixel types.
--   
--   This function can output the following images:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageY16</a></li>
--   <li><a>ImageYA8</a></li>
--   <li><a>ImageYA16</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGB16</a></li>
--   <li><a>ImageRGBA8</a></li>
--   <li><a>ImageRGBA16</a></li>
--   </ul>
decodePng :: ByteString -> Either String DynamicImage

-- | Decode a PNG file with, possibly, separated palette.
decodePngWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Same as <a>decodePng</a> but also extract meta datas present in the
--   files.
decodePngWithPaletteAndMetadata :: ByteString -> Either String (PalettedImage, Metadatas)

-- | Helper function to directly write an image as a png on disk.
writePng :: PngSavable pixel => FilePath -> Image pixel -> IO ()

-- | Encode a dynamic image in PNG if possible, supported images are:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageY16</a></li>
--   <li><a>ImageYA8</a></li>
--   <li><a>ImageYA16</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGB16</a></li>
--   <li><a>ImageRGBA8</a></li>
--   <li><a>ImageRGBA16</a></li>
--   </ul>
encodeDynamicPng :: DynamicImage -> Either String ByteString

-- | Write a dynamic image in a .png image file if possible. The same
--   restriction as encodeDynamicPng apply.
writeDynamicPng :: FilePath -> DynamicImage -> IO (Either String Bool)


-- | Module dedicated of Radiance file decompression (.hdr or .pic) file.
--   Radiance file format is used for High dynamic range imaging.
module Codec.Picture.HDR

-- | Decode an HDR (radiance) image, the resulting image can be:
--   
--   <ul>
--   <li><a>ImageRGBF</a></li>
--   </ul>
decodeHDR :: ByteString -> Either String DynamicImage

-- | Equivalent to decodeHDR but with aditional metadatas.
decodeHDRWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Encode an High dynamic range image into a radiance image file format.
--   Alias for encodeRawHDR
encodeHDR :: Image PixelRGBF -> ByteString

-- | Encode an High dynamic range image into a radiance image file format.
--   without compression
encodeRawHDR :: Image PixelRGBF -> ByteString

-- | Encode an High dynamic range image into a radiance image file format
--   using a light RLE compression. Some problems seem to arise with some
--   image viewer.
encodeRLENewStyleHDR :: Image PixelRGBF -> ByteString

-- | Write an High dynamic range image into a radiance image file on disk.
writeHDR :: FilePath -> Image PixelRGBF -> IO ()

-- | Write a RLE encoded High dynamic range image into a radiance image
--   file on disk.
writeRLENewStyleHDR :: FilePath -> Image PixelRGBF -> IO ()
instance Data.Binary.Class.Binary Codec.Picture.HDR.RadianceHeader
instance Data.Binary.Class.Binary Codec.Picture.HDR.RadianceFormat
instance Data.Binary.Class.Binary Codec.Picture.HDR.RGBE


-- | Modules used for Bitmap file (.bmp) file loading and writing
module Codec.Picture.Bitmap

-- | Write an image in a file use the bitmap format.
writeBitmap :: BmpEncodable pixel => FilePath -> Image pixel -> IO ()

-- | Encode an image into a bytestring in .bmp format ready to be written
--   on disk.
encodeBitmap :: forall pixel. BmpEncodable pixel => Image pixel -> ByteString

-- | Equivalent to <a>encodeBitmap</a> but also store the following
--   metadatas:
--   
--   <ul>
--   <li><a>DpiX</a></li>
--   <li><a>DpiY</a></li>
--   </ul>
encodeBitmapWithMetadata :: forall pixel. BmpEncodable pixel => Metadatas -> Image pixel -> ByteString

-- | Try to decode a bitmap image. Right now this function can output the
--   following image:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGBA8</a></li>
--   </ul>
decodeBitmap :: ByteString -> Either String DynamicImage

-- | Same as <a>decodeBitmap</a> but also extracts metadata.
decodeBitmapWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Same as <a>decodeBitmap</a> but also extracts metadata and provide
--   separated palette.
decodeBitmapWithPaletteAndMetadata :: ByteString -> Either String (PalettedImage, Metadatas)

-- | Encode a dynamic image in BMP if possible, supported images are:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGBA8</a></li>
--   </ul>
encodeDynamicBitmap :: DynamicImage -> Either String ByteString

-- | Equivalent to <a>encodeBitmapWithPalette</a> but also store the
--   following metadatas:
--   
--   <ul>
--   <li><a>DpiX</a></li>
--   <li><a>DpiY</a></li>
--   </ul>
encodeBitmapWithPaletteAndMetadata :: forall pixel. BmpEncodable pixel => Metadatas -> BmpPalette -> Image pixel -> ByteString

-- | Write a dynamic image in a .bmp image file if possible. The same
--   restriction as <a>encodeDynamicBitmap</a> apply.
writeDynamicBitmap :: FilePath -> DynamicImage -> IO (Either String Bool)

-- | All the instance of this class can be written as a bitmap file using
--   this library.
class BmpEncodable pixel
instance GHC.Show.Show Codec.Picture.Bitmap.ColorSpaceType
instance GHC.Classes.Eq Codec.Picture.Bitmap.ColorSpaceType
instance GHC.Show.Show Codec.Picture.Bitmap.BmpV5Header
instance GHC.Show.Show t => GHC.Show.Show (Codec.Picture.Bitmap.Bitfield t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Codec.Picture.Bitmap.Bitfield t)
instance GHC.Show.Show t => GHC.Show.Show (Codec.Picture.Bitmap.Bitfields4 t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Codec.Picture.Bitmap.Bitfields4 t)
instance GHC.Show.Show t => GHC.Show.Show (Codec.Picture.Bitmap.Bitfields3 t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Codec.Picture.Bitmap.Bitfields3 t)
instance GHC.Show.Show Codec.Picture.Bitmap.RGBABmpFormat
instance GHC.Classes.Eq Codec.Picture.Bitmap.RGBABmpFormat
instance GHC.Show.Show Codec.Picture.Bitmap.RGBBmpFormat
instance GHC.Classes.Eq Codec.Picture.Bitmap.RGBBmpFormat
instance GHC.Show.Show Codec.Picture.Bitmap.IndexedBmpFormat
instance Codec.Picture.Bitmap.BmpEncodable Codec.Picture.Types.Pixel8
instance Codec.Picture.Bitmap.BmpEncodable Codec.Picture.Types.PixelRGBA8
instance Codec.Picture.Bitmap.BmpEncodable Codec.Picture.Types.PixelRGB8
instance Data.Binary.Class.Binary Codec.Picture.Bitmap.BmpV5Header
instance Data.Binary.Class.Binary Codec.Picture.Bitmap.ColorSpaceType
instance Data.Binary.Class.Binary Codec.Picture.Bitmap.BmpHeader


-- | Module used by the jpeg decoder internally, shouldn't be used in user
--   code.
module Codec.Picture.Jpg.Internal.DefaultTable

-- | Enumeration used to search in the tables for different components.
data DctComponent
DcComponent :: DctComponent
AcComponent :: DctComponent

-- | Tree storing the code used for huffman encoding.
data HuffmanTree

-- | If bit is 0 take the first subtree, if 1, the right.
Branch :: HuffmanTree -> HuffmanTree -> HuffmanTree

-- | We should output the value
Leaf :: Word8 -> HuffmanTree

-- | no value present
Empty :: HuffmanTree
type HuffmanTable = [[Word8]]
type HuffmanPackedTree = Vector Word16

-- | Represent a compact array of 8 * 8 values. The size is not guarenteed
--   by type system, but if makeMacroBlock is used, everything should be
--   fine size-wise
type MacroBlock a = Vector a
type QuantificationTable = MacroBlock Int16
type HuffmanWriterCode = Vector (Word8, Word16)
scaleQuantisationMatrix :: Int -> QuantificationTable -> QuantificationTable

-- | Helper function to create pure macro block of the good size.
makeMacroBlock :: Storable a => [a] -> MacroBlock a
makeInverseTable :: HuffmanTree -> HuffmanWriterCode

-- | Transform parsed coefficients from the jpeg header to a tree which can
--   be used to decode data.
buildHuffmanTree :: [[Word8]] -> HuffmanTree
packHuffmanTree :: HuffmanTree -> HuffmanPackedTree
huffmanPackedDecode :: HuffmanPackedTree -> BoolReader s Word8
defaultChromaQuantizationTable :: QuantificationTable
defaultLumaQuantizationTable :: QuantificationTable
defaultAcChromaHuffmanTree :: HuffmanTree
defaultAcChromaHuffmanTable :: HuffmanTable
defaultAcLumaHuffmanTree :: HuffmanTree

-- | From the Table K.5 of ITU-81 (p154)
defaultAcLumaHuffmanTable :: HuffmanTable
defaultDcChromaHuffmanTree :: HuffmanTree

-- | From the Table K.4 of ITU-81 (p153)
defaultDcChromaHuffmanTable :: HuffmanTable
defaultDcLumaHuffmanTree :: HuffmanTree

-- | From the Table K.3 of ITU-81 (p153)
defaultDcLumaHuffmanTable :: HuffmanTable
instance GHC.Show.Show Codec.Picture.Jpg.Internal.DefaultTable.HuffmanTree
instance GHC.Classes.Eq Codec.Picture.Jpg.Internal.DefaultTable.HuffmanTree
instance GHC.Show.Show Codec.Picture.Jpg.Internal.DefaultTable.DctComponent
instance GHC.Classes.Eq Codec.Picture.Jpg.Internal.DefaultTable.DctComponent

module Codec.Picture.Jpg.Internal.Types

-- | Macroblock that can be transformed.
type MutableMacroBlock s a = STVector s a

-- | Create a new macroblock with the good array size
createEmptyMutableMacroBlock :: (Storable a, Num a) => ST s (MutableMacroBlock s a)
printMacroBlock :: (Storable a, PrintfArg a) => MutableMacroBlock s a -> ST s String
printPureMacroBlock :: (Storable a, PrintfArg a) => MacroBlock a -> String

-- | Type only used to make clear what kind of integer we are carrying
--   Might be transformed into newtype in the future
type DcCoefficient = Int16
data JpgImage
JpgImage :: [JpgFrame] -> JpgImage
[jpgFrame] :: JpgImage -> [JpgFrame]
data JpgComponent
JpgComponent :: !Word8 -> !Word8 -> !Word8 -> !Word8 -> JpgComponent
[componentIdentifier] :: JpgComponent -> !Word8

-- | Stored with 4 bits
[horizontalSamplingFactor] :: JpgComponent -> !Word8

-- | Stored with 4 bits
[verticalSamplingFactor] :: JpgComponent -> !Word8
[quantizationTableDest] :: JpgComponent -> !Word8
data JpgFrameHeader
JpgFrameHeader :: !Word16 -> !Word8 -> !Word16 -> !Word16 -> !Word8 -> ![JpgComponent] -> JpgFrameHeader
[jpgFrameHeaderLength] :: JpgFrameHeader -> !Word16
[jpgSamplePrecision] :: JpgFrameHeader -> !Word8
[jpgHeight] :: JpgFrameHeader -> !Word16
[jpgWidth] :: JpgFrameHeader -> !Word16
[jpgImageComponentCount] :: JpgFrameHeader -> !Word8
[jpgComponents] :: JpgFrameHeader -> ![JpgComponent]
data JpgFrame
JpgAppFrame :: !Word8 -> ByteString -> JpgFrame
JpgAdobeAPP14 :: !JpgAdobeApp14 -> JpgFrame
JpgJFIF :: !JpgJFIFApp0 -> JpgFrame
JpgExif :: ![ImageFileDirectory] -> JpgFrame
JpgExtension :: !Word8 -> ByteString -> JpgFrame
JpgQuantTable :: ![JpgQuantTableSpec] -> JpgFrame
JpgHuffmanTable :: ![(JpgHuffmanTableSpec, HuffmanPackedTree)] -> JpgFrame
JpgScanBlob :: !JpgScanHeader -> !ByteString -> JpgFrame
JpgScans :: !JpgFrameKind -> !JpgFrameHeader -> JpgFrame
JpgIntervalRestart :: !Word16 -> JpgFrame
data JpgFrameKind
JpgBaselineDCTHuffman :: JpgFrameKind
JpgExtendedSequentialDCTHuffman :: JpgFrameKind
JpgProgressiveDCTHuffman :: JpgFrameKind
JpgLosslessHuffman :: JpgFrameKind
JpgDifferentialSequentialDCTHuffman :: JpgFrameKind
JpgDifferentialProgressiveDCTHuffman :: JpgFrameKind
JpgDifferentialLosslessHuffman :: JpgFrameKind
JpgExtendedSequentialArithmetic :: JpgFrameKind
JpgProgressiveDCTArithmetic :: JpgFrameKind
JpgLosslessArithmetic :: JpgFrameKind
JpgDifferentialSequentialDCTArithmetic :: JpgFrameKind
JpgDifferentialProgressiveDCTArithmetic :: JpgFrameKind
JpgDifferentialLosslessArithmetic :: JpgFrameKind
JpgQuantizationTable :: JpgFrameKind
JpgHuffmanTableMarker :: JpgFrameKind
JpgStartOfScan :: JpgFrameKind
JpgEndOfImage :: JpgFrameKind
JpgAppSegment :: Word8 -> JpgFrameKind
JpgExtensionSegment :: Word8 -> JpgFrameKind
JpgRestartInterval :: JpgFrameKind
JpgRestartIntervalEnd :: Word8 -> JpgFrameKind
data JpgScanHeader
JpgScanHeader :: !Word16 -> !Word8 -> [JpgScanSpecification] -> (Word8, Word8) -> !Word8 -> !Word8 -> JpgScanHeader
[scanLength] :: JpgScanHeader -> !Word16
[scanComponentCount] :: JpgScanHeader -> !Word8
[scans] :: JpgScanHeader -> [JpgScanSpecification]

-- | (begin, end)
[spectralSelection] :: JpgScanHeader -> (Word8, Word8)

-- | Encoded as 4 bits
[successiveApproxHigh] :: JpgScanHeader -> !Word8

-- | Encoded as 4 bits
[successiveApproxLow] :: JpgScanHeader -> !Word8
data JpgQuantTableSpec
JpgQuantTableSpec :: !Word8 -> !Word8 -> MacroBlock Int16 -> JpgQuantTableSpec

-- | Stored on 4 bits
[quantPrecision] :: JpgQuantTableSpec -> !Word8

-- | Stored on 4 bits
[quantDestination] :: JpgQuantTableSpec -> !Word8
[quantTable] :: JpgQuantTableSpec -> MacroBlock Int16
data JpgHuffmanTableSpec
JpgHuffmanTableSpec :: !DctComponent -> !Word8 -> !Vector Word8 -> !Vector (Vector Word8) -> JpgHuffmanTableSpec

-- | 0 : DC, 1 : AC, stored on 4 bits
[huffmanTableClass] :: JpgHuffmanTableSpec -> !DctComponent

-- | Stored on 4 bits
[huffmanTableDest] :: JpgHuffmanTableSpec -> !Word8
[huffSizes] :: JpgHuffmanTableSpec -> !Vector Word8
[huffCodes] :: JpgHuffmanTableSpec -> !Vector (Vector Word8)
data JpgImageKind
BaseLineDCT :: JpgImageKind
ProgressiveDCT :: JpgImageKind
data JpgScanSpecification
JpgScanSpecification :: !Word8 -> !Word8 -> !Word8 -> JpgScanSpecification
[componentSelector] :: JpgScanSpecification -> !Word8

-- | Encoded as 4 bits
[dcEntropyCodingTable] :: JpgScanSpecification -> !Word8

-- | Encoded as 4 bits
[acEntropyCodingTable] :: JpgScanSpecification -> !Word8
data JpgColorSpace
JpgColorSpaceYCbCr :: JpgColorSpace
JpgColorSpaceYCC :: JpgColorSpace
JpgColorSpaceY :: JpgColorSpace
JpgColorSpaceYA :: JpgColorSpace
JpgColorSpaceYCCA :: JpgColorSpace
JpgColorSpaceYCCK :: JpgColorSpace
JpgColorSpaceCMYK :: JpgColorSpace
JpgColorSpaceRGB :: JpgColorSpace
JpgColorSpaceRGBA :: JpgColorSpace
data AdobeTransform

-- | Value 0
AdobeUnknown :: AdobeTransform

-- | value 1
AdobeYCbCr :: AdobeTransform

-- | value 2
AdobeYCck :: AdobeTransform
data JpgAdobeApp14
JpgAdobeApp14 :: !Word16 -> !Word16 -> !Word16 -> !AdobeTransform -> JpgAdobeApp14
[_adobeDctVersion] :: JpgAdobeApp14 -> !Word16
[_adobeFlag0] :: JpgAdobeApp14 -> !Word16
[_adobeFlag1] :: JpgAdobeApp14 -> !Word16
[_adobeTransform] :: JpgAdobeApp14 -> !AdobeTransform
data JpgJFIFApp0
JpgJFIFApp0 :: !JFifUnit -> !Word16 -> !Word16 -> !Maybe Int -> JpgJFIFApp0
[_jfifUnit] :: JpgJFIFApp0 -> !JFifUnit
[_jfifDpiX] :: JpgJFIFApp0 -> !Word16
[_jfifDpiY] :: JpgJFIFApp0 -> !Word16
[_jfifThumbnail] :: JpgJFIFApp0 -> !Maybe Int

-- | Size: 1
data JFifUnit

-- | 0
JFifUnitUnknown :: JFifUnit

-- | 1
JFifPixelsPerInch :: JFifUnit

-- | 2
JFifPixelsPerCentimeter :: JFifUnit
calculateSize :: SizeCalculable a => a -> Int
dctBlockSize :: Num a => a
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgFrameKind
instance GHC.Classes.Eq Codec.Picture.Jpg.Internal.Types.JpgFrameKind
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgColorSpace
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.AdobeTransform
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgAdobeApp14
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JFifUnit
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgJFIFApp0
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgComponent
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgFrameHeader
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgScanSpecification
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgScanHeader
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgQuantTableSpec
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgHuffmanTableSpec
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgFrame
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Types.JpgImage
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.RestartInterval
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.JpgImage
instance Codec.Picture.Jpg.Internal.Types.SizeCalculable Codec.Picture.Jpg.Internal.Types.JpgHuffmanTableSpec
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.JpgHuffmanTableSpec
instance (Codec.Picture.Jpg.Internal.Types.SizeCalculable a, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Codec.Picture.Jpg.Internal.Types.TableList a)
instance Codec.Picture.Jpg.Internal.Types.SizeCalculable Codec.Picture.Jpg.Internal.Types.JpgFrameHeader
instance Codec.Picture.Jpg.Internal.Types.SizeCalculable Codec.Picture.Jpg.Internal.Types.JpgComponent
instance Codec.Picture.Jpg.Internal.Types.SizeCalculable Codec.Picture.Jpg.Internal.Types.JpgScanSpecification
instance Codec.Picture.Jpg.Internal.Types.SizeCalculable Codec.Picture.Jpg.Internal.Types.JpgScanHeader
instance Codec.Picture.Jpg.Internal.Types.SizeCalculable Codec.Picture.Jpg.Internal.Types.JpgQuantTableSpec
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.JpgQuantTableSpec
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.JpgScanHeader
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.JpgScanSpecification
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.JpgFrameHeader
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.JpgComponent
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.JpgJFIFApp0
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.JFifUnit
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.JpgAdobeApp14
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.AdobeTransform
instance Data.Binary.Class.Binary Codec.Picture.Jpg.Internal.Types.JpgFrameKind

module Codec.Picture.Jpg.Internal.Metadata
extractMetadatas :: JpgJFIFApp0 -> Metadatas
encodeMetadatas :: Metadatas -> [JpgFrame]


-- | Module providing a <tt>fast</tt> implementation of IDCT
--   
--   inverse two dimensional DCT, Chen-Wang algorithm (cf. IEEE ASSP-32,
--   pp. 803-816, Aug. 1984) 32-bit integer arithmetic (8 bit coefficients)
--   11 mults, 29 adds per DCT sE, 18.8.91
--   
--   coefficients extended to 12 bit for IEEE1180-1990 compliance sE,
--   2.1.94
--   
--   this code assumes &gt;&gt; to be a two's-complement arithmetic right
--   shift: (-2)&gt;&gt;1 == -1 , (-3)&gt;&gt;1 == -2
module Codec.Picture.Jpg.Internal.FastIdct

-- | Macroblock that can be transformed.
type MutableMacroBlock s a = STVector s a

-- | Algorithm to call to perform an IDCT, return the same block that the
--   one given as input.
fastIdct :: MutableMacroBlock s Int16 -> ST s (MutableMacroBlock s Int16)

-- | Perform a Jpeg level shift in a mutable fashion.
mutableLevelShift :: MutableMacroBlock s Int16 -> ST s (MutableMacroBlock s Int16)

-- | Create a new macroblock with the good array size
createEmptyMutableMacroBlock :: (Storable a, Num a) => ST s (MutableMacroBlock s a)

module Codec.Picture.Jpg.Internal.FastDct

-- | Reference implementation of the DCT, directly implementing the formula
--   of ITU-81. It's slow as hell, perform to many operations, but is
--   accurate and a good reference point.
referenceDct :: MutableMacroBlock s Int32 -> MutableMacroBlock s Int16 -> ST s (MutableMacroBlock s Int32)

-- | Fast DCT extracted from libjpeg
fastDctLibJpeg :: MutableMacroBlock s Int32 -> MutableMacroBlock s Int16 -> ST s (MutableMacroBlock s Int32)

module Codec.Picture.Jpg.Internal.Common

-- | Same as for DcCoefficient, to provide nicer type signatures
type DctCoefficients = DcCoefficient
data JpgUnpackerParameter
JpgUnpackerParameter :: !HuffmanPackedTree -> !HuffmanPackedTree -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !(Int, Int) -> !(Int, Int) -> !(Int, Int) -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> JpgUnpackerParameter
[dcHuffmanTree] :: JpgUnpackerParameter -> !HuffmanPackedTree
[acHuffmanTree] :: JpgUnpackerParameter -> !HuffmanPackedTree
[componentIndex] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[restartInterval] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[componentWidth] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[componentHeight] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[subSampling] :: JpgUnpackerParameter -> !(Int, Int)
[coefficientRange] :: JpgUnpackerParameter -> !(Int, Int)
[successiveApprox] :: JpgUnpackerParameter -> !(Int, Int)
[readerIndex] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int

-- | When in progressive mode, we can have many color in a scan or only
--   one. The indices changes on this fact, when mixed, there is whole MCU
--   for all color components, spanning multiple block lines. With only one
--   color component we use the normal raster order.
[indiceVector] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[blockIndex] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[blockMcuX] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[blockMcuY] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
decodeInt :: Int -> BoolReader s Int32
dcCoefficientDecode :: HuffmanPackedTree -> BoolReader s DcCoefficient

-- | Apply a quantization matrix to a macroblock
deQuantize :: MacroBlock Int16 -> MutableMacroBlock s Int16 -> ST s (MutableMacroBlock s Int16)
decodeRrrrSsss :: HuffmanPackedTree -> BoolReader s (Int, Int)
zigZagReorderForward :: Storable a => MutableMacroBlock s a -> MutableMacroBlock s a -> ST s (MutableMacroBlock s a)
zigZagReorderForwardv :: (Storable a, Num a) => Vector a -> Vector a
zigZagReorder :: MutableMacroBlock s Int16 -> MutableMacroBlock s Int16 -> ST s (MutableMacroBlock s Int16)
inverseDirectCosineTransform :: MutableMacroBlock s Int16 -> ST s (MutableMacroBlock s Int16)

-- | Unpack an int of the given size encoded from MSB to LSB.
unpackInt :: Int -> BoolReader s Int32

-- | Given a size coefficient (how much a pixel span horizontally and
--   vertically), the position of the macroblock, return a list of indices
--   and value to be stored in an array (like the final image)
unpackMacroBlock :: Int -> Int -> Int -> Int -> Int -> Int -> MutableImage s PixelYCbCr8 -> MutableMacroBlock s Int16 -> ST s ()
rasterMap :: Monad m => Int -> Int -> (Int -> Int -> m ()) -> m ()

-- | This is one of the most important function of the decoding, it form
--   the barebone decoding pipeline for macroblock. It's all there is to
--   know for macro block transformation
decodeMacroBlock :: MacroBlock DctCoefficients -> MutableMacroBlock s Int16 -> MutableMacroBlock s Int16 -> ST s (MutableMacroBlock s Int16)
decodeRestartInterval :: BoolReader s Int32
toBlockSize :: Int -> Int
instance GHC.Show.Show Codec.Picture.Jpg.Internal.Common.JpgUnpackerParameter

module Codec.Picture.Jpg.Internal.Progressive
data JpgUnpackerParameter
JpgUnpackerParameter :: !HuffmanPackedTree -> !HuffmanPackedTree -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> !(Int, Int) -> !(Int, Int) -> !(Int, Int) -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> JpgUnpackerParameter
[dcHuffmanTree] :: JpgUnpackerParameter -> !HuffmanPackedTree
[acHuffmanTree] :: JpgUnpackerParameter -> !HuffmanPackedTree
[componentIndex] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[restartInterval] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[componentWidth] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[componentHeight] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[subSampling] :: JpgUnpackerParameter -> !(Int, Int)
[coefficientRange] :: JpgUnpackerParameter -> !(Int, Int)
[successiveApprox] :: JpgUnpackerParameter -> !(Int, Int)
[readerIndex] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int

-- | When in progressive mode, we can have many color in a scan or only
--   one. The indices changes on this fact, when mixed, there is whole MCU
--   for all color components, spanning multiple block lines. With only one
--   color component we use the normal raster order.
[indiceVector] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[blockIndex] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[blockMcuX] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
[blockMcuY] :: JpgUnpackerParameter -> {-# UNPACK #-} !Int
progressiveUnpack :: (Int, Int) -> JpgFrameHeader -> Vector (MacroBlock Int16) -> [([(JpgUnpackerParameter, a)], ByteString)] -> ST s (MutableImage s PixelYCbCr8)


-- | Module used for JPEG file loading and writing.
module Codec.Picture.Jpg

-- | Try to decompress and decode a jpeg file. The colorspace is still
--   YCbCr if you want to perform computation on the luma part. You can
--   convert it to RGB using <a>convertImage</a> from the
--   <a>ColorSpaceConvertible</a> typeclass.
--   
--   This function can output the following images:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageYA8</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageCMYK8</a></li>
--   <li><a>ImageYCbCr8</a></li>
--   </ul>
decodeJpeg :: ByteString -> Either String DynamicImage

-- | Equivalent to <a>decodeJpeg</a> but also extracts metadatas.
--   
--   Extract the following metadatas from the JFIF block:
--   
--   <ul>
--   <li><a>DpiX</a></li>
--   <li><a>DpiY</a></li>
--   </ul>
--   
--   Exif metadata are also extracted if present.
decodeJpegWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Function to call to encode an image to jpeg. The quality factor should
--   be between 0 and 100 (100 being the best quality).
encodeJpegAtQuality :: Word8 -> Image PixelYCbCr8 -> ByteString

-- | Equivalent to <a>encodeJpegAtQuality</a>, but will store the following
--   metadatas in the file using a JFIF block:
--   
--   <ul>
--   <li><a>DpiX</a></li>
--   <li><a>DpiY</a></li>
--   </ul>
encodeJpegAtQualityWithMetadata :: Word8 -> Metadatas -> Image PixelYCbCr8 -> ByteString

-- | Equivalent to <a>encodeJpegAtQuality</a>, but will store the following
--   metadatas in the file using a JFIF block:
--   
--   <ul>
--   <li><a>DpiX</a></li>
--   <li><a>DpiY</a></li>
--   </ul>
--   
--   This function also allow to create JPEG files with the following color
--   space:
--   
--   <ul>
--   <li>Y (<a>Pixel8</a>) for greyscale.</li>
--   <li>RGB (<a>PixelRGB8</a>) with no color downsampling on any
--   plane</li>
--   <li>CMYK (<a>PixelCMYK8</a>) with no color downsampling on any
--   plane</li>
--   </ul>
encodeDirectJpegAtQualityWithMetadata :: forall px. JpgEncodable px => Word8 -> Metadatas -> Image px -> ByteString

-- | Encode an image in jpeg at a reasonnable quality level. If you want
--   better quality or reduced file size, you should use
--   <a>encodeJpegAtQuality</a>
encodeJpeg :: Image PixelYCbCr8 -> ByteString

-- | Helper type class describing all JPG-encodable pixel types
class (Pixel px, PixelBaseComponent px ~ Word8) => JpgEncodable px
instance Codec.Picture.Jpg.JpgEncodable Codec.Picture.Types.Pixel8
instance Codec.Picture.Jpg.JpgEncodable Codec.Picture.Types.PixelYCbCr8
instance Codec.Picture.Jpg.JpgEncodable Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Jpg.JpgEncodable Codec.Picture.Types.PixelCMYK8

module Codec.Picture.Gif.Internal.LZWEncoding
lzwEncode :: Int -> Vector Word8 -> ByteString

module Codec.Picture.Gif.Internal.LZW
decodeLzw :: ByteString -> Int -> Int -> STVector s Word8 -> BoolReader s ()
decodeLzwTiff :: ByteString -> STVector s Word8 -> Int -> BoolReader s ()
instance GHC.Classes.Eq Codec.Picture.Gif.Internal.LZW.TiffVariant


-- | Module implementing TIFF decoding.
--   
--   Supported compression schemes:
--   
--   <ul>
--   <li>Uncompressed</li>
--   <li>PackBits</li>
--   <li>LZW</li>
--   </ul>
--   
--   Supported bit depth:
--   
--   <ul>
--   <li>2 bits</li>
--   <li>4 bits</li>
--   <li>8 bits</li>
--   <li>16 bits</li>
--   </ul>
module Codec.Picture.Tiff

-- | Decode a tiff encoded image while preserving the underlying pixel type
--   (except for Y32 which is truncated to 16 bits).
--   
--   This function can output the following images:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageY16</a></li>
--   <li><a>ImageY32</a></li>
--   <li><a>ImageYF</a></li>
--   <li><a>ImageYA8</a></li>
--   <li><a>ImageYA16</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGB16</a></li>
--   <li><a>ImageRGBA8</a></li>
--   <li><a>ImageRGBA16</a></li>
--   <li><a>ImageCMYK8</a></li>
--   <li><a>ImageCMYK16</a></li>
--   </ul>
decodeTiff :: ByteString -> Either String DynamicImage

-- | Like <a>decodeTiff</a> but also provides some metdata present in the
--   Tiff file.
--   
--   The metadata extracted are the <a>DpiX</a> &amp; <a>DpiY</a>
--   information alongside the EXIF informations.
decodeTiffWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Decode TIFF and provide separated palette and metadata
decodeTiffWithPaletteAndMetadata :: ByteString -> Either String (PalettedImage, Metadatas)

-- | Class defining which pixel types can be serialized in a Tiff file.
class (Pixel px) => TiffSaveable px

-- | Transform an image into a Tiff encoded bytestring, ready to be written
--   as a file.
encodeTiff :: forall px. TiffSaveable px => Image px -> ByteString

-- | Helper function to directly write an image as a tiff on disk.
writeTiff :: TiffSaveable pixel => FilePath -> Image pixel -> IO ()
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.Pixel8
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.Pixel16
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.Pixel32
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.PixelF
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.PixelYA8
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.PixelYA16
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.PixelCMYK8
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.PixelCMYK16
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.PixelRGB16
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.PixelRGBA8
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.PixelRGBA16
instance Codec.Picture.Tiff.TiffSaveable Codec.Picture.Types.PixelYCbCr8
instance Codec.Picture.Tiff.Unpackable Codec.Picture.Tiff.YCbCrSubsampling
instance Codec.Picture.Tiff.Unpackable Codec.Picture.Tiff.Pack12
instance Codec.Picture.Tiff.Unpackable Codec.Picture.Tiff.Pack2
instance Codec.Picture.Tiff.Unpackable Codec.Picture.Tiff.Pack4
instance Codec.Picture.Tiff.Unpackable GHC.Word.Word8
instance Codec.Picture.Tiff.Unpackable GHC.Word.Word16
instance Codec.Picture.Tiff.Unpackable GHC.Word.Word32
instance Codec.Picture.Tiff.Unpackable GHC.Types.Float
instance Codec.Picture.Tiff.Internal.Types.BinaryParam Data.ByteString.Internal.ByteString Codec.Picture.Tiff.TiffInfo


-- | Module implementing GIF decoding.
module Codec.Picture.Gif

-- | Transform a raw gif image to an image, without modifying the pixels.
--   This function can output the following images:
--   
--   <ul>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGBA8</a></li>
--   </ul>
decodeGif :: ByteString -> Either String DynamicImage

-- | Transform a raw gif image to an image, without modifying the pixels.
--   This function can output the following images:
--   
--   <ul>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGBA8</a></li>
--   </ul>
--   
--   Metadatas include Width &amp; Height information.
decodeGifWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Return the gif image with metadata and palette. The palette is only
--   returned for the first image of an animation and has no transparency.
decodeGifWithPaletteAndMetadata :: ByteString -> Either String (PalettedImage, Metadatas)

-- | Transform a raw gif to a list of images, representing all the images
--   of an animation.
decodeGifImages :: ByteString -> Either String [DynamicImage]

-- | Extract a list of frame delays from a raw gif.
getDelaysGifImages :: ByteString -> Either String [GifDelay]

-- | Delay to wait before showing the next Gif image. The delay is
--   expressed in 100th of seconds.
type GifDelay = Int
data GifDisposalMethod
DisposalAny :: GifDisposalMethod
DisposalDoNot :: GifDisposalMethod
DisposalRestoreBackground :: GifDisposalMethod
DisposalRestorePrevious :: GifDisposalMethod
DisposalUnknown :: Word8 -> GifDisposalMethod

-- | GIF image definition for encoding
data GifEncode
GifEncode :: Int -> Int -> Maybe Palette -> Maybe Int -> GifLooping -> [GifFrame] -> GifEncode

-- | Screen width
[geWidth] :: GifEncode -> Int

-- | Screen height
[geHeight] :: GifEncode -> Int

-- | Global palette, optional
[gePalette] :: GifEncode -> Maybe Palette

-- | Background color index, optional. If given, a global palette is also
--   required
[geBackground] :: GifEncode -> Maybe Int

-- | Looping behaviour
[geLooping] :: GifEncode -> GifLooping

-- | Image frames
[geFrames] :: GifEncode -> [GifFrame]

-- | An individual image frame in a GIF image
data GifFrame
GifFrame :: Int -> Int -> Maybe Palette -> Maybe Int -> GifDelay -> GifDisposalMethod -> Image Pixel8 -> GifFrame

-- | Image X offset in GIF canvas
[gfXOffset] :: GifFrame -> Int

-- | Image Y offset in GIF canvas
[gfYOffset] :: GifFrame -> Int

-- | Image local palette, optional if a global palette is given
[gfPalette] :: GifFrame -> Maybe Palette

-- | Transparent color index, optional
[gfTransparent] :: GifFrame -> Maybe Int

-- | Frame transition delay, in 1/100ths of a second
[gfDelay] :: GifFrame -> GifDelay

-- | Frame disposal method
[gfDisposal] :: GifFrame -> GifDisposalMethod

-- | Image pixels
[gfPixels] :: GifFrame -> Image Pixel8

-- | Help to control the behaviour of GIF animation looping.
data GifLooping

-- | The animation will stop once the end is reached
LoopingNever :: GifLooping

-- | The animation will restart once the end is reached
LoopingForever :: GifLooping

-- | The animation will repeat n times before stoping
LoopingRepeat :: Word16 -> GifLooping

-- | Encode a greyscale image to a bytestring.
encodeGifImage :: Image Pixel8 -> ByteString

-- | Encode an image with a given palette. Can return errors if the palette
--   is ill-formed.
--   
--   <ul>
--   <li>A palette must have between 1 and 256 colors</li>
--   </ul>
encodeGifImageWithPalette :: Image Pixel8 -> Palette -> Either String ByteString

-- | Encode a gif animation to a bytestring.
--   
--   <ul>
--   <li>Every image must have the same size</li>
--   <li>Every palette must have between one and 256 colors.</li>
--   </ul>
encodeGifImages :: GifLooping -> [(Palette, GifDelay, Image Pixel8)] -> Either String ByteString

-- | Encode a complex gif to a bytestring.
--   
--   <ul>
--   <li>There must be at least one image.</li>
--   <li>The screen and every frame dimensions must be between 1 and
--   65535.</li>
--   <li>Every frame image must fit within the screen bounds.</li>
--   <li>Every palette must have between one and 256 colors.</li>
--   <li>There must be a global palette or every image must have a local
--   palette.</li>
--   <li>The background color index must be present in the global
--   palette.</li>
--   <li>Every frame's transparent color index, if set, must be present in
--   the palette used by that frame.</li>
--   <li>Every color index used in an image must be present in the palette
--   used by that frame.</li>
--   </ul>
encodeComplexGifImage :: GifEncode -> Either String ByteString

-- | Write a greyscale in a gif file on the disk.
writeGifImage :: FilePath -> Image Pixel8 -> IO ()

-- | Write a gif image with a palette to a file.
--   
--   <ul>
--   <li>A palette must have between 1 and 256 colors</li>
--   </ul>
writeGifImageWithPalette :: FilePath -> Image Pixel8 -> Palette -> Either String (IO ())

-- | Write a list of images as a gif animation in a file.
--   
--   <ul>
--   <li>Every image must have the same size</li>
--   <li>Every palette must have between one and 256 colors.</li>
--   </ul>
writeGifImages :: FilePath -> GifLooping -> [(Palette, GifDelay, Image Pixel8)] -> Either String (IO ())
writeComplexGifImage :: FilePath -> GifEncode -> Either String (IO ())

-- | Default palette to produce greyscale images.
greyPalette :: Palette
instance Data.Binary.Class.Binary Codec.Picture.Gif.GifFile
instance Data.Binary.Class.Binary Codec.Picture.Gif.GifHeader
instance Data.Binary.Class.Binary Codec.Picture.Gif.GifImage
instance Data.Binary.Class.Binary Codec.Picture.Gif.GraphicControlExtension
instance Data.Binary.Class.Binary Codec.Picture.Gif.ImageDescriptor
instance Data.Binary.Class.Binary Codec.Picture.Gif.LogicalScreenDescriptor
instance Data.Binary.Class.Binary Codec.Picture.Gif.GifVersion


-- | This module provide some color quantisation algorithm in order to help
--   in the creation of paletted images. The most important function is
--   <a>palettize</a> which will make everything to create a nice color
--   indexed image with its palette.
module Codec.Picture.ColorQuant

-- | Reduces an image to a color palette according to <a>PaletteOptions</a>
--   and returns the <i>indices image</i> along with its <a>Palette</a>.
palettize :: PaletteOptions -> Image PixelRGB8 -> (Image Pixel8, Palette)

-- | Converts RGBA image to the array of GifFame's to use in
--   encodeComplexGifImage
palettizeWithAlpha :: [(GifDelay, Image PixelRGBA8)] -> GifDisposalMethod -> [GifFrame]

-- | Default palette option, which aim at the best quality and maximum
--   possible colors (256)
defaultPaletteOptions :: PaletteOptions

-- | Define which palette creation method is used.
data PaletteCreationMethod

-- | MedianMeanCut method, provide the best results (visualy) at the cost
--   of increased calculations.
MedianMeanCut :: PaletteCreationMethod

-- | Very fast algorithm (one pass), doesn't provide good looking results.
Uniform :: PaletteCreationMethod

-- | To specify how the palette will be created.
data PaletteOptions
PaletteOptions :: PaletteCreationMethod -> Bool -> Int -> PaletteOptions

-- | Algorithm used to find the palette
[paletteCreationMethod] :: PaletteOptions -> PaletteCreationMethod

-- | Do we want to apply the dithering to the image. Enabling it often
--   reduce compression ratio but enhance the perceived quality of the
--   final image.
[enableImageDithering] :: PaletteOptions -> Bool

-- | Maximum number of color we want in the palette
[paletteColorCount] :: PaletteOptions -> Int
instance GHC.Classes.Eq Codec.Picture.ColorQuant.Cluster
instance GHC.Classes.Ord Codec.Picture.ColorQuant.Cluster
instance GHC.Base.Applicative (Codec.Picture.ColorQuant.Fold a)
instance GHC.Base.Functor (Codec.Picture.ColorQuant.Fold a)


-- | Helper functions to save dynamic images to other file format with
--   automatic color space/sample format conversion done automatically.
module Codec.Picture.Saving

-- | This function will try to do anything to encode an image as JPEG, make
--   all color conversion and such. Equivalent of <tt>decodeImage</tt> for
--   jpeg encoding Save Y or YCbCr Jpeg only, all other colorspaces are
--   converted. To save a RGB or CMYK JPEG file, use the
--   <a>encodeDirectJpegAtQualityWithMetadata</a> function
imageToJpg :: Int -> DynamicImage -> ByteString

-- | This function will try to do anything to encode an image as PNG, make
--   all color conversion and such. Equivalent of <tt>decodeImage</tt> for
--   PNG encoding
imageToPng :: DynamicImage -> ByteString

-- | This function will try to do anything to encode an image as a gif,
--   make all color conversion and quantization. Equivalent of
--   <tt>decodeImage</tt> for gif encoding
imageToGif :: DynamicImage -> Either String ByteString

-- | This function will try to do anything to encode an image as bitmap,
--   make all color conversion and such. Equivalent of <tt>decodeImage</tt>
--   for Bitmap encoding
imageToBitmap :: DynamicImage -> ByteString

-- | This function will try to do anything to encode an image as a Tiff,
--   make all color conversion and such. Equivalent of <tt>decodeImage</tt>
--   for Tiff encoding
imageToTiff :: DynamicImage -> ByteString

-- | This function will try to do anything to encode an image as RADIANCE,
--   make all color conversion and such. Equivalent of <tt>decodeImage</tt>
--   for radiance encoding
imageToRadiance :: DynamicImage -> ByteString

-- | This function will try to do anything to encode an image as a tga,
--   make all color conversion and quantization. Equivalent of
--   <tt>decodeImage</tt> for tga encoding
imageToTga :: DynamicImage -> ByteString


-- | Main module for image import/export into various image formats.
--   
--   To use the library without thinking about it, look after
--   <a>decodeImage</a> and <a>readImage</a>.
--   
--   Generally, the <tt>read*</tt> functions read the images from a file
--   and try to decode it, and the <tt>decode*</tt> functions try to decode
--   a bytestring.
--   
--   For an easy image writing use the <a>saveBmpImage</a>,
--   <a>saveJpgImage</a> &amp; <a>savePngImage</a> functions
module Codec.Picture

-- | Load an image file without even thinking about it, it does everything
--   as <a>decodeImage</a>
readImage :: FilePath -> IO (Either String DynamicImage)

-- | Equivalent to <a>readImage</a> but also providing metadatas.
readImageWithMetadata :: FilePath -> IO (Either String (DynamicImage, Metadatas))

-- | If you want to decode an image in a bytestring without even thinking
--   in term of format or whatever, this is the function to use. It will
--   try to decode in each known format and if one decoding succeeds, it
--   will return the decoded image in it's own colorspace.
decodeImage :: ByteString -> Either String DynamicImage

-- | Equivalent to <a>decodeImage</a>, but also provide potential metadatas
--   present in the given file.
decodeImageWithMetadata :: ByteString -> Either String (DynamicImage, Metadatas)

-- | Equivalent to <a>decodeImage</a>, but also provide potential metadatas
--   present in the given file and the palettes if the format provides
--   them.
decodeImageWithPaletteAndMetadata :: ByteString -> Either String (PalettedImage, Metadatas)

-- | <a>map</a> equivalent for an image, working at the pixel level. Little
--   example : a brightness function for an rgb image
--   
--   <pre>
--   brightnessRGB8 :: Int -&gt; Image PixelRGB8 -&gt; Image PixelRGB8
--   brightnessRGB8 add = pixelMap brightFunction
--        where up v = fromIntegral (fromIntegral v + add)
--              brightFunction (PixelRGB8 r g b) =
--                      PixelRGB8 (up r) (up g) (up b)
--   </pre>
pixelMap :: forall a b. (Pixel a, Pixel b) => (a -> b) -> Image a -> Image b

-- | Helper function to help extract information from dynamic image. To get
--   the width of a dynamic image, you can use the following snippet:
--   
--   <pre>
--   dynWidth :: DynamicImage -&gt; Int
--   dynWidth img = dynamicMap imageWidth img
--   </pre>
dynamicMap :: (forall pixel. Pixel pixel => Image pixel -> a) -> DynamicImage -> a

-- | Equivalent of the <a>pixelMap</a> function for the dynamic images. You
--   can perform pixel colorspace independant operations with this
--   function.
--   
--   For instance, if you want to extract a square crop of any image,
--   without caring about colorspace, you can use the following snippet.
--   
--   <pre>
--   dynSquare :: DynamicImage -&gt; DynamicImage
--   dynSquare = dynamicPixelMap squareImage
--   
--   squareImage :: Pixel a =&gt; Image a -&gt; Image a
--   squareImage img = generateImage (\x y -&gt; pixelAt img x y) edge edge
--      where edge = min (imageWidth img) (imageHeight img)
--   </pre>
dynamicPixelMap :: (forall pixel. Pixel pixel => Image pixel -> Image pixel) -> DynamicImage -> DynamicImage

-- | Create an image given a function to generate pixels. The function will
--   receive values from 0 to width-1 for the x parameter and 0 to height-1
--   for the y parameter. The coordinates 0,0 are the upper left corner of
--   the image, and (width-1, height-1) the lower right corner.
--   
--   for example, to create a small gradient image:
--   
--   <pre>
--   imageCreator :: String -&gt; IO ()
--   imageCreator path = writePng path $ generateImage pixelRenderer 250 300
--      where pixelRenderer x y = PixelRGB8 (fromIntegral x) (fromIntegral y) 128
--   </pre>
generateImage :: forall px. Pixel px => (Int -> Int -> px) -> Int -> Int -> Image px

-- | Create an image given a function to generate pixels. The function will
--   receive values from 0 to width-1 for the x parameter and 0 to height-1
--   for the y parameter. The coordinates 0,0 are the upper left corner of
--   the image, and (width-1, height-1) the lower right corner.
--   
--   the acc parameter is a user defined one.
--   
--   The function is called for each pixel in the line from left to right
--   (0 to width - 1) and for each line (0 to height - 1).
generateFoldImage :: forall a acc. Pixel a => (acc -> Int -> Int -> (acc, a)) -> acc -> Int -> Int -> (acc, Image a)

-- | Create an image using a monadic initializer function. The function
--   will receive values from 0 to width-1 for the x parameter and 0 to
--   height-1 for the y parameter. The coordinates 0,0 are the upper left
--   corner of the image, and (width-1, height-1) the lower right corner.
--   
--   The function is called for each pixel in the line from left to right
--   (0 to width - 1) and for each line (0 to height - 1).
withImage :: forall m pixel. (Pixel pixel, PrimMonad m) => Int -> Int -> (Int -> Int -> m pixel) -> m (Image pixel)

-- | Flatten a PalettedImage to a DynamicImage
palettedToTrueColor :: PalettedImage -> DynamicImage

-- | Convert by any means possible a dynamic image to an image in RGB. The
--   process can lose precision while converting from 16bits pixels or
--   Floating point pixels. Any alpha layer will be dropped
convertRGB8 :: DynamicImage -> Image PixelRGB8

-- | Convert by any means possible a dynamic image to an image in RGB. The
--   process can lose precision while converting from 32bits pixels or
--   Floating point pixels. Any alpha layer will be dropped
convertRGB16 :: DynamicImage -> Image PixelRGB16

-- | Convert by any means possible a dynamic image to an image in RGBA. The
--   process can lose precision while converting from 16bits pixels or
--   Floating point pixels.
convertRGBA8 :: DynamicImage -> Image PixelRGBA8

-- | Traversal type matching the definition in the Lens package.
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | Traversal in "raster" order, from left to right the top to bottom.
--   This traversal is matching pixelMap in spirit.
--   
--   Since 3.2.4
imagePixels :: forall pxa pxb. (Pixel pxa, Pixel pxb) => Traversal (Image pxa) (Image pxb) pxa pxb

-- | Traversal providing the pixel position with it's value. The traversal
--   in raster order, from lef to right, then top to bottom. The traversal
--   match pixelMapXY in spirit.
--   
--   Since 3.2.4
imageIPixels :: forall pxa pxb. (Pixel pxa, Pixel pxb) => Traversal (Image pxa) (Image pxb) (Int, Int, pxa) pxb

-- | Save an image to a '.bmp' file, will do everything it can to save an
--   image.
saveBmpImage :: FilePath -> DynamicImage -> IO ()

-- | Save an image to a '.jpg' file, will do everything it can to save an
--   image.
saveJpgImage :: Int -> FilePath -> DynamicImage -> IO ()

-- | Save an image to a '.gif' file, will do everything it can to save it.
saveGifImage :: FilePath -> DynamicImage -> Either String (IO ())

-- | Save an image to a '.png' file, will do everything it can to save an
--   image. For example, a simple transcoder to png
--   
--   <pre>
--   transcodeToPng :: FilePath -&gt; FilePath -&gt; IO ()
--   transcodeToPng pathIn pathOut = do
--      eitherImg &lt;- readImage pathIn
--      case eitherImg of
--          Left _ -&gt; return ()
--          Right img -&gt; savePngImage pathOut img
--   </pre>
savePngImage :: FilePath -> DynamicImage -> IO ()

-- | Save an image to a '.tiff' file, will do everything it can to save an
--   image.
saveTiffImage :: FilePath -> DynamicImage -> IO ()

-- | Save an image to a '.hdr' file, will do everything it can to save an
--   image.
saveRadianceImage :: FilePath -> DynamicImage -> IO ()

-- | All the instance of this class can be written as a bitmap file using
--   this library.
class BmpEncodable pixel

-- | Write an image in a file use the bitmap format.
writeBitmap :: BmpEncodable pixel => FilePath -> Image pixel -> IO ()

-- | Encode an image into a bytestring in .bmp format ready to be written
--   on disk.
encodeBitmap :: forall pixel. BmpEncodable pixel => Image pixel -> ByteString

-- | Try to load a .bmp file. The colorspace would be RGB, RGBA or Y.
readBitmap :: FilePath -> IO (Either String DynamicImage)

-- | Try to decode a bitmap image. Right now this function can output the
--   following image:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGBA8</a></li>
--   </ul>
decodeBitmap :: ByteString -> Either String DynamicImage

-- | Encode a dynamic image in BMP if possible, supported images are:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGBA8</a></li>
--   </ul>
encodeDynamicBitmap :: DynamicImage -> Either String ByteString

-- | Write a dynamic image in a .bmp image file if possible. The same
--   restriction as <a>encodeDynamicBitmap</a> apply.
writeDynamicBitmap :: FilePath -> DynamicImage -> IO (Either String Bool)

-- | Helper function trying to load a gif file from a file on disk.
readGif :: FilePath -> IO (Either String DynamicImage)

-- | Helper function trying to load all the images of an animated gif file.
readGifImages :: FilePath -> IO (Either String [DynamicImage])

-- | Transform a raw gif image to an image, without modifying the pixels.
--   This function can output the following images:
--   
--   <ul>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGBA8</a></li>
--   </ul>
decodeGif :: ByteString -> Either String DynamicImage

-- | Transform a raw gif to a list of images, representing all the images
--   of an animation.
decodeGifImages :: ByteString -> Either String [DynamicImage]

-- | Encode a greyscale image to a bytestring.
encodeGifImage :: Image Pixel8 -> ByteString

-- | Write a greyscale in a gif file on the disk.
writeGifImage :: FilePath -> Image Pixel8 -> IO ()

-- | Encode an image with a given palette. Can return errors if the palette
--   is ill-formed.
--   
--   <ul>
--   <li>A palette must have between 1 and 256 colors</li>
--   </ul>
encodeGifImageWithPalette :: Image Pixel8 -> Palette -> Either String ByteString

-- | Write a gif image with a palette to a file.
--   
--   <ul>
--   <li>A palette must have between 1 and 256 colors</li>
--   </ul>
writeGifImageWithPalette :: FilePath -> Image Pixel8 -> Palette -> Either String (IO ())

-- | Encode a full color image to a gif by applying a color quantization
--   algorithm on it.
encodeColorReducedGifImage :: Image PixelRGB8 -> Either String ByteString

-- | Write a full color image to a gif by applying a color quantization
--   algorithm on it.
writeColorReducedGifImage :: FilePath -> Image PixelRGB8 -> Either String (IO ())

-- | Encode a gif animation to a bytestring.
--   
--   <ul>
--   <li>Every image must have the same size</li>
--   <li>Every palette must have between one and 256 colors.</li>
--   </ul>
encodeGifImages :: GifLooping -> [(Palette, GifDelay, Image Pixel8)] -> Either String ByteString

-- | Write a list of images as a gif animation in a file.
--   
--   <ul>
--   <li>Every image must have the same size</li>
--   <li>Every palette must have between one and 256 colors.</li>
--   </ul>
writeGifImages :: FilePath -> GifLooping -> [(Palette, GifDelay, Image Pixel8)] -> Either String (IO ())

-- | Delay to wait before showing the next Gif image. The delay is
--   expressed in 100th of seconds.
type GifDelay = Int

-- | Help to control the behaviour of GIF animation looping.
data GifLooping

-- | The animation will stop once the end is reached
LoopingNever :: GifLooping

-- | The animation will restart once the end is reached
LoopingForever :: GifLooping

-- | The animation will repeat n times before stoping
LoopingRepeat :: Word16 -> GifLooping

-- | Helper function to create a gif animation. All the images of the
--   animation are separated by the same delay.
encodeGifAnimation :: GifDelay -> GifLooping -> [Image PixelRGB8] -> Either String ByteString

-- | Helper function to write a gif animation on disk. See
--   encodeGifAnimation
writeGifAnimation :: FilePath -> GifDelay -> GifLooping -> [Image PixelRGB8] -> Either String (IO ())

-- | Try to load a jpeg file and decompress. The colorspace is still YCbCr
--   if you want to perform computation on the luma part. You can convert
--   it to RGB using <tt>colorSpaceConversion</tt>.
readJpeg :: FilePath -> IO (Either String DynamicImage)

-- | Try to decompress and decode a jpeg file. The colorspace is still
--   YCbCr if you want to perform computation on the luma part. You can
--   convert it to RGB using <a>convertImage</a> from the
--   <a>ColorSpaceConvertible</a> typeclass.
--   
--   This function can output the following images:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageYA8</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageCMYK8</a></li>
--   <li><a>ImageYCbCr8</a></li>
--   </ul>
decodeJpeg :: ByteString -> Either String DynamicImage

-- | Encode an image in jpeg at a reasonnable quality level. If you want
--   better quality or reduced file size, you should use
--   <a>encodeJpegAtQuality</a>
encodeJpeg :: Image PixelYCbCr8 -> ByteString

-- | Function to call to encode an image to jpeg. The quality factor should
--   be between 0 and 100 (100 being the best quality).
encodeJpegAtQuality :: Word8 -> Image PixelYCbCr8 -> ByteString

-- | Encode an image into a png if possible.
class PngSavable a

-- | Transform an image into a png encoded bytestring, ready to be written
--   as a file.
encodePng :: PngSavable a => Image a -> ByteString

-- | Encode a png using some metadatas. The following metadata keys will be
--   stored in a <tt>tEXt</tt> field :
--   
--   <ul>
--   <li><a>Title</a></li>
--   <li><a>Description</a></li>
--   <li><a>Author</a></li>
--   <li><a>Copyright</a></li>
--   <li><a>Software</a></li>
--   <li><a>Comment</a></li>
--   <li><a>Disclaimer</a></li>
--   <li><a>Source</a></li>
--   <li><a>Warning</a></li>
--   <li><a>Unknown</a> using the key present in the constructor.</li>
--   </ul>
--   
--   the followings metadata will bes tored in the <tt>gAMA</tt> chunk.
--   
--   <ul>
--   <li><a>Gamma</a></li>
--   </ul>
--   
--   The followings metadata will be stored in a <tt>pHYs</tt> chunk
--   
--   <ul>
--   <li><a>DpiX</a></li>
--   <li><a>DpiY</a></li>
--   </ul>
encodePngWithMetadata :: PngSavable a => Metadatas -> Image a -> ByteString

-- | Helper function trying to load a png file from a file on disk.
readPng :: FilePath -> IO (Either String DynamicImage)

-- | Transform a raw png image to an image, without modifying the
--   underlying pixel type. If the image is greyscale and &lt; 8 bits, a
--   transformation to RGBA8 is performed. This should change in the
--   future. The resulting image let you manage the pixel types.
--   
--   This function can output the following images:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageY16</a></li>
--   <li><a>ImageYA8</a></li>
--   <li><a>ImageYA16</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGB16</a></li>
--   <li><a>ImageRGBA8</a></li>
--   <li><a>ImageRGBA16</a></li>
--   </ul>
decodePng :: ByteString -> Either String DynamicImage

-- | Helper function to directly write an image as a png on disk.
writePng :: PngSavable pixel => FilePath -> Image pixel -> IO ()

-- | Encode a paletted image as a color indexed 8-bit PNG. the palette must
--   have between 1 and 256 values in it. Accepts <a>PixelRGB8</a> and
--   <a>PixelRGBA8</a> as palette pixel type
encodePalettedPng :: PngPaletteSaveable a => Image a -> Image Pixel8 -> Either String ByteString

-- | Encode a dynamic image in PNG if possible, supported images are:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageY16</a></li>
--   <li><a>ImageYA8</a></li>
--   <li><a>ImageYA16</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGB16</a></li>
--   <li><a>ImageRGBA8</a></li>
--   <li><a>ImageRGBA16</a></li>
--   </ul>
encodeDynamicPng :: DynamicImage -> Either String ByteString

-- | Write a dynamic image in a .png image file if possible. The same
--   restriction as encodeDynamicPng apply.
writeDynamicPng :: FilePath -> DynamicImage -> IO (Either String Bool)

-- | Try to load a .tga file from disk.
readTGA :: FilePath -> IO (Either String DynamicImage)

-- | Transform a raw tga image to an image, without modifying the
--   underlying pixel type.
--   
--   This function can output the following images:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGBA8</a></li>
--   </ul>
decodeTga :: ByteString -> Either String DynamicImage

-- | This typeclass determine if a pixel can be saved in the TGA format.
class TgaSaveable a

-- | Transform a compatible image to a raw bytestring representing a Targa
--   file.
encodeTga :: TgaSaveable px => Image px -> ByteString

-- | Helper function to directly write an image a tga on disk.
writeTga :: TgaSaveable pixel => FilePath -> Image pixel -> IO ()

-- | Helper function trying to load tiff file from a file on disk.
readTiff :: FilePath -> IO (Either String DynamicImage)

-- | Class defining which pixel types can be serialized in a Tiff file.
class (Pixel px) => TiffSaveable px

-- | Decode a tiff encoded image while preserving the underlying pixel type
--   (except for Y32 which is truncated to 16 bits).
--   
--   This function can output the following images:
--   
--   <ul>
--   <li><a>ImageY8</a></li>
--   <li><a>ImageY16</a></li>
--   <li><a>ImageY32</a></li>
--   <li><a>ImageYF</a></li>
--   <li><a>ImageYA8</a></li>
--   <li><a>ImageYA16</a></li>
--   <li><a>ImageRGB8</a></li>
--   <li><a>ImageRGB16</a></li>
--   <li><a>ImageRGBA8</a></li>
--   <li><a>ImageRGBA16</a></li>
--   <li><a>ImageCMYK8</a></li>
--   <li><a>ImageCMYK16</a></li>
--   </ul>
decodeTiff :: ByteString -> Either String DynamicImage

-- | Transform an image into a Tiff encoded bytestring, ready to be written
--   as a file.
encodeTiff :: forall px. TiffSaveable px => Image px -> ByteString

-- | Helper function to directly write an image as a tiff on disk.
writeTiff :: TiffSaveable pixel => FilePath -> Image pixel -> IO ()

-- | Try to load a .pic file. The colorspace can only be RGB with floating
--   point precision.
readHDR :: FilePath -> IO (Either String DynamicImage)

-- | Decode an HDR (radiance) image, the resulting image can be:
--   
--   <ul>
--   <li><a>ImageRGBF</a></li>
--   </ul>
decodeHDR :: ByteString -> Either String DynamicImage

-- | Encode an High dynamic range image into a radiance image file format.
--   Alias for encodeRawHDR
encodeHDR :: Image PixelRGBF -> ByteString

-- | Write an High dynamic range image into a radiance image file on disk.
writeHDR :: FilePath -> Image PixelRGBF -> IO ()

-- | Define which palette creation method is used.
data PaletteCreationMethod

-- | MedianMeanCut method, provide the best results (visualy) at the cost
--   of increased calculations.
MedianMeanCut :: PaletteCreationMethod

-- | Very fast algorithm (one pass), doesn't provide good looking results.
Uniform :: PaletteCreationMethod

-- | To specify how the palette will be created.
data PaletteOptions
PaletteOptions :: PaletteCreationMethod -> Bool -> Int -> PaletteOptions

-- | Algorithm used to find the palette
[paletteCreationMethod] :: PaletteOptions -> PaletteCreationMethod

-- | Do we want to apply the dithering to the image. Enabling it often
--   reduce compression ratio but enhance the perceived quality of the
--   final image.
[enableImageDithering] :: PaletteOptions -> Bool

-- | Maximum number of color we want in the palette
[paletteColorCount] :: PaletteOptions -> Int

-- | Reduces an image to a color palette according to <a>PaletteOptions</a>
--   and returns the <i>indices image</i> along with its <a>Palette</a>.
palettize :: PaletteOptions -> Image PixelRGB8 -> (Image Pixel8, Palette)

-- | The main type of this package, one that most functions work on, is
--   Image.
--   
--   Parameterized by the underlying pixel format it forms a rigid type. If
--   you wish to store images of different or unknown pixel formats use
--   <a>DynamicImage</a>.
--   
--   Image is essentially a rectangular pixel buffer of specified width and
--   height. The coordinates are assumed to start from the upper-left
--   corner of the image, with the horizontal position first and vertical
--   second.
data Image a
Image :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Vector (PixelBaseComponent a) -> Image a

-- | Width of the image in pixels
[imageWidth] :: Image a -> {-# UNPACK #-} !Int

-- | Height of the image in pixels.
[imageHeight] :: Image a -> {-# UNPACK #-} !Int

-- | Image pixel data. To extract pixels at a given position you should use
--   the helper functions.
--   
--   Internally pixel data is stored as consecutively packed lines from top
--   to bottom, scanned from left to right within individual lines, from
--   first to last color component within each pixel.
[imageData] :: Image a -> Vector (PixelBaseComponent a)

-- | Image type enumerating all predefined pixel types. It enables loading
--   and use of images of different pixel types.
data DynamicImage

-- | A greyscale image.
ImageY8 :: Image Pixel8 -> DynamicImage

-- | A greyscale image with 16bit components
ImageY16 :: Image Pixel16 -> DynamicImage

-- | A greyscale image with 32bit components
ImageY32 :: Image Pixel32 -> DynamicImage

-- | A greyscale HDR image
ImageYF :: Image PixelF -> DynamicImage

-- | An image in greyscale with an alpha channel.
ImageYA8 :: Image PixelYA8 -> DynamicImage

-- | An image in greyscale with alpha channel on 16 bits.
ImageYA16 :: Image PixelYA16 -> DynamicImage

-- | An image in true color.
ImageRGB8 :: Image PixelRGB8 -> DynamicImage

-- | An image in true color with 16bit depth.
ImageRGB16 :: Image PixelRGB16 -> DynamicImage

-- | An image with HDR pixels
ImageRGBF :: Image PixelRGBF -> DynamicImage

-- | An image in true color and an alpha channel.
ImageRGBA8 :: Image PixelRGBA8 -> DynamicImage

-- | A true color image with alpha on 16 bits.
ImageRGBA16 :: Image PixelRGBA16 -> DynamicImage

-- | An image in the colorspace used by Jpeg images.
ImageYCbCr8 :: Image PixelYCbCr8 -> DynamicImage

-- | An image in the colorspace CMYK
ImageCMYK8 :: Image PixelCMYK8 -> DynamicImage

-- | An image in the colorspace CMYK and 16 bits precision
ImageCMYK16 :: Image PixelCMYK16 -> DynamicImage

-- | Type for the palette used in Gif &amp; PNG files.
type Palette = Image PixelRGB8

-- | Definition of pixels used in images. Each pixel has a color space, and
--   a representative component (Word8 or Float).
class (Storable (PixelBaseComponent a), Num (PixelBaseComponent a), Eq a) => Pixel a where {
    
    -- | Type of the pixel component, "classical" images would have Word8 type
    --   as their PixelBaseComponent, HDR image would have Float for instance
    type family PixelBaseComponent a :: *;
}

-- | Call the function for every component of the pixels. For example for
--   RGB pixels mixWith is declared like this:
--   
--   <pre>
--   mixWith f (PixelRGB8 ra ga ba) (PixelRGB8 rb gb bb) =
--      PixelRGB8 (f 0 ra rb) (f 1 ga gb) (f 2 ba bb)
--   </pre>
mixWith :: Pixel a => (Int -> PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> a -> a -> a

-- | Extension of the <a>mixWith</a> which separate the treatment of the
--   color components of the alpha value (transparency component). For
--   pixel without alpha components, it is equivalent to mixWith.
--   
--   <pre>
--   mixWithAlpha f fa (PixelRGBA8 ra ga ba aa) (PixelRGB8 rb gb bb ab) =
--      PixelRGBA8 (f 0 ra rb) (f 1 ga gb) (f 2 ba bb) (fa aa ab)
--   </pre>
mixWithAlpha :: Pixel a => (Int -> PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> (PixelBaseComponent a -> PixelBaseComponent a -> PixelBaseComponent a) -> a -> a -> a

-- | Return the opacity of a pixel, if the pixel has an alpha layer, return
--   the alpha value. If the pixel doesn't have an alpha value, return a
--   value representing the opaqueness.
pixelOpacity :: Pixel a => a -> PixelBaseComponent a

-- | Return the number of components of the pixel
componentCount :: Pixel a => a -> Int

-- | Apply a function to each component of a pixel. If the color type
--   possess an alpha (transparency channel), it is treated like the other
--   color components.
colorMap :: Pixel a => (PixelBaseComponent a -> PixelBaseComponent a) -> a -> a

-- | Calculate the index for the begining of the pixel
pixelBaseIndex :: Pixel a => Image a -> Int -> Int -> Int

-- | Calculate theindex for the begining of the pixel at position x y
mutablePixelBaseIndex :: Pixel a => MutableImage s a -> Int -> Int -> Int

-- | Extract a pixel at a given position, (x, y), the origin is assumed to
--   be at the corner top left, positive y to the bottom of the image
pixelAt :: Pixel a => Image a -> Int -> Int -> a

-- | Same as pixelAt but for mutable images.
readPixel :: (Pixel a, PrimMonad m) => MutableImage (PrimState m) a -> Int -> Int -> m a

-- | Write a pixel in a mutable image at position x y
writePixel :: (Pixel a, PrimMonad m) => MutableImage (PrimState m) a -> Int -> Int -> a -> m ()

-- | Unsafe version of pixelAt, read a pixel at the given index without
--   bound checking (if possible). The index is expressed in number
--   (PixelBaseComponent a)
unsafePixelAt :: Pixel a => Vector (PixelBaseComponent a) -> Int -> a

-- | Unsafe version of readPixel, read a pixel at the given position
--   without bound checking (if possible). The index is expressed in number
--   (PixelBaseComponent a)
unsafeReadPixel :: (Pixel a, PrimMonad m) => STVector (PrimState m) (PixelBaseComponent a) -> Int -> m a

-- | Unsafe version of writePixel, write a pixel at the given position
--   without bound checking. This can be _really_ unsafe. The index is
--   expressed in number (PixelBaseComponent a)
unsafeWritePixel :: (Pixel a, PrimMonad m) => STVector (PrimState m) (PixelBaseComponent a) -> Int -> a -> m ()

-- | Type alias for 8bit greyscale pixels. For simplicity, greyscale pixels
--   use plain numbers instead of a separate type.
type Pixel8 = Word8

-- | Type alias for 16bit greyscale pixels.
type Pixel16 = Word16

-- | Type alias for 32bit greyscale pixels.
type Pixel32 = Word32

-- | Type alias for 32bit floating point greyscale pixels. The standard
--   bounded value range is mapped to the closed interval [0,1] i.e.
--   
--   <pre>
--   map promotePixel [0, 1 .. 255 :: Pixel8] == [0/255, 1/255 .. 1.0 :: PixelF]
--   </pre>
type PixelF = Float

-- | Pixel type storing 8bit Luminance (Y) and alpha (A) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Luminance</li>
--   <li>Alpha</li>
--   </ul>
data PixelYA8
PixelYA8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelYA8

-- | Pixel type storing 16bit Luminance (Y) and alpha (A) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Luminance</li>
--   <li>Alpha</li>
--   </ul>
data PixelYA16
PixelYA16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelYA16

-- | Classic pixel type storing 8bit red, green and blue (RGB) information.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGB8
PixelRGB8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelRGB8

-- | Pixel type storing 16bit red, green and blue (RGB) information. Values
--   are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGB16
PixelRGB16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelRGB16

-- | HDR pixel type storing floating point 32bit red, green and blue (RGB)
--   information. Same value range and comments apply as for <a>PixelF</a>.
--   Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   </ul>
data PixelRGBF
PixelRGBF :: {-# UNPACK #-} !PixelF -> {-# UNPACK #-} !PixelF -> {-# UNPACK #-} !PixelF -> PixelRGBF

-- | Classical pixel type storing 8bit red, green, blue and alpha (RGBA)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   <li>Alpha</li>
--   </ul>
data PixelRGBA8
PixelRGBA8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelRGBA8

-- | Pixel type storing 16bit red, green, blue and alpha (RGBA)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Red</li>
--   <li>Green</li>
--   <li>Blue</li>
--   <li>Alpha</li>
--   </ul>
data PixelRGBA16
PixelRGBA16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelRGBA16

-- | Pixel type storing 8bit luminance, blue difference and red difference
--   (YCbCr) information. Values are stored in the following order:
--   
--   <ul>
--   <li>Y (luminance)</li>
--   <li>Cb</li>
--   <li>Cr</li>
--   </ul>
data PixelYCbCr8
PixelYCbCr8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelYCbCr8

-- | Pixel type storing 8bit cyan, magenta, yellow and black (CMYK)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Cyan</li>
--   <li>Magenta</li>
--   <li>Yellow</li>
--   <li>Black</li>
--   </ul>
data PixelCMYK8
PixelCMYK8 :: {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> {-# UNPACK #-} !Pixel8 -> PixelCMYK8

-- | Pixel type storing 16bit cyan, magenta, yellow and black (CMYK)
--   information. Values are stored in the following order:
--   
--   <ul>
--   <li>Cyan</li>
--   <li>Magenta</li>
--   <li>Yellow</li>
--   <li>Black</li>
--   </ul>
data PixelCMYK16
PixelCMYK16 :: {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> {-# UNPACK #-} !Pixel16 -> PixelCMYK16

-- | Import a image from an unsafe pointer The pointer must have a size of
--   width * height * componentCount px
imageFromUnsafePtr :: forall px. (Pixel px, PixelBaseComponent px ~ Word8) => Int -> Int -> ForeignPtr Word8 -> Image px
instance Codec.Picture.Decimable Codec.Picture.Types.Pixel16 Codec.Picture.Types.Pixel8
instance Codec.Picture.Decimable Codec.Picture.Types.Pixel32 Codec.Picture.Types.Pixel16
instance Codec.Picture.Decimable Codec.Picture.Types.Pixel32 Codec.Picture.Types.Pixel8
instance Codec.Picture.Decimable Codec.Picture.Types.PixelYA16 Codec.Picture.Types.PixelYA8
instance Codec.Picture.Decimable Codec.Picture.Types.PixelRGB16 Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Decimable Codec.Picture.Types.PixelRGBA16 Codec.Picture.Types.PixelRGBA8
instance Codec.Picture.Decimable Codec.Picture.Types.PixelCMYK16 Codec.Picture.Types.PixelCMYK8
instance Codec.Picture.Decimable Codec.Picture.Types.PixelF Codec.Picture.Types.Pixel8
instance Codec.Picture.Decimable Codec.Picture.Types.PixelF Codec.Picture.Types.Pixel16
instance Codec.Picture.Decimable Codec.Picture.Types.PixelRGBF Codec.Picture.Types.PixelRGB8
instance Codec.Picture.Decimable Codec.Picture.Types.PixelRGBF Codec.Picture.Types.PixelRGB16
