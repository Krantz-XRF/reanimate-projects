-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Catching all exceptions from within an enclosed computation
--   
--   Catching all exceptions raised within an enclosed computation, while
--   remaining responsive to (external) asynchronous exceptions. For more
--   information on the technique, please see:
--   <a>https://www.fpcomplete.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions</a>
@package enclosed-exceptions
@version 1.0.3


-- | The purpose of this module is to allow you to capture all exceptions
--   originating from within the enclosed computation, while still reacting
--   to asynchronous exceptions aimed at the calling thread.
--   
--   This way, you can be sure that the function that calls, for example,
--   <tt><a>catchAny</a></tt>, will still respond to
--   <tt><a>ThreadKilled</a></tt> or <tt><tt>Timeout</tt></tt> events
--   raised by another thread (with <tt><a>throwTo</a></tt>), while
--   capturing all exceptions, synchronous or asynchronous, resulting from
--   the execution of the enclosed computation.
--   
--   One particular use case is to allow the safe execution of code from
--   various libraries (which you do not control), capturing any faults
--   that might occur, while remaining responsive to higher level events
--   and control actions.
--   
--   This library was originally developed by Michael Snoyman for the
--   <tt>ClassyPrelude</tt> library, and was latter 'spun-off' into a
--   separate independent package.
--   
--   For a more detailed explanation of the motivation behind this
--   functions, see:
--   
--   
--   <a>https://www.fpcomplete.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions</a>
--   
--   and
--   
--   
--   <a>https://groups.google.com/forum/#!topic/haskell-cafe/e9H2I-3uVJE</a>
module Control.Exception.Enclosed

-- | A version of <a>catch</a> which is specialized for any exception. This
--   simplifies usage as no explicit type signatures are necessary.
--   
--   Note that since version 0.5.9, this function now has proper support
--   for asynchronous exceptions, by only catching exceptions generated by
--   the internal (enclosed) action.
--   
--   Since 0.5.6
catchAny :: MonadBaseControl IO m => m a -> (SomeException -> m a) -> m a

-- | A version of <a>handle</a> which is specialized for any exception.
--   This simplifies usage as no explicit type signatures are necessary.
--   
--   Note that since version 0.5.9, this function now has proper support
--   for asynchronous exceptions, by only catching exceptions generated by
--   the internal (enclosed) action.
--   
--   Since 0.5.6
handleAny :: MonadBaseControl IO m => (SomeException -> m a) -> m a -> m a

-- | A version of <a>try</a> which is specialized for any exception. This
--   simplifies usage as no explicit type signatures are necessary.
--   
--   Note that since version 0.5.9, this function now has proper support
--   for asynchronous exceptions, by only catching exceptions generated by
--   the internal (enclosed) action.
--   
--   Since 0.5.6
tryAny :: MonadBaseControl IO m => m a -> m (Either SomeException a)

-- | An extension to <tt>catch</tt> which ensures that the return value is
--   fully evaluated. See <tt>tryAny</tt>.
--   
--   Since 1.0.1
catchDeep :: (Exception e, NFData a, MonadBaseControl IO m) => m a -> (e -> m a) -> m a

-- | An extension to <tt>catchAny</tt> which ensures that the return value
--   is fully evaluated. See <tt>tryAnyDeep</tt>.
--   
--   Since 0.5.9
catchAnyDeep :: (NFData a, MonadBaseControl IO m) => m a -> (SomeException -> m a) -> m a

-- | <pre>
--   flip catchAnyDeep
--   </pre>
--   
--   Since 0.5.6
handleAnyDeep :: (NFData a, MonadBaseControl IO m) => (SomeException -> m a) -> m a -> m a

-- | an extension to <tt>try</tt> which ensures that the return value is
--   fully evaluated. in other words, if you get a <tt>right</tt> response
--   here, you can be confident that using it will not result in another
--   exception.
--   
--   Since 1.0.1
tryDeep :: (Exception e, NFData a, MonadBaseControl IO m) => m a -> m (Either e a)

-- | an extension to <tt>tryany</tt> which ensures that the return value is
--   fully evaluated. in other words, if you get a <tt>right</tt> response
--   here, you can be confident that using it will not result in another
--   exception.
--   
--   Since 0.5.9
tryAnyDeep :: (NFData a, MonadBaseControl IO m) => m a -> m (Either SomeException a)

-- | A version of <a>catch</a> which is specialized for IO exceptions. This
--   simplifies usage as no explicit type signatures are necessary.
--   
--   Since 0.5.6
catchIO :: MonadBaseControl IO m => m a -> (IOException -> m a) -> m a

-- | A version of <a>handle</a> which is specialized for IO exceptions.
--   This simplifies usage as no explicit type signatures are necessary.
--   
--   Since 0.5.6
handleIO :: MonadBaseControl IO m => (IOException -> m a) -> m a -> m a

-- | A version of <a>try</a> which is specialized for IO exceptions. This
--   simplifies usage as no explicit type signatures are necessary.
--   
--   Since 0.5.6
tryIO :: MonadBaseControl IO m => m a -> m (Either IOException a)

-- | Since 0.5.6
asIOException :: IOException -> IOException

-- | Since 0.5.6
asSomeException :: SomeException -> SomeException
