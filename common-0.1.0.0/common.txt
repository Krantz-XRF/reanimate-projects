-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Common utilities for Reanimate.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/Krantz-XRF/reanimate-projects/tree/master/common#readme</a>
@package common
@version 0.1.0.0


module Common.Animation.Effects

-- | Add a white background for the given animation.
addWhiteBkg :: SVG -> SVG

-- | Fade out the animation after it stops.
fadeToEnd :: Time -> Animation -> Animation

-- | Linear interpolation (for position) between 2 key frames.
lerpSVG :: SVG -> SVG -> Time -> SVG

-- | Linear interpolation between 2 colours.
lerpColour :: Texture -> Texture -> Time -> Texture

-- | Make a pure translation animation.
translationAnim :: SVG -> SVG -> Animation

-- | Wiggle = S-Curve, sin, S-Curve. Copied from
--   reanimate<i>examples</i>tut_glue_latex.hs
wiggleS :: Signal

-- | Make the effect around a new center. The coordinates of the new center
--   should be provided as relative.
aroundE :: RPoint -> Effect -> Effect

-- | Highlight = Wiggle (Rotate) + Scale. Copied from
--   reanimate<i>examples</i>tut_glue_latex.hs
highlightE :: Double -> Effect

-- | Make parallel animation.
parallel :: Foldable f => f Animation -> Animation

-- | Make parallel animation.
sequential :: Foldable f => f Animation -> Animation


module Common.Bifunctor

-- | Fold <a>Fix</a>. Copied from data-fix 0.3.0. Package "data-fix" uses
--   <a>Functor</a> instead of <a>Bifunctor</a>.
foldFix :: Bifunctor f => (f b a -> b) -> Fix f a -> b

-- | Scan <a>Fix</a>.
scanFix :: Bifunctor f => (f b a -> b) -> Fix f a -> Fix f b

-- | Scan <a>Fix</a> with <a>Lens</a>.
scanFixIdx :: Bifunctor f => Lens s t a b -> (f b a -> b) -> Fix f s -> Fix f t


module Common.HexColour

-- | The <a>rgba</a> Quasi-Quoter. Accepted format: RGB, RGBA, RRGGBB,
--   RRGGBBAA
rgba :: QuasiQuoter

-- | All the things that can be converted from a <a>PixelRGBA8</a>.
class FromRGBA8 a

-- | Convert from <a>PixelRGBA8</a>.
fromRGBA8 :: FromRGBA8 a => PixelRGBA8 -> a
instance Common.HexColour.FromRGBA8 Codec.Picture.Types.PixelRGBA8
instance Common.HexColour.FromRGBA8 Graphics.SvgTree.Types.Basic.Texture
instance Common.HexColour.FromRGBA8 Skylighting.Types.Color
instance Common.HexColour.FromRGBA8 a => Common.HexColour.FromRGBA8 (GHC.Maybe.Maybe a)


module Common.Linear

-- | Types which allows for linear interpolation.
class Linear a

-- | Linear interpolation. 0 for departure, 1 for destination.
lerp :: Linear a => Double -> a -> a -> a
instance Common.Linear.Linear Codec.Picture.Types.Pixel8
instance Common.Linear.Linear GHC.Types.Double
instance Common.Linear.Linear Codec.Picture.Types.PixelRGBA8
instance Linear.Vector.Additive f => Common.Linear.Linear (f GHC.Types.Double)


module Common.Object.SyntaxHighlight.Theme

-- | Tomorrow theme.
tomorrow :: Style


module Common.Object.SyntaxHighlight

-- | Evaluate to the first, with the second as a type hint.
asIf :: a -> a -> a

-- | Coerce the data, as if it were converted using the given converter.
coerceAsIf :: Coercible a b => (a -> b) -> a -> b

-- | Default tokenizer config: with default syntax map, without trace
--   output.
defaultTokenizerConfig :: TokenizerConfig

-- | Highlight with a specified language syntax. Use <a>lookupSyntax</a> to
--   find a proper <a>Syntax</a>.
highlight :: Syntax -> Text -> [[SVG]]

-- | Highlight code in some language.
highlightIn :: Text -> Text -> [[SVG]]

-- | Highlight Haskell code.
highlightHs :: Text -> [[SVG]]

-- | Custom highlight with maximum flexibility.
highlightWith :: TokenizerConfig -> Style -> Syntax -> Text -> Either String [[SVG]]

-- | Escape LaTeX text. Stolen from
--   <tt>Skylighting.Format.LaTeX.escapeLaTeX</tt>.
escapeLaTeX :: Text -> Text


module Common.Object.Transform

-- | Allow rendering for groups of objects.
class GroupRender a

-- | Render a group of objects to a group of SVGs. The group structure
--   should be taken into consideration while rendering. e.g. Group of
--   <a>Text</a> can be rendered using <a>latexChunks</a>.
renderGroup :: (GroupRender a, Traversable t) => t a -> t SVG

-- | Create a group of objects, translation of each lifted to <a>Object</a>
--   level.
oNewGroup :: forall a t s. (Traversable t, GroupRender a) => t a -> Scene s (t (Object s SVG))

-- | Create a group of objects, scaled as a group, translation of each
--   lifted to <a>Object</a> level.
oNewGroupScaled :: forall a t s. (Traversable t, GroupRender a) => Double -> t a -> Scene s (t (Object s SVG))

-- | New object, with its translation lifted to <a>Object</a> level.
oNewCentered :: SVG -> Scene s (Object s SVG)

-- | Group alignment, given a base, align the second parameter according to
--   the base.
type GroupAlignment t t' s a b = t (Object s a) -> t' (Object s b) -> Scene s ()

-- | Apply some <a>GroupAlignment</a>s.
applyAlignment :: (Traversable t, Traversable t') => [GroupAlignment t t' s a b] -> t (Object s a) -> t' (Object s b) -> Scene s ()

-- | Scaled by a factor.
scaled :: (Traversable t, Traversable t') => Double -> GroupAlignment t t' s a b

-- | <a>Traversal</a> of all four margins.
allMargins :: Traversal (a, a, a, a) (b, b, b, b) a b

-- | Set margin.
withMargin :: (Traversable t, Traversable t') => Coord -> GroupAlignment t t' s a b

-- | Aligned according to the left boundary (minimum X).
leftAligned :: (Traversable t, Traversable t') => GroupAlignment t t' s a b

-- | Aligned according to the right boundary (maximum X).
rightAligned :: (Traversable t, Traversable t') => GroupAlignment t t' s a b

-- | Aligned according to the horizontal center line (average of min/max
--   X).
xCentered :: (Traversable t, Traversable t') => GroupAlignment t t' s a b

-- | Placed below the alignment base.
placedBelow :: (Traversable t, Traversable t') => GroupAlignment t t' s a b

-- | Aligned according to the bottom boundary (minimum Y).
bottomAligned :: (Traversable t, Traversable t') => GroupAlignment t t' s a b

-- | Aligned according to the top boundary (minimum Y).
topAligned :: (Traversable t, Traversable t') => GroupAlignment t t' s a b

-- | Aligned according to the vertical center line (average of min/max Y).
yCentered :: (Traversable t, Traversable t') => GroupAlignment t t' s a b

-- | Description for key frame animations.
--   
--   <b>Note</b>:
--   
--   <ul>
--   <li><a>IsString</a> instance provided here for conveniently creating
--   new objects.</li>
--   <li>The following objects are collected as the base for
--   alignment:<ul><li>Objects that vanished, or</li><li>Source objects for
--   transformations</li></ul></li>
--   <li>The following objects are collected as the target for
--   alignment:<ul><li>Objects newly created, or</li><li>Target objects for
--   transformations</li></ul></li>
--   </ul>
data Trans a b

-- | Object newly created in this frame.
New :: b -> Trans a b

-- | Previous object vanishing in this frame.
Vanish :: a -> Trans a b

-- | Object transformaton in this frame.
(::=>) :: [a] -> b -> Trans a b

-- | Short cut for single object transformaton in this frame.
pattern (:=>) :: a -> b -> Trans a b

-- | Traverse the origins of the <a>Trans</a>.
transOrigin :: Traversal (Trans a b) (Trans a' b) a a'

-- | Key frame animation, with automatic creation for new objects.
--   
--   <b>Warning</b>: if alignment base (see <a>Trans</a> for details) is
--   empty, then all the alignment functions provided in this module would
--   crash your program. In this case, custom (ad-hoc) alignment functions
--   might be useful. Or, to specify a custom alignment base <tt>bs</tt>,
--   use <tt>const (alignment bs)</tt> instead of <tt>alignment</tt>.
--   
--   <b>Note</b>: if the target object utilise <tt>OverloadedStrings</tt>
--   via <a>IsString</a>, the type becomes ambiguous. Use
--   <tt>TypeApplications</tt> for this situation:
--   
--   <pre>
--   transformObject' @ObjType alignments transformations
--   </pre>
transformObject' :: GroupRender t => [GroupAlignment (Compose [] []) (Compose [] (Trans (Object s a))) s a SVG] -> [Trans (Object s a) t] -> Scene s [Object s SVG]

-- | Key frame animation.
--   
--   <b>Warning</b>: if alignment base (see <a>Trans</a> for details) is
--   empty, then all the alignment functions provided in this module would
--   crash your program. In this case, custom (ad-hoc) alignment functions
--   might be useful. Or, to specify a custom alignment base <tt>bs</tt>,
--   use <tt>const (alignment bs)</tt> instead of <tt>alignment</tt>.
transformObject :: [Trans (Object s a) [Object s b]] -> Scene s ()

-- | Key frame animation, but without hiding the original.
dupFromObject :: Renderable a => [Trans (Object s a) [Object s b]] -> Scene s ()

-- | Duplicate the object, make it independent from the original.
dupObject :: Renderable a => Object s a -> Scene s (Object s a)

-- | Read the overall translation of an <a>Object</a> group.
readGroupTrans :: Traversable t => t (Object s a) -> Scene s (V2 Double)
instance Data.Traversable.Traversable (Common.Object.Transform.Trans a)
instance Data.Foldable.Foldable (Common.Object.Transform.Trans a)
instance GHC.Base.Functor (Common.Object.Transform.Trans a)
instance (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (Common.Object.Transform.Trans a b)
instance Data.String.IsString b => Data.String.IsString (Common.Object.Transform.Trans a b)


module Common.Object.Effect

-- | A potentialy partial box.
data Box
Box :: Coord -> Coord -> Double -> Double -> Coord -> PixelRGBA8 -> Box
[_boxWidth] :: Box -> Coord
[_boxHeight] :: Box -> Coord
[_boxStart] :: Box -> Double
[_boxEnd] :: Box -> Double
[_boxStroke] :: Box -> Coord
[_boxColour] :: Box -> PixelRGBA8
boxWidth :: Lens' Box Coord
boxHeight :: Lens' Box Coord
boxStart :: Lens' Box Double
boxEnd :: Lens' Box Double
boxStroke :: Lens' Box Coord
boxColour :: Lens' Box PixelRGBA8

-- | Create a new box around the target.
oBoxNewOver :: Object s a -> PixelRGBA8 -> Scene s (Object s Box)

-- | Create a new box around a target group.
oBoxNewOverMany :: Traversable t => t (Object s a) -> PixelRGBA8 -> Scene s (Object s Box)

-- | Grow the <a>Box</a>.
oBoxGrow :: Duration -> Object s Box -> Scene s ()

-- | Erase the <a>Box</a>.
oBoxErase :: Duration -> Object s Box -> Scene s ()

-- | Draw a partial box, provided a starting point and an ending point.
partialBox :: Coord -> Coord -> Double -> Double -> SVG

-- | Wiggle the <a>Object</a>.
oWiggle :: Traversable t => t (Object s a) -> Scene s ()
instance GHC.Show.Show a => GHC.Show.Show (Common.Object.Effect.BB a)
instance (GHC.Classes.Ord a, GHC.Num.Num a) => GHC.Base.Semigroup (Common.Object.Effect.BB a)
instance Reanimate.Scene.Object.Renderable Common.Object.Effect.Box
instance GHC.Classes.Eq Common.Object.Effect.VertexInfo
instance GHC.Show.Show Common.Object.Effect.VertexInfo
instance GHC.Classes.Eq Common.Object.Effect.Box
instance GHC.Show.Show Common.Object.Effect.Box


module Common.Object.Types

-- | Center a group of objects.
centerAsGroup :: (Functor t, Foldable t) => t SVG -> t SVG

-- | Any <a>Renderable</a> object.
data AnyRenderable
AnyRenderable :: a -> AnyRenderable

-- | A group of renderable objects, rendered using <a>renderGroup</a>.
newtype ObjectGroup a
ObjectGroup :: [a] -> ObjectGroup a
[unwrapObjectGroup] :: ObjectGroup a -> [a]

-- | Code chunks typeset by XeLaTeX in type writer font.
newtype CodeChunk
CodeChunk :: Text -> CodeChunk
[unwrapCodeChunk] :: CodeChunk -> Text

-- | LaTeX inline math formulae.
newtype MathChunk
MathChunk :: Text -> MathChunk
[unwrapMathChunk] :: MathChunk -> Text

-- | Code blocks in some programming language. Highlighted by Skylighting.
data CodeBlock
CodeBlock :: Text -> Text -> CodeBlock
[codeLanguage] :: CodeBlock -> Text
[codeText] :: CodeBlock -> Text

-- | TeX codes.
newtype TeX
TeX :: Text -> TeX
[unwrapTeXCode] :: TeX -> Text

-- | Renderable object, treated as a line.
data Line a
LeftAligned :: a -> Line a
Centered :: a -> Line a
RightAligned :: a -> Line a

-- | Lines typeset by XeLaTeX in normal font.
type TextLine = Line TeX

-- | Lines wrapping any <a>Renderable</a>.
type AnyLine = Line AnyRenderable
layoutLines :: Traversable t => t (Line SVG) -> t SVG

-- | Make a rounded rectangle.
roundedRect :: Double -> Double -> Double -> SVG

-- | Make a rounded square.
roundedSquare :: Double -> Double -> SVG

-- | Text bubble (tips), basically lines surrounded by a rounded rectangle.
newtype Bubble a
Bubble :: [a] -> Bubble a
[unwrapBubble] :: Bubble a -> [a]

-- | Create a new text bubble, attached to an existing object.
oNewBubble :: forall x a s. GroupRender x => Object s a -> [x] -> Scene s (Object s SVG)

-- | Pop out a new text bubble (for a given duration), attached to an
--   existing object.
oPopBubble :: forall x a s. GroupRender x => Duration -> Object s a -> [x] -> Scene s ()

-- | <a>CodeBlock</a> in a <a>Bubble</a>.
type CodeBubble = Bubble (Line CodeBlock)

-- | Construct a <a>CodeBubble</a>.
pattern CodeBubble :: Text -> Text -> CodeBubble

-- | Construct a <a>CodeBubble</a> in Haskell language.
pattern HaskellBubble :: Text -> CodeBubble
instance GHC.Classes.Eq a => GHC.Classes.Eq (Common.Object.Types.ObjectGroup a)
instance GHC.Show.Show a => GHC.Show.Show (Common.Object.Types.ObjectGroup a)
instance Data.String.IsString Common.Object.Types.CodeChunk
instance GHC.Classes.Ord Common.Object.Types.CodeChunk
instance GHC.Classes.Eq Common.Object.Types.CodeChunk
instance GHC.Show.Show Common.Object.Types.CodeChunk
instance Data.String.IsString Common.Object.Types.MathChunk
instance GHC.Classes.Ord Common.Object.Types.MathChunk
instance GHC.Classes.Eq Common.Object.Types.MathChunk
instance GHC.Show.Show Common.Object.Types.MathChunk
instance GHC.Classes.Ord Common.Object.Types.CodeBlock
instance GHC.Classes.Eq Common.Object.Types.CodeBlock
instance GHC.Show.Show Common.Object.Types.CodeBlock
instance Data.String.IsString Common.Object.Types.TeX
instance GHC.Classes.Ord Common.Object.Types.TeX
instance GHC.Classes.Eq Common.Object.Types.TeX
instance GHC.Show.Show Common.Object.Types.TeX
instance Data.Foldable.Foldable Common.Object.Types.Line
instance Data.Traversable.Traversable Common.Object.Types.Line
instance GHC.Base.Functor Common.Object.Types.Line
instance GHC.Classes.Ord a => GHC.Classes.Ord (Common.Object.Types.Line a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Common.Object.Types.Line a)
instance GHC.Show.Show a => GHC.Show.Show (Common.Object.Types.Line a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Common.Object.Types.Bubble a)
instance GHC.Show.Show a => GHC.Show.Show (Common.Object.Types.Bubble a)
instance Common.Object.Transform.GroupRender a => Reanimate.Scene.Object.Renderable (Common.Object.Types.Bubble a)
instance Data.String.IsString a => Data.String.IsString (Common.Object.Types.Line a)
instance Reanimate.Scene.Object.Renderable a => Common.Object.Transform.GroupRender (Common.Object.Types.Line a)
instance Reanimate.Scene.Object.Renderable Common.Object.Types.TeX
instance Reanimate.Scene.Object.Renderable Common.Object.Types.CodeBlock
instance Common.Object.Transform.GroupRender Common.Object.Types.MathChunk
instance Common.Object.Transform.GroupRender Common.Object.Types.CodeChunk
instance GHC.Exts.IsList (Common.Object.Types.ObjectGroup a)
instance Common.Object.Transform.GroupRender a => Reanimate.Scene.Object.Renderable (Common.Object.Types.ObjectGroup a)
instance Reanimate.Scene.Object.Renderable Common.Object.Types.AnyRenderable


module Common.SVG

-- | Adjust the <tt>strokeWidth</tt> for an <a>SVG</a>.
adjustStrokeWidth :: (Double -> Double) -> SVG -> SVG

-- | Predefined style for paths: every path is counterclockwise, and left
--   paths appear first.
counterclockwiseLR :: [PathCommand] -> [PathCommand]

-- | Predefined style for paths: every path is clockwise, and left paths
--   appear first.
clockwiseLR :: [PathCommand] -> [PathCommand]

-- | Group a series of <a>PathCommand</a>s by subpaths.
groupPath :: [PathCommand] -> [[PathCommand]]

-- | Sort subpaths by some ordering.
sortPathBy :: ([PathCommand] -> [PathCommand] -> Ordering) -> [PathCommand] -> [PathCommand]

-- | Sort subpaths by comparing the results of a key function applied to
--   each element.
--   
--   <tt>sortPathOn f</tt> is equivalent to <tt>sortPathBy (comparing
--   f)</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
--   
--   See also <a>sortOn</a> and <a>sortBy</a>.
--   
--   For predefined key functions, see <a>pathBB</a>, <a>pathCenter</a>,
--   <a>pathRadius</a>.
sortPathOn :: Ord a => ([PathCommand] -> a) -> [PathCommand] -> [PathCommand]

-- | Bounding box of a (sub-) path.
pathBB :: [PathCommand] -> (Coord, Coord, Coord, Coord)

-- | Center of a path.
pathCenter :: [PathCommand] -> RPoint

-- | Radius of a (sub-) path, i.e. maximum distance from the center of the
--   bounding box.
pathRadius :: [PathCommand] -> Coord

-- | Get end points and control points for a path (as
--   <tt>[LineCommand]</tt>).
getPoints :: [LineCommand] -> [RPoint]

-- | Flip the directon of an SVG path (as <tt>[LineCommand]</tt>). Prefer
--   <a>flipPath</a> over roundtripping through <a>toLineCommands</a> and
--   <a>lineToPath</a>.
flipLine :: [LineCommand] -> [LineCommand]

-- | Check whether a (closed) path is clockwise or counterclockwise.
isClockwise :: [RPoint] -> Bool

-- | Make a path clockwise by flipping if it was not.
makeClockwise :: [PathCommand] -> [PathCommand]

-- | Make a path clockwise by flipping if it was not.
makeCounterclockwise :: [PathCommand] -> [PathCommand]

-- | Flip the directon of an SVG path.
flipPath :: [PathCommand] -> [PathCommand]


module Common.Prologue

-- | Common prologue animation.
prologue :: Scene s ()
