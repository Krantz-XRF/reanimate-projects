-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A thin GeoJSON Layer above the aeson library
--   
--   A thin GeoJSON Layer above the aeson library.
--   
--   It currently conforms to version 1.0 of the GeoJSON spec which can be
--   found here:
--   
--   <a>https://tools.ietf.org/html/rfc7946</a>
@package geojson
@version 4.0.2


-- | Basic types for GeoJSON representations.
module Data.Geospatial.Internal.BasicTypes
type Latitude = Double
type Longitude = Double
type Easting = Double
type Northing = Double
type Altitude = Double
data GeoPositionWithoutCRS
GeoEmpty :: GeoPositionWithoutCRS
GeoPointXY :: PointXY -> GeoPositionWithoutCRS
GeoPointXYZ :: PointXYZ -> GeoPositionWithoutCRS
GeoPointXYZM :: PointXYZM -> GeoPositionWithoutCRS
retrieveXY :: GeoPositionWithoutCRS -> PointXY

-- | (<a>GeoPositionWithoutCRS</a> is a catch all for indeterminate CRSs
--   and for expression of positions before a CRS has been determined
data PointXY
PointXY :: !Double -> !Double -> PointXY
[_xyX] :: PointXY -> !Double
[_xyY] :: PointXY -> !Double
data PointXYZ
PointXYZ :: !Double -> !Double -> !Double -> PointXYZ
[_xyzX] :: PointXYZ -> !Double
[_xyzY] :: PointXYZ -> !Double
[_xyzZ] :: PointXYZ -> !Double
data PointXYZM
PointXYZM :: !Double -> !Double -> !Double -> !Double -> PointXYZM
[_xyzmX] :: PointXYZM -> !Double
[_xyzmY] :: PointXYZM -> !Double
[_xyzmZ] :: PointXYZM -> !Double
[_xyzmM] :: PointXYZM -> !Double
newtype DoubleArray
DoubleArray :: [Double] -> DoubleArray
class HasGeoPositionWithoutCRS c_ageb
geoPositionWithoutCRS :: HasGeoPositionWithoutCRS c_ageb => Lens' c_ageb GeoPositionWithoutCRS
type Name = Text
type Code = Int
type Href = Text
type FormatString = Text
type ProjectionType = Text

-- | See Section 4 <i>Bounding Boxes</i> of the GeoJSON spec, The length of
--   the list/array must be 2*n where n is the dimensionality of the
--   position type for the CRS with min values first followed by the max
--   values, wich both the min/max sets following the same axis order as
--   the CRS, e.g for WGS84: minLongitude, minLatitude, maxLongitude,
--   maxLatitude The spec mentions that it can be part of a geometry object
--   too but doesnt give an example, This implementation will ignore bboxes
--   on Geometry objects, they can be added if required.
data BoundingBoxWithoutCRS
BoundingBoxWithoutCRSXY :: PointXY -> PointXY -> BoundingBoxWithoutCRS
BoundingBoxWithoutCRSXYZ :: PointXYZ -> PointXYZ -> BoundingBoxWithoutCRS
BoundingBoxWithoutCRSXYZM :: PointXYZM -> PointXYZM -> BoundingBoxWithoutCRS
data FeatureID
FeatureIDText :: Text -> FeatureID
FeatureIDNumber :: Int -> FeatureID
instance Control.DeepSeq.NFData Data.Geospatial.Internal.BasicTypes.FeatureID
instance GHC.Generics.Generic Data.Geospatial.Internal.BasicTypes.FeatureID
instance GHC.Classes.Eq Data.Geospatial.Internal.BasicTypes.FeatureID
instance GHC.Show.Show Data.Geospatial.Internal.BasicTypes.FeatureID
instance Control.DeepSeq.NFData Data.Geospatial.Internal.BasicTypes.BoundingBoxWithoutCRS
instance GHC.Generics.Generic Data.Geospatial.Internal.BasicTypes.BoundingBoxWithoutCRS
instance GHC.Show.Show Data.Geospatial.Internal.BasicTypes.BoundingBoxWithoutCRS
instance GHC.Classes.Eq Data.Geospatial.Internal.BasicTypes.BoundingBoxWithoutCRS
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.BasicTypes.BoundingBoxWithoutCRS
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.BasicTypes.BoundingBoxWithoutCRS
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.BasicTypes.FeatureID
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.BasicTypes.FeatureID
instance Data.Geospatial.Internal.BasicTypes.HasGeoPositionWithoutCRS Data.Geospatial.Internal.BasicTypes.GeoPositionWithoutCRS
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.BasicTypes.GeoPositionWithoutCRS
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.BasicTypes.GeoPositionWithoutCRS
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.BasicTypes.DoubleArray
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.BasicTypes.DoubleArray
instance Control.DeepSeq.NFData Data.Geospatial.Internal.BasicTypes.DoubleArray
instance GHC.Generics.Generic Data.Geospatial.Internal.BasicTypes.DoubleArray
instance GHC.Show.Show Data.Geospatial.Internal.BasicTypes.DoubleArray
instance GHC.Classes.Eq Data.Geospatial.Internal.BasicTypes.DoubleArray
instance Control.DeepSeq.NFData Data.Geospatial.Internal.BasicTypes.PointXY
instance GHC.Generics.Generic Data.Geospatial.Internal.BasicTypes.PointXY
instance GHC.Classes.Eq Data.Geospatial.Internal.BasicTypes.PointXY
instance GHC.Show.Show Data.Geospatial.Internal.BasicTypes.PointXY
instance Control.DeepSeq.NFData Data.Geospatial.Internal.BasicTypes.PointXYZ
instance GHC.Generics.Generic Data.Geospatial.Internal.BasicTypes.PointXYZ
instance GHC.Classes.Eq Data.Geospatial.Internal.BasicTypes.PointXYZ
instance GHC.Show.Show Data.Geospatial.Internal.BasicTypes.PointXYZ
instance Control.DeepSeq.NFData Data.Geospatial.Internal.BasicTypes.PointXYZM
instance GHC.Generics.Generic Data.Geospatial.Internal.BasicTypes.PointXYZM
instance GHC.Classes.Eq Data.Geospatial.Internal.BasicTypes.PointXYZM
instance GHC.Show.Show Data.Geospatial.Internal.BasicTypes.PointXYZM
instance Control.DeepSeq.NFData Data.Geospatial.Internal.BasicTypes.GeoPositionWithoutCRS
instance GHC.Generics.Generic Data.Geospatial.Internal.BasicTypes.GeoPositionWithoutCRS
instance GHC.Classes.Eq Data.Geospatial.Internal.BasicTypes.GeoPositionWithoutCRS
instance GHC.Show.Show Data.Geospatial.Internal.BasicTypes.GeoPositionWithoutCRS


-- | See Section 3 <i>Coordinate Reference System Objects</i> in the
--   GeoJSON Spec
module Data.Geospatial.Internal.CRS

-- | See Section 3 <i>Coordinate Reference System Objects</i> in the
--   GeoJSON Spec <a>NoCRS</a> is required because no <tt>crs</tt>
--   attribute in a GeoJSON feature is NOT the same thing as a null
--   <tt>crs</tt> attribute. no <tt>crs</tt> value implies the default CRS,
--   while a null CRS means you cannot assume a CRS, null will mapped to
--   <a>NoCRS</a> while a non-existent attribute will be mapped to a
--   <a>Nothing</a> <a>Maybe</a> value
data CRSObject
NoCRS :: CRSObject
NamedCRS :: !Name -> CRSObject
EPSG :: Code -> CRSObject
LinkedCRS :: !Href -> !FormatString -> CRSObject

-- | The default CRS according to Section 3 <i>Coordinate Reference System
--   Objects</i> is WGS84 which I believe, from
--   <a>http://spatialreference.org/ref/epsg/4326/</a> which translates to
--   this in JSON: <a>http://spatialreference.org/ref/epsg/4326/json/</a>)
--   is represented thus:
defaultCRS :: CRSObject
_NoCRS :: Prism' CRSObject ()
_NamedCRS :: Prism' CRSObject Name
_EPSG :: Prism' CRSObject Code
_LinkedCRS :: Prism' CRSObject (Href, FormatString)
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.CRS.CRSObject
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.CRS.CRSObject
instance GHC.Classes.Eq Data.Geospatial.Internal.CRS.CRSObject
instance GHC.Show.Show Data.Geospatial.Internal.CRS.CRSObject


-- | see Section 2.1.1 <i>Position</i> in the GeoJSON Spec
module Data.Geospatial.Internal.GeoPosition

-- | see Section 2.1.1 <i>Position</i> in the GeoJSON Spec, I make the
--   assumption here that the only position types we will use will involve
--   easting or northing (+ve or -ve Altitude) or lon or lat (+ve or -ve
--   Altitude)
data GeoPosition
LonLat :: Longitude -> Latitude -> GeoPosition
LonLatAlt :: Longitude -> Latitude -> Altitude -> GeoPosition
EastingNorthing :: Easting -> Northing -> GeoPosition
EastingNorthingAlt :: Easting -> Northing -> Altitude -> GeoPosition

-- | the <a>GeoPosition</a> is a bit special in that when you convert it to
--   GeoJSON, it will lose the CRS info attached to it and cannot be read
--   back in from the GeoJSON. Hence it is ineligible for the
--   <tt>FromJSON</tt> type class, so this function will strip it down to a
--   <tt>GeoPositionWithoutCRS</tt>, which is eligible
stripCRSFromPosition :: GeoPosition -> GeoPositionWithoutCRS


-- | Some helpers for some of the common Aeson ops
module Data.Geospatial.Internal.Geometry.Aeson

-- | A generic function that can be used to read in the GeoJSON for:
--   <tt>GeoPoint</tt>, <tt>GeoMultiPoint</tt>, <tt>GeoLine</tt>,
--   <tt>GeoMultiLine</tt>, <tt>GeoPolygon</tt> and
--   <tt>GeoMultiPolygon</tt> Takes in a String for the GeoJSON geometry
--   type, the type constructor for the datatype and the JSON object
--   containing both the 'type' val and the <tt>coordinates</tt> val
readGeometryGeoAeson :: (FromJSON a, FromJSON b) => String -> (a -> b) -> Object -> Parser b

-- | The inverse to the above, you just give it the type string and the
--   value for the coordinates and it will create the JSON object
makeGeometryGeoAeson :: ToJSON a => String -> a -> Value

-- | get an optional value out of a JSON object:
optValFromObj :: FromJSON a => Text -> Object -> Parser (Maybe a)

-- | The other way around, given an optional value, will return the
--   attributes that should be added to the makeObj input
optAttributes :: ToJSON a => Text -> Maybe a -> [Pair]


module Data.Geospatial.Internal.Geometry.GeoPoint
newtype GeoPoint
GeoPoint :: GeoPositionWithoutCRS -> GeoPoint
[_unGeoPoint] :: GeoPoint -> GeoPositionWithoutCRS
unGeoPoint :: Iso' GeoPoint GeoPositionWithoutCRS
retrieveXY :: GeoPositionWithoutCRS -> PointXY
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.Geometry.GeoPoint.GeoPoint
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.Geometry.GeoPoint.GeoPoint
instance Control.DeepSeq.NFData Data.Geospatial.Internal.Geometry.GeoPoint.GeoPoint
instance GHC.Generics.Generic Data.Geospatial.Internal.Geometry.GeoPoint.GeoPoint
instance GHC.Classes.Eq Data.Geospatial.Internal.Geometry.GeoPoint.GeoPoint
instance GHC.Show.Show Data.Geospatial.Internal.Geometry.GeoPoint.GeoPoint


module Data.Geospatial.Internal.Geometry.GeoMultiPoint
newtype GeoMultiPoint
GeoMultiPoint :: Seq GeoPositionWithoutCRS -> GeoMultiPoint
[_unGeoMultiPoint] :: GeoMultiPoint -> Seq GeoPositionWithoutCRS
unGeoMultiPoint :: Iso' GeoMultiPoint (Seq GeoPositionWithoutCRS)

-- | Split GeoMultiPoint coordinates into multiple GeoPoints
splitGeoMultiPoint :: GeoMultiPoint -> Seq GeoPoint

-- | Merge multiple GeoPoints into one GeoMultiPoint
mergeGeoPoints :: Seq GeoPoint -> GeoMultiPoint
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.Geometry.GeoMultiPoint.GeoMultiPoint
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.Geometry.GeoMultiPoint.GeoMultiPoint
instance Control.DeepSeq.NFData Data.Geospatial.Internal.Geometry.GeoMultiPoint.GeoMultiPoint
instance GHC.Generics.Generic Data.Geospatial.Internal.Geometry.GeoMultiPoint.GeoMultiPoint
instance GHC.Classes.Eq Data.Geospatial.Internal.Geometry.GeoMultiPoint.GeoMultiPoint
instance GHC.Show.Show Data.Geospatial.Internal.Geometry.GeoMultiPoint.GeoMultiPoint


module Data.SeqHelper
sequenceHead :: Seq a -> Seq a
sequenceTail :: Seq a -> Seq a
removeNextDuplicate :: Eq a => Seq a -> Seq a


-- | Refer to the GeoJSON Spec
--   <a>http://geojson.org/geojson-spec.html#polygon</a>
--   
--   A LinearRing is a List with at least 4 elements, where the first
--   element is expected to be the same as the last.
module Data.LinearRing

-- | a LinearRing has at least 3 (distinct) elements
data LinearRing a

-- | When converting a List to a LinearRing there are some things that can
--   go wrong
--   
--   <ul>
--   <li>The list can be too short</li>
--   <li>The head may not be equal to the last element in the list (NB this
--   is not currently checked due to performance concerns, and it also
--   doesnt make much sense since its likely to contain doubles)</li>
--   </ul>
data ListToLinearRingError a
ListTooShort :: Int -> ListToLinearRingError a
HeadNotEqualToLast :: a -> a -> ListToLinearRingError a

-- | When converting a Sequence to a LinearRing there are some things that
--   can go wrong
--   
--   <ul>
--   <li>The sequence can be too short</li>
--   <li>The head may not be equal to the last element in the list</li>
--   </ul>
data SequenceToLinearRingError a
SequenceTooShort :: Int -> SequenceToLinearRingError a
FirstNotEqualToLast :: a -> a -> SequenceToLinearRingError a

-- | create a sequence from a LinearRing. LinearRing 1 2 3 [4,1] --&gt; Seq
--   [1,2,3,4,1)]
toSeq :: LinearRing a -> Seq a

-- | create a sequence from a LinearRing by combining values. LinearRing 1
--   2 3 <a>4,1</a> --&gt; Seq [(1,2),(2,3),(3,4),(4,1)]
combineToSeq :: (a -> a -> b) -> LinearRing a -> Seq b

-- | creates a LinearRing out of a sequence of elements, if there are
--   enough elements (needs at least 3) elements
--   
--   fromSeq (x:y:z:ws@(_:_)) = _Success # LinearRing x y z
--   (fromListDropLast ws) fromSeq xs = _Failure # return (ListTooShort
--   (length xs))
fromSeq :: (Eq a, Show a, Validate v, Functor (v (NonEmpty (ListToLinearRingError a)))) => Seq a -> v (NonEmpty (SequenceToLinearRingError a)) (LinearRing a)

-- | This function converts it into a list and appends the given element to
--   the end.
fromLinearRing :: LinearRing a -> [a]

-- | creates a LinearRing out of a list of elements, if there arent enough
--   elements (needs at least 4) elements
--   
--   This version doesnt check equality of the head and tail in case you
--   wish to use it for elements with no Eq instance defined.
--   
--   Also its a list, finding the last element could be expensive with
--   large lists. So just follow the spec and make sure the ring is closed.
--   
--   Ideally the Spec would be modified to remove the redundant last
--   element from the Polygons/LineRings. Its just going to waste
--   bandwidth...
--   
--   And be aware that the last element of the list will be dropped.
--   
--   Unfortunately it doesn't check that the last element is the same as
--   the first at the moment...
fromList :: (Eq a, Show a, Validate v, Functor (v (NonEmpty (ListToLinearRingError a)))) => [a] -> v (NonEmpty (ListToLinearRingError a)) (LinearRing a)

-- | The expensive version of fromList that checks whether the head and
--   last elements are equal.
fromListWithEqCheck :: (Eq a, Show a, Validate v, Applicative (v (NonEmpty (ListToLinearRingError a)))) => [a] -> v (NonEmpty (ListToLinearRingError a)) (LinearRing a)

-- | Creates a LinearRing <tt>makeLinearRing x y z xs</tt> creates a
--   <a>LinearRing</a> homomorphic to the list <tt>[x, y, z] ++ xs</tt> the
--   list <tt>xs</tt> should NOT contain the first element repeated, i.e
--   the loop does not need to be closed, makeLinearRing will close it off.
--   
--   Repeating the first element is just redundant.
makeLinearRing :: (Eq a, Show a) => a -> a -> a -> Seq a -> LinearRing a

-- | returns the element at the head of the ring
ringHead :: LinearRing a -> a

-- | returns the number of elements in the list, including the replicated
--   element at the end of the list.
ringLength :: LinearRing a -> Int
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.LinearRing.LinearRing a)
instance GHC.Generics.Generic (Data.LinearRing.LinearRing a)
instance GHC.Show.Show a => GHC.Show.Show (Data.LinearRing.LinearRing a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.LinearRing.LinearRing a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.LinearRing.ListToLinearRingError a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.LinearRing.SequenceToLinearRingError a)
instance GHC.Show.Show a => GHC.Show.Show (Data.LinearRing.SequenceToLinearRingError a)
instance GHC.Show.Show a => GHC.Show.Show (Data.LinearRing.ListToLinearRingError a)
instance GHC.Base.Functor Data.LinearRing.LinearRing
instance Data.Foldable.Foldable Data.LinearRing.LinearRing
instance Data.Traversable.Traversable Data.LinearRing.LinearRing
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Data.LinearRing.LinearRing a)
instance (GHC.Classes.Eq a, Data.Aeson.Types.FromJSON.FromJSON a, GHC.Show.Show a) => Data.Aeson.Types.FromJSON.FromJSON (Data.LinearRing.LinearRing a)


module Data.Geospatial.Internal.Geometry.GeoPolygon
newtype GeoPolygon
GeoPolygon :: Seq (LinearRing GeoPositionWithoutCRS) -> GeoPolygon
[_unGeoPolygon] :: GeoPolygon -> Seq (LinearRing GeoPositionWithoutCRS)
unGeoPolygon :: Iso' GeoPolygon (Seq (LinearRing GeoPositionWithoutCRS))
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.Geometry.GeoPolygon.GeoPolygon
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.Geometry.GeoPolygon.GeoPolygon
instance Control.DeepSeq.NFData Data.Geospatial.Internal.Geometry.GeoPolygon.GeoPolygon
instance GHC.Generics.Generic Data.Geospatial.Internal.Geometry.GeoPolygon.GeoPolygon
instance GHC.Classes.Eq Data.Geospatial.Internal.Geometry.GeoPolygon.GeoPolygon
instance GHC.Show.Show Data.Geospatial.Internal.Geometry.GeoPolygon.GeoPolygon


module Data.Geospatial.Internal.Geometry.GeoMultiPolygon
newtype GeoMultiPolygon
GeoMultiPolygon :: Seq (Seq (LinearRing GeoPositionWithoutCRS)) -> GeoMultiPolygon
[_unGeoMultiPolygon] :: GeoMultiPolygon -> Seq (Seq (LinearRing GeoPositionWithoutCRS))
unGeoMultiPolygon :: Iso' GeoMultiPolygon (Seq (Seq (LinearRing GeoPositionWithoutCRS)))

-- | Split GeoMultiPolygon coordinates into multiple GeoPolygons
splitGeoMultiPolygon :: GeoMultiPolygon -> Seq GeoPolygon

-- | Merge multiple GeoPolygons into one GeoMultiPolygon
mergeGeoPolygons :: Seq GeoPolygon -> GeoMultiPolygon
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.Geometry.GeoMultiPolygon.GeoMultiPolygon
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.Geometry.GeoMultiPolygon.GeoMultiPolygon
instance Control.DeepSeq.NFData Data.Geospatial.Internal.Geometry.GeoMultiPolygon.GeoMultiPolygon
instance GHC.Generics.Generic Data.Geospatial.Internal.Geometry.GeoMultiPolygon.GeoMultiPolygon
instance GHC.Classes.Eq Data.Geospatial.Internal.Geometry.GeoMultiPolygon.GeoMultiPolygon
instance GHC.Show.Show Data.Geospatial.Internal.Geometry.GeoMultiPolygon.GeoMultiPolygon


-- | Refer to the GeoJSON Spec
--   <a>http://geojson.org/geojson-spec.html#linestring</a>
--   
--   A LinearString is a List with at least 2 elements
module Data.LineString

-- | a LineString has at least 2 elements
data LineString a

-- | When converting a List to a LineString, here is a list of things that
--   can go wrong:
--   
--   <ul>
--   <li>The list was empty</li>
--   <li>The list only had one element</li>
--   </ul>
data ListToLineStringError
ListEmpty :: ListToLineStringError
SingletonList :: ListToLineStringError

-- | When converting a Sequence to a LineString, here is a list of things
--   that can go wrong:
--   
--   <ul>
--   <li>The sequence was empty</li>
--   <li>The sequence only had one element</li>
--   </ul>
data SequenceToLineStringError
SequenceEmpty :: SequenceToLineStringError
SingletonSequence :: SequenceToLineStringError

-- | create a sequence from a LineString. LineString 1 2 [3,4] --&gt;
--   Sequence [1,2,3,4]
toSeq :: LineString a -> Seq a

-- | create a sequence from a LineString by combining values. LineString 1
--   2 <a>3,4</a> --&gt; Sequence [(1,2),(2,3),(3,4)]
combineToSeq :: (a -> a -> b) -> LineString a -> Seq b

-- | creates a LineString out of a sequence of elements, if there are
--   enough elements (needs at least 2) elements
fromSeq :: Validate v => Seq a -> v SequenceToLineStringError (LineString a)

-- | This function converts it into a list and appends the given element to
--   the end.
fromLineString :: LineString a -> [a]

-- | creates a LineString out of a list of elements, if there are enough
--   elements (needs at least 2) elements
fromList :: Validate v => [a] -> v ListToLineStringError (LineString a)

-- | Creates a LineString <tt>makeLineString x y zs</tt> creates a
--   <a>LineString</a> homomorphic to the list <tt>[x, y] ++ zs</tt>
makeLineString :: a -> a -> Seq a -> LineString a

-- | returns the element at the head of the string
lineStringHead :: LineString a -> a

-- | returns the last element in the string
lineStringLast :: LineString a -> a

-- | returns the number of elements in the list, including the replicated
--   element at the end of the list.
lineStringLength :: LineString a -> Int
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.LineString.LineString a)
instance GHC.Generics.Generic (Data.LineString.LineString a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.LineString.LineString a)
instance GHC.Classes.Eq Data.LineString.ListToLineStringError
instance GHC.Classes.Eq Data.LineString.SequenceToLineStringError
instance GHC.Show.Show Data.LineString.SequenceToLineStringError
instance GHC.Show.Show Data.LineString.ListToLineStringError
instance GHC.Show.Show a => GHC.Show.Show (Data.LineString.LineString a)
instance GHC.Base.Functor Data.LineString.LineString
instance Data.Foldable.Foldable Data.LineString.LineString
instance Data.Traversable.Traversable Data.LineString.LineString
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Data.LineString.LineString a)
instance (Data.Aeson.Types.FromJSON.FromJSON a, GHC.Show.Show a) => Data.Aeson.Types.FromJSON.FromJSON (Data.LineString.LineString a)


module Data.Geospatial.Internal.Geometry.GeoLine
newtype GeoLine
GeoLine :: LineString GeoPositionWithoutCRS -> GeoLine
[_unGeoLine] :: GeoLine -> LineString GeoPositionWithoutCRS
unGeoLine :: Iso' GeoLine (LineString GeoPositionWithoutCRS)
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.Geometry.GeoLine.GeoLine
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.Geometry.GeoLine.GeoLine
instance Control.DeepSeq.NFData Data.Geospatial.Internal.Geometry.GeoLine.GeoLine
instance GHC.Generics.Generic Data.Geospatial.Internal.Geometry.GeoLine.GeoLine
instance GHC.Classes.Eq Data.Geospatial.Internal.Geometry.GeoLine.GeoLine
instance GHC.Show.Show Data.Geospatial.Internal.Geometry.GeoLine.GeoLine


module Data.Geospatial.Internal.Geometry.GeoMultiLine
newtype GeoMultiLine
GeoMultiLine :: Seq (LineString GeoPositionWithoutCRS) -> GeoMultiLine
[_unGeoMultiLine] :: GeoMultiLine -> Seq (LineString GeoPositionWithoutCRS)
unGeoMultiLine :: Iso' GeoMultiLine (Seq (LineString GeoPositionWithoutCRS))

-- | Split GeoMultiLine coordinates into multiple GeoLines
splitGeoMultiLine :: GeoMultiLine -> Seq GeoLine

-- | Merge multiple GeoLines into one GeoMultiLine
mergeGeoLines :: Seq GeoLine -> GeoMultiLine
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.Geometry.GeoMultiLine.GeoMultiLine
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.Geometry.GeoMultiLine.GeoMultiLine
instance Control.DeepSeq.NFData Data.Geospatial.Internal.Geometry.GeoMultiLine.GeoMultiLine
instance GHC.Generics.Generic Data.Geospatial.Internal.Geometry.GeoMultiLine.GeoMultiLine
instance GHC.Classes.Eq Data.Geospatial.Internal.Geometry.GeoMultiLine.GeoMultiLine
instance GHC.Show.Show Data.Geospatial.Internal.Geometry.GeoMultiLine.GeoMultiLine


-- | See section 2.1 "Geometry Objects" in the GeoJSON Spec.
module Data.Geospatial.Internal.Geometry
newtype GeoPoint
GeoPoint :: GeoPositionWithoutCRS -> GeoPoint
[_unGeoPoint] :: GeoPoint -> GeoPositionWithoutCRS
retrieveXY :: GeoPositionWithoutCRS -> PointXY
newtype GeoMultiPoint
GeoMultiPoint :: Seq GeoPositionWithoutCRS -> GeoMultiPoint
[_unGeoMultiPoint] :: GeoMultiPoint -> Seq GeoPositionWithoutCRS

-- | Split GeoMultiPoint coordinates into multiple GeoPoints
splitGeoMultiPoint :: GeoMultiPoint -> Seq GeoPoint

-- | Merge multiple GeoPoints into one GeoMultiPoint
mergeGeoPoints :: Seq GeoPoint -> GeoMultiPoint
newtype GeoPolygon
GeoPolygon :: Seq (LinearRing GeoPositionWithoutCRS) -> GeoPolygon
[_unGeoPolygon] :: GeoPolygon -> Seq (LinearRing GeoPositionWithoutCRS)
newtype GeoMultiPolygon
GeoMultiPolygon :: Seq (Seq (LinearRing GeoPositionWithoutCRS)) -> GeoMultiPolygon
[_unGeoMultiPolygon] :: GeoMultiPolygon -> Seq (Seq (LinearRing GeoPositionWithoutCRS))

-- | Split GeoMultiPolygon coordinates into multiple GeoPolygons
splitGeoMultiPolygon :: GeoMultiPolygon -> Seq GeoPolygon

-- | Merge multiple GeoPolygons into one GeoMultiPolygon
mergeGeoPolygons :: Seq GeoPolygon -> GeoMultiPolygon
newtype GeoLine
GeoLine :: LineString GeoPositionWithoutCRS -> GeoLine
[_unGeoLine] :: GeoLine -> LineString GeoPositionWithoutCRS
newtype GeoMultiLine
GeoMultiLine :: Seq (LineString GeoPositionWithoutCRS) -> GeoMultiLine
[_unGeoMultiLine] :: GeoMultiLine -> Seq (LineString GeoPositionWithoutCRS)

-- | Split GeoMultiLine coordinates into multiple GeoLines
splitGeoMultiLine :: GeoMultiLine -> Seq GeoLine

-- | Merge multiple GeoLines into one GeoMultiLine
mergeGeoLines :: Seq GeoLine -> GeoMultiLine

-- | See section 2.1 <i>Geometry Objects</i> in the GeoJSON Spec.
data GeospatialGeometry
NoGeometry :: GeospatialGeometry
Point :: GeoPoint -> GeospatialGeometry
MultiPoint :: GeoMultiPoint -> GeospatialGeometry
Polygon :: GeoPolygon -> GeospatialGeometry
MultiPolygon :: GeoMultiPolygon -> GeospatialGeometry
Line :: GeoLine -> GeospatialGeometry
MultiLine :: GeoMultiLine -> GeospatialGeometry
Collection :: Seq GeospatialGeometry -> GeospatialGeometry
unGeoPoint :: Iso' GeoPoint GeoPositionWithoutCRS
unGeoMultiPoint :: Iso' GeoMultiPoint (Seq GeoPositionWithoutCRS)
unGeoPolygon :: Iso' GeoPolygon (Seq (LinearRing GeoPositionWithoutCRS))
unGeoMultiPolygon :: Iso' GeoMultiPolygon (Seq (Seq (LinearRing GeoPositionWithoutCRS)))
unGeoLine :: Iso' GeoLine (LineString GeoPositionWithoutCRS)
unGeoMultiLine :: Iso' GeoMultiLine (Seq (LineString GeoPositionWithoutCRS))
_NoGeometry :: Prism' GeospatialGeometry ()
_Point :: Prism' GeospatialGeometry GeoPoint
_MultiPoint :: Prism' GeospatialGeometry GeoMultiPoint
_Polygon :: Prism' GeospatialGeometry GeoPolygon
_MultiPolygon :: Prism' GeospatialGeometry GeoMultiPolygon
_Line :: Prism' GeospatialGeometry GeoLine
_MultiLine :: Prism' GeospatialGeometry GeoMultiLine
_Collection :: Prism' GeospatialGeometry (Seq GeospatialGeometry)
instance Data.Aeson.Types.ToJSON.ToJSON Data.Geospatial.Internal.Geometry.GeospatialGeometry
instance Data.Aeson.Types.FromJSON.FromJSON Data.Geospatial.Internal.Geometry.GeospatialGeometry
instance Control.DeepSeq.NFData Data.Geospatial.Internal.Geometry.GeospatialGeometry
instance GHC.Generics.Generic Data.Geospatial.Internal.Geometry.GeospatialGeometry
instance GHC.Classes.Eq Data.Geospatial.Internal.Geometry.GeospatialGeometry
instance GHC.Show.Show Data.Geospatial.Internal.Geometry.GeospatialGeometry


-- | See Section 2.2 <i>Feature Objects</i> of the GeoJSON spec.
--   Parameterised on the property type
module Data.Geospatial.Internal.GeoFeature

-- | See Section 2.2 <i>Feature Objects</i> of the GeoJSON spec.
--   Parameterised on the property type
data GeoFeature a
GeoFeature :: Maybe BoundingBoxWithoutCRS -> GeospatialGeometry -> a -> Maybe FeatureID -> GeoFeature a
[_bbox] :: GeoFeature a -> Maybe BoundingBoxWithoutCRS
[_geometry] :: GeoFeature a -> GeospatialGeometry
[_properties] :: GeoFeature a -> a
[_featureId] :: GeoFeature a -> Maybe FeatureID
bbox :: forall a_azrl. Lens' (GeoFeature a_azrl) (Maybe BoundingBoxWithoutCRS)
geometry :: forall a_azrl. Lens' (GeoFeature a_azrl) GeospatialGeometry
properties :: forall a_azrl a_azyN. Lens (GeoFeature a_azrl) (GeoFeature a_azyN) a_azrl a_azyN
featureId :: forall a_azrl. Lens' (GeoFeature a_azrl) (Maybe FeatureID)
reWrapGeometry :: GeoFeature a -> GeospatialGeometry -> GeoFeature a
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Data.Geospatial.Internal.GeoFeature.GeoFeature a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Data.Geospatial.Internal.GeoFeature.GeoFeature a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Geospatial.Internal.GeoFeature.GeoFeature a)
instance GHC.Generics.Generic (Data.Geospatial.Internal.GeoFeature.GeoFeature a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Geospatial.Internal.GeoFeature.GeoFeature a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Geospatial.Internal.GeoFeature.GeoFeature a)


-- | See Section 2.3 <i>Feature Collection Objects</i> of the GeoJSON spec
module Data.Geospatial.Internal.GeoFeatureCollection

-- | See Section 2.3 <i>Feature Collection Objects</i> of the GeoJSON spec
data GeoFeatureCollection a
GeoFeatureCollection :: Maybe BoundingBoxWithoutCRS -> Seq (GeoFeature a) -> GeoFeatureCollection a
[_boundingbox] :: GeoFeatureCollection a -> Maybe BoundingBoxWithoutCRS
[_geofeatures] :: GeoFeatureCollection a -> Seq (GeoFeature a)
boundingbox :: forall a_aAXF. Lens' (GeoFeatureCollection a_aAXF) (Maybe BoundingBoxWithoutCRS)
geofeatures :: forall a_aAXF a_aB0e. Lens (GeoFeatureCollection a_aAXF) (GeoFeatureCollection a_aB0e) (Seq (GeoFeature a_aAXF)) (Seq (GeoFeature a_aB0e))
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Data.Geospatial.Internal.GeoFeatureCollection.GeoFeatureCollection a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Data.Geospatial.Internal.GeoFeatureCollection.GeoFeatureCollection a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Geospatial.Internal.GeoFeatureCollection.GeoFeatureCollection a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Geospatial.Internal.GeoFeatureCollection.GeoFeatureCollection a)


-- | Refer to the GeoJSON Spec
--   <a>http://www.geojson.org/geojson-spec.html</a>
module Data.Geospatial
type Latitude = Double
type Longitude = Double
type Easting = Double
type Northing = Double
type Altitude = Double
data FeatureID
FeatureIDText :: Text -> FeatureID
FeatureIDNumber :: Int -> FeatureID
data GeoPositionWithoutCRS
GeoEmpty :: GeoPositionWithoutCRS
GeoPointXY :: PointXY -> GeoPositionWithoutCRS
GeoPointXYZ :: PointXYZ -> GeoPositionWithoutCRS
GeoPointXYZM :: PointXYZM -> GeoPositionWithoutCRS

-- | see Section 2.1.1 <i>Position</i> in the GeoJSON Spec, I make the
--   assumption here that the only position types we will use will involve
--   easting or northing (+ve or -ve Altitude) or lon or lat (+ve or -ve
--   Altitude)
data GeoPosition
LonLat :: Longitude -> Latitude -> GeoPosition
LonLatAlt :: Longitude -> Latitude -> Altitude -> GeoPosition
EastingNorthing :: Easting -> Northing -> GeoPosition
EastingNorthingAlt :: Easting -> Northing -> Altitude -> GeoPosition
newtype GeoPoint
GeoPoint :: GeoPositionWithoutCRS -> GeoPoint
[_unGeoPoint] :: GeoPoint -> GeoPositionWithoutCRS
retrieveXY :: GeoPositionWithoutCRS -> PointXY

-- | (<a>GeoPositionWithoutCRS</a> is a catch all for indeterminate CRSs
--   and for expression of positions before a CRS has been determined
data PointXY
PointXY :: !Double -> !Double -> PointXY
[_xyX] :: PointXY -> !Double
[_xyY] :: PointXY -> !Double
data PointXYZ
PointXYZ :: !Double -> !Double -> !Double -> PointXYZ
[_xyzX] :: PointXYZ -> !Double
[_xyzY] :: PointXYZ -> !Double
[_xyzZ] :: PointXYZ -> !Double
data PointXYZM
PointXYZM :: !Double -> !Double -> !Double -> !Double -> PointXYZM
[_xyzmX] :: PointXYZM -> !Double
[_xyzmY] :: PointXYZM -> !Double
[_xyzmZ] :: PointXYZM -> !Double
[_xyzmM] :: PointXYZM -> !Double
newtype GeoMultiPoint
GeoMultiPoint :: Seq GeoPositionWithoutCRS -> GeoMultiPoint
[_unGeoMultiPoint] :: GeoMultiPoint -> Seq GeoPositionWithoutCRS

-- | Split GeoMultiPoint coordinates into multiple GeoPoints
splitGeoMultiPoint :: GeoMultiPoint -> Seq GeoPoint

-- | Merge multiple GeoPoints into one GeoMultiPoint
mergeGeoPoints :: Seq GeoPoint -> GeoMultiPoint
newtype GeoPolygon
GeoPolygon :: Seq (LinearRing GeoPositionWithoutCRS) -> GeoPolygon
[_unGeoPolygon] :: GeoPolygon -> Seq (LinearRing GeoPositionWithoutCRS)
newtype GeoMultiPolygon
GeoMultiPolygon :: Seq (Seq (LinearRing GeoPositionWithoutCRS)) -> GeoMultiPolygon
[_unGeoMultiPolygon] :: GeoMultiPolygon -> Seq (Seq (LinearRing GeoPositionWithoutCRS))

-- | Split GeoMultiPolygon coordinates into multiple GeoPolygons
splitGeoMultiPolygon :: GeoMultiPolygon -> Seq GeoPolygon

-- | Merge multiple GeoPolygons into one GeoMultiPolygon
mergeGeoPolygons :: Seq GeoPolygon -> GeoMultiPolygon
newtype GeoLine
GeoLine :: LineString GeoPositionWithoutCRS -> GeoLine
[_unGeoLine] :: GeoLine -> LineString GeoPositionWithoutCRS
newtype GeoMultiLine
GeoMultiLine :: Seq (LineString GeoPositionWithoutCRS) -> GeoMultiLine
[_unGeoMultiLine] :: GeoMultiLine -> Seq (LineString GeoPositionWithoutCRS)

-- | Split GeoMultiLine coordinates into multiple GeoLines
splitGeoMultiLine :: GeoMultiLine -> Seq GeoLine

-- | Merge multiple GeoLines into one GeoMultiLine
mergeGeoLines :: Seq GeoLine -> GeoMultiLine

-- | See section 2.1 <i>Geometry Objects</i> in the GeoJSON Spec.
data GeospatialGeometry
NoGeometry :: GeospatialGeometry
Point :: GeoPoint -> GeospatialGeometry
MultiPoint :: GeoMultiPoint -> GeospatialGeometry
Polygon :: GeoPolygon -> GeospatialGeometry
MultiPolygon :: GeoMultiPolygon -> GeospatialGeometry
Line :: GeoLine -> GeospatialGeometry
MultiLine :: GeoMultiLine -> GeospatialGeometry
Collection :: Seq GeospatialGeometry -> GeospatialGeometry
type Name = Text
type Code = Int
type Href = Text
type FormatString = Text
type ProjectionType = Text

-- | See Section 3 <i>Coordinate Reference System Objects</i> in the
--   GeoJSON Spec <a>NoCRS</a> is required because no <tt>crs</tt>
--   attribute in a GeoJSON feature is NOT the same thing as a null
--   <tt>crs</tt> attribute. no <tt>crs</tt> value implies the default CRS,
--   while a null CRS means you cannot assume a CRS, null will mapped to
--   <a>NoCRS</a> while a non-existent attribute will be mapped to a
--   <a>Nothing</a> <a>Maybe</a> value
data CRSObject
NoCRS :: CRSObject
NamedCRS :: !Name -> CRSObject
EPSG :: Code -> CRSObject
LinkedCRS :: !Href -> !FormatString -> CRSObject

-- | See Section 4 <i>Bounding Boxes</i> of the GeoJSON spec, The length of
--   the list/array must be 2*n where n is the dimensionality of the
--   position type for the CRS with min values first followed by the max
--   values, wich both the min/max sets following the same axis order as
--   the CRS, e.g for WGS84: minLongitude, minLatitude, maxLongitude,
--   maxLatitude The spec mentions that it can be part of a geometry object
--   too but doesnt give an example, This implementation will ignore bboxes
--   on Geometry objects, they can be added if required.
data BoundingBoxWithoutCRS
BoundingBoxWithoutCRSXY :: PointXY -> PointXY -> BoundingBoxWithoutCRS
BoundingBoxWithoutCRSXYZ :: PointXYZ -> PointXYZ -> BoundingBoxWithoutCRS
BoundingBoxWithoutCRSXYZM :: PointXYZM -> PointXYZM -> BoundingBoxWithoutCRS

-- | See Section 2.2 <i>Feature Objects</i> of the GeoJSON spec.
--   Parameterised on the property type
data GeoFeature a
GeoFeature :: Maybe BoundingBoxWithoutCRS -> GeospatialGeometry -> a -> Maybe FeatureID -> GeoFeature a
[_bbox] :: GeoFeature a -> Maybe BoundingBoxWithoutCRS
[_geometry] :: GeoFeature a -> GeospatialGeometry
[_properties] :: GeoFeature a -> a
[_featureId] :: GeoFeature a -> Maybe FeatureID
reWrapGeometry :: GeoFeature a -> GeospatialGeometry -> GeoFeature a

-- | See Section 2.3 <i>Feature Collection Objects</i> of the GeoJSON spec
data GeoFeatureCollection a
GeoFeatureCollection :: Maybe BoundingBoxWithoutCRS -> Seq (GeoFeature a) -> GeoFeatureCollection a
[_boundingbox] :: GeoFeatureCollection a -> Maybe BoundingBoxWithoutCRS
[_geofeatures] :: GeoFeatureCollection a -> Seq (GeoFeature a)

-- | the <a>GeoPosition</a> is a bit special in that when you convert it to
--   GeoJSON, it will lose the CRS info attached to it and cannot be read
--   back in from the GeoJSON. Hence it is ineligible for the
--   <tt>FromJSON</tt> type class, so this function will strip it down to a
--   <tt>GeoPositionWithoutCRS</tt>, which is eligible
stripCRSFromPosition :: GeoPosition -> GeoPositionWithoutCRS

-- | The default CRS according to Section 3 <i>Coordinate Reference System
--   Objects</i> is WGS84 which I believe, from
--   <a>http://spatialreference.org/ref/epsg/4326/</a> which translates to
--   this in JSON: <a>http://spatialreference.org/ref/epsg/4326/json/</a>)
--   is represented thus:
defaultCRS :: CRSObject
unGeoPoint :: Iso' GeoPoint GeoPositionWithoutCRS
unGeoMultiPoint :: Iso' GeoMultiPoint (Seq GeoPositionWithoutCRS)
unGeoPolygon :: Iso' GeoPolygon (Seq (LinearRing GeoPositionWithoutCRS))
unGeoLine :: Iso' GeoLine (LineString GeoPositionWithoutCRS)
unGeoMultiLine :: Iso' GeoMultiLine (Seq (LineString GeoPositionWithoutCRS))
unGeoMultiPolygon :: Iso' GeoMultiPolygon (Seq (Seq (LinearRing GeoPositionWithoutCRS)))
bbox :: forall a_azrl. Lens' (GeoFeature a_azrl) (Maybe BoundingBoxWithoutCRS)
geometry :: forall a_azrl. Lens' (GeoFeature a_azrl) GeospatialGeometry
properties :: forall a_azrl a_azyN. Lens (GeoFeature a_azrl) (GeoFeature a_azyN) a_azrl a_azyN
featureId :: forall a_azrl. Lens' (GeoFeature a_azrl) (Maybe FeatureID)
boundingbox :: forall a_aAXF. Lens' (GeoFeatureCollection a_aAXF) (Maybe BoundingBoxWithoutCRS)
geofeatures :: forall a_aAXF a_aB0e. Lens (GeoFeatureCollection a_aAXF) (GeoFeatureCollection a_aB0e) (Seq (GeoFeature a_aAXF)) (Seq (GeoFeature a_aB0e))
class HasGeoPositionWithoutCRS c_ageb
geoPositionWithoutCRS :: HasGeoPositionWithoutCRS c_ageb => Lens' c_ageb GeoPositionWithoutCRS
_NoGeometry :: Prism' GeospatialGeometry ()
_Point :: Prism' GeospatialGeometry GeoPoint
_MultiPoint :: Prism' GeospatialGeometry GeoMultiPoint
_Polygon :: Prism' GeospatialGeometry GeoPolygon
_MultiPolygon :: Prism' GeospatialGeometry GeoMultiPolygon
_Line :: Prism' GeospatialGeometry GeoLine
_MultiLine :: Prism' GeospatialGeometry GeoMultiLine
_Collection :: Prism' GeospatialGeometry (Seq GeospatialGeometry)
_NoCRS :: Prism' CRSObject ()
_NamedCRS :: Prism' CRSObject Name
_EPSG :: Prism' CRSObject Code
_LinkedCRS :: Prism' CRSObject (Href, FormatString)
