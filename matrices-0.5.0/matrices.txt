-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | native matrix based on vector
--   
--   Pure Haskell matrix library, supporting creating, indexing, and
--   modifying dense/sparse matrices.
@package matrices
@version 0.5.0

module Data.Matrix.Class.Mutable
class MVector v a => MMatrix m v a
dim :: MMatrix m v a => m v s a -> (Int, Int)
unsafeRead :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> s a
unsafeWrite :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> a -> s ()

-- | Create a mutable matrix without initialization
new :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> s (m v (PrimState s) a)
replicate :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> a -> s (m v (PrimState s) a)

-- | Derived methods
write :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> a -> s ()
read :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> s a

module Data.Matrix.Class
type family Mutable (m :: (* -> *) -> * -> *) :: (* -> * -> *) -> * -> * -> *
class (MMatrix (Mutable m) (Mutable v) a, Vector v a) => Matrix m v a
dim :: Matrix m v a => m v a -> (Int, Int)
unsafeIndex :: Matrix m v a => m v a -> (Int, Int) -> a
unsafeFromVector :: Matrix m v a => (Int, Int) -> v a -> m v a

-- | Default algorithm is O((m*n) * O(unsafeIndex)).
flatten :: Matrix m v a => m v a -> v a

-- | Extract a row. Default algorithm is O(n * O(unsafeIndex)).
unsafeTakeRow :: Matrix m v a => m v a -> Int -> v a

-- | Extract a column. Default algorithm is O(m * O(unsafeIndex)).
unsafeTakeColumn :: Matrix m v a => m v a -> Int -> v a

-- | Extract the diagonal. Default algorithm is O(min(m,n) *
--   O(unsafeIndex)).
takeDiag :: Matrix m v a => m v a -> v a
thaw :: (Matrix m v a, PrimMonad s) => m v a -> s (Mutable m (Mutable v) (PrimState s) a)
unsafeThaw :: (Matrix m v a, PrimMonad s) => m v a -> s (Mutable m (Mutable v) (PrimState s) a)
freeze :: (Matrix m v a, PrimMonad s) => Mutable m (Mutable v) (PrimState s) a -> s (m v a)
unsafeFreeze :: (Matrix m v a, PrimMonad s) => Mutable m (Mutable v) (PrimState s) a -> s (m v a)

-- | Derived methods
--   
--   Return the number of rows
rows :: Matrix m v a => m v a -> Int

-- | Return the number of columns
cols :: Matrix m v a => m v a -> Int

-- | Indexing
(!) :: Matrix m v a => m v a -> (Int, Int) -> a
fromVector :: Matrix m v a => (Int, Int) -> v a -> m v a
fromList :: Matrix m v a => (Int, Int) -> [a] -> m v a
empty :: Matrix m v a => m v a

-- | O(m*n) Create a list by concatenating rows
toList :: Matrix m v a => m v a -> [a]

-- | O(m*n) Create matrix from list of lists, it doesn't check if the list
--   of list is a valid matrix
fromLists :: Matrix m v a => [[a]] -> m v a

-- | O(m*n) Matrix construction
matrix :: Matrix m v a => Int -> [a] -> m v a

-- | O(m*n) Create matrix from rows
fromRows :: Matrix m v a => [v a] -> m v a

-- | Extract a row.
takeRow :: Matrix m v a => m v a -> Int -> v a

-- | O(m) Return the rows
toRows :: Matrix m v a => m v a -> [v a]

-- | Extract a row.
takeColumn :: Matrix m v a => m v a -> Int -> v a

-- | O(m*n) Return the columns
toColumns :: Matrix m v a => m v a -> [v a]

-- | O(m*n) List of lists
toLists :: Matrix m v a => m v a -> [[a]]
create :: Matrix m v a => (forall s. ST s (Mutable m (Mutable v) s a)) -> m v a

module Data.Matrix.Generic.Mutable

-- | mutable matrix
data MMatrix v s a
MMatrix :: !Int -> !Int -> !Int -> !Int -> !v s a -> MMatrix v s a
dim :: MMatrix m v a => m v s a -> (Int, Int)
takeRow :: MVector v a => MMatrix v m a -> Int -> v m a

-- | Derived methods
write :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> a -> s ()
unsafeWrite :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> a -> s ()
read :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> s a
unsafeRead :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> s a

-- | Create a mutable matrix without initialization
new :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> s (m v (PrimState s) a)
replicate :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> a -> s (m v (PrimState s) a)
instance Control.DeepSeq.NFData (v s a) => Control.DeepSeq.NFData (Data.Matrix.Generic.Mutable.MMatrix v s a)
instance Data.Vector.Generic.Mutable.Base.MVector v a => Data.Matrix.Class.Mutable.MMatrix Data.Matrix.Generic.Mutable.MMatrix v a

module Data.Matrix.Generic

-- | Row-major matrix supporting efficient slice.
data Matrix v a
Matrix :: !Int -> !Int -> !Int -> !Int -> !v a -> Matrix v a
dim :: Matrix m v a => m v a -> (Int, Int)

-- | Derived methods
--   
--   Return the number of rows
rows :: Matrix m v a => m v a -> Int

-- | Return the number of columns
cols :: Matrix m v a => m v a -> Int
unsafeIndex :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Indexing
(!) :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Extract a row.
takeRow :: Matrix m v a => m v a -> Int -> v a

-- | Extract a row.
takeColumn :: Matrix m v a => m v a -> Int -> v a

-- | Extract the diagonal. Default algorithm is O(min(m,n) *
--   O(unsafeIndex)).
takeDiag :: Matrix m v a => m v a -> v a
unsafeFromVector :: Matrix m v a => (Int, Int) -> v a -> m v a
fromVector :: Matrix m v a => (Int, Int) -> v a -> m v a

-- | O(m*n) Matrix construction
matrix :: Matrix m v a => Int -> [a] -> m v a
fromList :: Matrix m v a => (Int, Int) -> [a] -> m v a

-- | O(m*n) Create matrix from list of lists, it doesn't check if the list
--   of list is a valid matrix
fromLists :: Matrix m v a => [[a]] -> m v a

-- | O(m*n) Create matrix from rows
fromRows :: Matrix m v a => [v a] -> m v a

-- | O(m*n) Create matrix from columns
fromColumns :: Vector v a => [v a] -> Matrix v a
empty :: Matrix m v a => m v a

-- | Default algorithm is O((m*n) * O(unsafeIndex)).
flatten :: Matrix m v a => m v a -> v a

-- | O(m) Return the rows
toRows :: Matrix m v a => m v a -> [v a]

-- | O(m*n) Return the columns
toColumns :: Matrix m v a => m v a -> [v a]

-- | O(m*n) Create a list by concatenating rows
toList :: Matrix m v a => m v a -> [a]

-- | O(m*n) List of lists
toLists :: Matrix m v a => m v a -> [[a]]

-- | O(m*n) Convert different matrix type
convert :: (Vector v a, Vector w a) => Matrix v a -> Matrix w a

-- | O(m*n) Matrix transpose
tr :: Vector v a => Matrix v a -> Matrix v a

-- | O(1) Extract sub matrix
subMatrix :: Vector v a => (Int, Int) -> (Int, Int) -> Matrix v a -> Matrix v a

-- | O(m*n) Create an identity matrix
ident :: (Num a, Vector v a) => Int -> Matrix v a

-- | O(m*n) Create a square matrix with given diagonal, other entries
--   default to 0
diag :: (Num a, Vector v a, Foldable t) => t a -> Matrix v a

-- | O(m*n) Create a rectangular matrix with default values and given
--   diagonal
diagRect :: (Vector v a, Foldable t) => a -> (Int, Int) -> t a -> Matrix v a
fromBlocks :: Vector v a => a -> [[Matrix v a]] -> Matrix v a
isSymmetric :: (Eq a, Vector v a) => Matrix v a -> Bool
force :: Vector v a => Matrix v a -> Matrix v a
foldl :: Vector v b => (a -> b -> a) -> a -> Matrix v b -> a
map :: (Vector v a, Vector v b) => (a -> b) -> Matrix v a -> Matrix v b
imap :: (Vector v a, Vector v b) => ((Int, Int) -> a -> b) -> Matrix v a -> Matrix v b
mapM :: (Vector v a, Vector v b, Monad m) => (a -> m b) -> Matrix v a -> m (Matrix v b)

-- | O(m*n) Apply the monadic action to every element and its index,
--   yielding a matrix of results.
imapM :: (Vector v a, Vector v b, Monad m) => ((Int, Int) -> a -> m b) -> Matrix v a -> m (Matrix v b)
mapM_ :: (Vector v a, Monad m) => (a -> m b) -> Matrix v a -> m ()

-- | O(m*n) Apply the monadic action to every element and its index,
--   ignoring the results.
imapM_ :: (Vector v a, Monad m) => ((Int, Int) -> a -> m b) -> Matrix v a -> m ()
forM :: (Vector v a, Vector v b, Monad m) => Matrix v a -> (a -> m b) -> m (Matrix v b)
forM_ :: (Vector v a, Monad m) => Matrix v a -> (a -> m b) -> m ()
zipWith :: (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> Matrix v a -> Matrix v b -> Matrix v c
zipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (a -> b -> c -> d) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d
zipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (a -> b -> c -> d -> e) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e
zipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (a -> b -> c -> d -> e -> f) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v f
zipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (a -> b -> c -> d -> e -> f -> g) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v f -> Matrix v g
izipWith :: (Vector v a, Vector v b, Vector v c) => ((Int, Int) -> a -> b -> c) -> Matrix v a -> Matrix v b -> Matrix v c
izipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => ((Int, Int) -> a -> b -> c -> d) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d
izipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => ((Int, Int) -> a -> b -> c -> d -> e) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e
izipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => ((Int, Int) -> a -> b -> c -> d -> e -> f) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v f
izipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => ((Int, Int) -> a -> b -> c -> d -> e -> f -> g) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v f -> Matrix v g
zip :: (Vector v a, Vector v b, Vector v (a, b)) => Matrix v a -> Matrix v b -> Matrix v (a, b)
zip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => Matrix v a -> Matrix v b -> Matrix v c -> Matrix v (a, b, c)
zip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v (a, b, c, d)
zip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v (a, b, c, d, e)
zip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v f -> Matrix v (a, b, c, d, e, f)
zipWithM :: (Monad m, Vector v a, Vector v b, Vector v c) => (a -> b -> m c) -> Matrix v a -> Matrix v b -> m (Matrix v c)
zipWithM_ :: (Monad m, Vector v a, Vector v b) => (a -> b -> m c) -> Matrix v a -> Matrix v b -> m ()
unzip :: (Vector v a, Vector v b, Vector v (a, b)) => Matrix v (a, b) -> (Matrix v a, Matrix v b)
unzip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => Matrix v (a, b, c) -> (Matrix v a, Matrix v b, Matrix v c)
unzip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => Matrix v (a, b, c, d) -> (Matrix v a, Matrix v b, Matrix v c, Matrix v d)
unzip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => Matrix v (a, b, c, d, e) -> (Matrix v a, Matrix v b, Matrix v c, Matrix v d, Matrix v e)
unzip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => Matrix v (a, b, c, d, e, f) -> (Matrix v a, Matrix v b, Matrix v c, Matrix v d, Matrix v e, Matrix v f)
sequence :: (Vector v a, Vector v (m a), Monad m) => Matrix v (m a) -> m (Matrix v a)
sequence_ :: (Vector v (m a), Monad m) => Matrix v (m a) -> m ()
generate :: Vector v a => (Int, Int) -> ((Int, Int) -> a) -> Matrix v a
thaw :: (Matrix m v a, PrimMonad s) => m v a -> s (Mutable m (Mutable v) (PrimState s) a)
unsafeThaw :: (Matrix m v a, PrimMonad s) => m v a -> s (Mutable m (Mutable v) (PrimState s) a)
freeze :: (Matrix m v a, PrimMonad s) => Mutable m (Mutable v) (PrimState s) a -> s (m v a)
unsafeFreeze :: (Matrix m v a, PrimMonad s) => Mutable m (Mutable v) (PrimState s) a -> s (m v a)
create :: Matrix m v a => (forall s. ST s (Mutable m (Mutable v) s a)) -> m v a
instance GHC.Generics.Generic (Data.Matrix.Generic.Matrix v a)
instance GHC.Read.Read (v a) => GHC.Read.Read (Data.Matrix.Generic.Matrix v a)
instance GHC.Show.Show (v a) => GHC.Show.Show (Data.Matrix.Generic.Matrix v a)
instance (Data.Vector.Generic.Base.Vector v a, GHC.Classes.Eq (v a)) => GHC.Classes.Eq (Data.Matrix.Generic.Matrix v a)
instance Control.DeepSeq.NFData (v a) => Control.DeepSeq.NFData (Data.Matrix.Generic.Matrix v a)
instance Data.Vector.Generic.Base.Vector v a => Data.Matrix.Class.Matrix Data.Matrix.Generic.Matrix v a

module Data.Matrix.Mutable
type MMatrix a = MMatrix MVector a
dim :: Context a => MMatrix s a -> (Int, Int)
takeRow :: Context a => MMatrix s a -> Int -> MVector s a
write :: Context a => PrimMonad s => MMatrix (PrimState s) a -> (Int, Int) -> a -> s ()
unsafeWrite :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> (Int, Int) -> a -> s ()
read :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> (Int, Int) -> s a
unsafeRead :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> (Int, Int) -> s a

-- | Create a mutable matrix without initialization
new :: (Context a, PrimMonad s) => (Int, Int) -> s (MMatrix (PrimState s) a)
replicate :: (Context a, PrimMonad s) => (Int, Int) -> a -> s (MMatrix (PrimState s) a)

module Data.Matrix
type Matrix = Matrix Vector
dim :: Context a => Matrix a -> (Int, Int)
rows :: Context a => Matrix a -> Int
cols :: Context a => Matrix a -> Int
unsafeIndex :: Context a => Matrix a -> (Int, Int) -> a
(!) :: Context a => Matrix a -> (Int, Int) -> a
takeRow :: Context a => Matrix a -> Int -> Vector a
takeColumn :: Context a => Matrix a -> Int -> Vector a
takeDiag :: Context a => Matrix a -> Vector a
unsafeFromVector :: Context a => (Int, Int) -> Vector a -> Matrix a
fromVector :: Context a => (Int, Int) -> Vector a -> Matrix a

-- | O(m*n) Matrix construction
matrix :: Context a => Int -> [a] -> Matrix a
fromList :: Context a => (Int, Int) -> [a] -> Matrix a

-- | O(m*n) Create matrix from list of lists, it doesn't check if the list
--   of list is a valid matrix
fromLists :: Context a => [[a]] -> Matrix a

-- | O(m*n) Create matrix from rows
fromRows :: Context a => [Vector a] -> Matrix a

-- | O(m*n) Create matrix from columns
fromColumns :: Context a => [Vector a] -> Matrix a
empty :: Context a => Matrix a
flatten :: Context a => Matrix a -> Vector a

-- | O(m) Return the rows
toRows :: Context a => Matrix a -> [Vector a]
toColumns :: Context a => Matrix a -> [Vector a]

-- | O(m*n) Create a list by concatenating rows
toList :: Context a => Matrix a -> [a]

-- | O(m*n) List of lists
toLists :: Context a => Matrix a -> [[a]]

-- | O(m*n) Matrix transpose
tr :: Context a => Matrix a -> Matrix a

-- | O(1) Extract sub matrix
subMatrix :: Context a => (Int, Int) -> (Int, Int) -> Matrix a -> Matrix a

-- | O(m*n) Create an identity matrix
ident :: (Context a, Num a) => Int -> Matrix a

-- | O(m*n) Create a square matrix with given diagonal, other entries
--   default to 0
diag :: (Context a, Num a, Foldable t) => t a -> Matrix a

-- | O(m*n) Create a rectangular matrix with default values and given
--   diagonal
diagRect :: (Context a, Foldable t) => a -> (Int, Int) -> t a -> Matrix a
fromBlocks :: Context a => a -> [[Matrix a]] -> Matrix a
isSymmetric :: (Context a, Eq a) => Matrix a -> Bool
force :: Context a => Matrix a -> Matrix a
foldl :: Context b => (a -> b -> a) -> a -> Matrix b -> a
map :: (Context a, Context b) => (a -> b) -> Matrix a -> Matrix b
imap :: (Context a, Context b) => ((Int, Int) -> a -> b) -> Matrix a -> Matrix b
mapM :: (Context a, Context b, Monad m) => (a -> m b) -> Matrix a -> m (Matrix b)

-- | O(m*n) Apply the monadic action to every element and its index,
--   yielding a matrix of results.
imapM :: (Context a, Context b, Monad m) => ((Int, Int) -> a -> m b) -> Matrix a -> m (Matrix b)
mapM_ :: (Context a, Monad m) => (a -> m b) -> Matrix a -> m ()

-- | O(m*n) Apply the monadic action to every element and its index,
--   ignoring the results.
imapM_ :: (Context a, Monad m) => ((Int, Int) -> a -> m b) -> Matrix a -> m ()
forM :: (Context a, Context b, Monad m) => Matrix a -> (a -> m b) -> m (Matrix b)
forM_ :: (Context a, Monad m) => Matrix a -> (a -> m b) -> m ()
zipWith :: (Context a, Context b, Context c) => (a -> b -> c) -> Matrix a -> Matrix b -> Matrix c
zipWith3 :: (Context a, Context b, Context c, Context d) => (a -> b -> c -> d) -> Matrix a -> Matrix b -> Matrix c -> Matrix d
zipWith4 :: (Context a, Context b, Context c, Context d, Context e) => (a -> b -> c -> d -> e) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e
zipWith5 :: (Context a, Context b, Context c, Context d, Context e, Context f) => (a -> b -> c -> d -> e -> f) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f
zipWith6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context g) => (a -> b -> c -> d -> e -> f -> g) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f -> Matrix g
izipWith :: (Context a, Context b, Context c) => ((Int, Int) -> a -> b -> c) -> Matrix a -> Matrix b -> Matrix c
izipWith3 :: (Context a, Context b, Context c, Context d) => ((Int, Int) -> a -> b -> c -> d) -> Matrix a -> Matrix b -> Matrix c -> Matrix d
izipWith4 :: (Context a, Context b, Context c, Context d, Context e) => ((Int, Int) -> a -> b -> c -> d -> e) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e
izipWith5 :: (Context a, Context b, Context c, Context d, Context e, Context f) => ((Int, Int) -> a -> b -> c -> d -> e -> f) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f
izipWith6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context g) => ((Int, Int) -> a -> b -> c -> d -> e -> f -> g) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f -> Matrix g
zip :: (Context a, Context b, Context (a, b)) => Matrix a -> Matrix b -> Matrix (a, b)
zip3 :: (Context a, Context b, Context c, Context (a, b, c)) => Matrix a -> Matrix b -> Matrix c -> Matrix (a, b, c)
zip4 :: (Context a, Context b, Context c, Context d, Context (a, b, c, d)) => Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix (a, b, c, d)
zip5 :: (Context a, Context b, Context c, Context d, Context e, Context (a, b, c, d, e)) => Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix (a, b, c, d, e)
zip6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context (a, b, c, d, e, f)) => Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f -> Matrix (a, b, c, d, e, f)
zipWithM :: (Context a, Context b, Context c, Monad m) => (a -> b -> m c) -> Matrix a -> Matrix b -> m (Matrix c)
zipWithM_ :: (Context a, Context b, Monad m) => (a -> b -> m c) -> Matrix a -> Matrix b -> m ()
unzip :: (Context a, Context b, Context (a, b)) => Matrix (a, b) -> (Matrix a, Matrix b)
unzip3 :: (Context a, Context b, Context c, Context (a, b, c)) => Matrix (a, b, c) -> (Matrix a, Matrix b, Matrix c)
unzip4 :: (Context a, Context b, Context c, Context d, Context (a, b, c, d)) => Matrix (a, b, c, d) -> (Matrix a, Matrix b, Matrix c, Matrix d)
unzip5 :: (Context a, Context b, Context c, Context d, Context e, Context (a, b, c, d, e)) => Matrix (a, b, c, d, e) -> (Matrix a, Matrix b, Matrix c, Matrix d, Matrix e)
unzip6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context (a, b, c, d, e, f)) => Matrix (a, b, c, d, e, f) -> (Matrix a, Matrix b, Matrix c, Matrix d, Matrix e, Matrix f)
sequence :: Monad m => Matrix (m a) -> m (Matrix a)
sequence_ :: Monad m => Matrix (m a) -> m ()
generate :: Context a => (Int, Int) -> ((Int, Int) -> a) -> Matrix a
thaw :: (Context a, PrimMonad s) => Matrix a -> s (MMatrix (PrimState s) a)
unsafeThaw :: (Context a, PrimMonad s) => Matrix a -> s (MMatrix (PrimState s) a)
freeze :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> s (Matrix a)
unsafeFreeze :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> s (Matrix a)
create :: Context a => (forall s. ST s (MMatrix s a)) -> Matrix a

module Data.Matrix.Sparse.Generic
class Eq a => Zero a
zero :: Zero a => a

-- | Compressed Sparse Row (CSR) matrix
data CSR v a
CSR :: !Int -> !Int -> !v a -> !Vector Int -> !Vector Int -> CSR v a
type AssocList a = [((Int, Int), a)]
dim :: Matrix m v a => m v a -> (Int, Int)

-- | Derived methods
--   
--   Return the number of rows
rows :: Matrix m v a => m v a -> Int

-- | Return the number of columns
cols :: Matrix m v a => m v a -> Int
unsafeIndex :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Indexing
(!) :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Extract a row.
takeRow :: Matrix m v a => m v a -> Int -> v a

-- | Extract a row.
takeColumn :: Matrix m v a => m v a -> Int -> v a

-- | Extract the diagonal. Default algorithm is O(min(m,n) *
--   O(unsafeIndex)).
takeDiag :: Matrix m v a => m v a -> v a

-- | Construct CSR from ascending association list. Items must be sorted
--   first by row index, and then by column index.
fromAscAL :: Vector v a => (Int, Int) -> Int -> AssocList a -> CSR v a
unsafeFromVector :: Matrix m v a => (Int, Int) -> v a -> m v a
fromVector :: Matrix m v a => (Int, Int) -> v a -> m v a

-- | O(m*n) Matrix construction
matrix :: Matrix m v a => Int -> [a] -> m v a

-- | O(m*n) Create matrix from list of lists, it doesn't check if the list
--   of list is a valid matrix
fromLists :: Matrix m v a => [[a]] -> m v a

-- | O(m*n) Create matrix from rows
fromRows :: Matrix m v a => [v a] -> m v a
empty :: Matrix m v a => m v a

-- | Default algorithm is O((m*n) * O(unsafeIndex)).
flatten :: Matrix m v a => m v a -> v a

-- | O(m) Return the rows
toRows :: Matrix m v a => m v a -> [v a]

-- | O(m*n) Return the columns
toColumns :: Matrix m v a => m v a -> [v a]

-- | O(m*n) Create a list by concatenating rows
toList :: Matrix m v a => m v a -> [a]

-- | O(m*n) List of lists
toLists :: Matrix m v a => m v a -> [[a]]
instance GHC.Generics.Generic (Data.Matrix.Sparse.Generic.CSR v a)
instance GHC.Classes.Eq (v a) => GHC.Classes.Eq (Data.Matrix.Sparse.Generic.CSR v a)
instance GHC.Read.Read (v a) => GHC.Read.Read (Data.Matrix.Sparse.Generic.CSR v a)
instance GHC.Show.Show (v a) => GHC.Show.Show (Data.Matrix.Sparse.Generic.CSR v a)
instance (Data.Matrix.Sparse.Generic.Zero a, Data.Vector.Generic.Base.Vector v a) => Data.Matrix.Class.Matrix Data.Matrix.Sparse.Generic.CSR v a
instance Data.Matrix.Sparse.Generic.Zero GHC.Types.Int
instance Data.Matrix.Sparse.Generic.Zero GHC.Types.Double
instance GHC.Classes.Eq a => Data.Matrix.Sparse.Generic.Zero [a]

module Data.Matrix.Storable.Mutable
type MMatrix a = MMatrix MVector a
dim :: Context a => MMatrix s a -> (Int, Int)
takeRow :: Context a => MMatrix s a -> Int -> MVector s a
write :: Context a => PrimMonad s => MMatrix (PrimState s) a -> (Int, Int) -> a -> s ()
unsafeWrite :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> (Int, Int) -> a -> s ()
read :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> (Int, Int) -> s a
unsafeRead :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> (Int, Int) -> s a

-- | Create a mutable matrix without initialization
new :: (Context a, PrimMonad s) => (Int, Int) -> s (MMatrix (PrimState s) a)
replicate :: (Context a, PrimMonad s) => (Int, Int) -> a -> s (MMatrix (PrimState s) a)

module Data.Matrix.Storable
type Matrix = Matrix Vector
dim :: Context a => Matrix a -> (Int, Int)
rows :: Context a => Matrix a -> Int
cols :: Context a => Matrix a -> Int
unsafeIndex :: Context a => Matrix a -> (Int, Int) -> a
(!) :: Context a => Matrix a -> (Int, Int) -> a
takeRow :: Context a => Matrix a -> Int -> Vector a
takeColumn :: Context a => Matrix a -> Int -> Vector a
takeDiag :: Context a => Matrix a -> Vector a
unsafeFromVector :: Context a => (Int, Int) -> Vector a -> Matrix a
fromVector :: Context a => (Int, Int) -> Vector a -> Matrix a

-- | O(m*n) Matrix construction
matrix :: Context a => Int -> [a] -> Matrix a
fromList :: Context a => (Int, Int) -> [a] -> Matrix a

-- | O(m*n) Create matrix from list of lists, it doesn't check if the list
--   of list is a valid matrix
fromLists :: Context a => [[a]] -> Matrix a

-- | O(m*n) Create matrix from rows
fromRows :: Context a => [Vector a] -> Matrix a

-- | O(m*n) Create matrix from columns
fromColumns :: Context a => [Vector a] -> Matrix a
empty :: Context a => Matrix a
flatten :: Context a => Matrix a -> Vector a

-- | O(m) Return the rows
toRows :: Context a => Matrix a -> [Vector a]
toColumns :: Context a => Matrix a -> [Vector a]

-- | O(m*n) Create a list by concatenating rows
toList :: Context a => Matrix a -> [a]

-- | O(m*n) List of lists
toLists :: Context a => Matrix a -> [[a]]

-- | O(m*n) Matrix transpose
tr :: Context a => Matrix a -> Matrix a

-- | O(1) Extract sub matrix
subMatrix :: Context a => (Int, Int) -> (Int, Int) -> Matrix a -> Matrix a

-- | O(m*n) Create an identity matrix
ident :: (Context a, Num a) => Int -> Matrix a

-- | O(m*n) Create a square matrix with given diagonal, other entries
--   default to 0
diag :: (Context a, Num a, Foldable t) => t a -> Matrix a

-- | O(m*n) Create a rectangular matrix with default values and given
--   diagonal
diagRect :: (Context a, Foldable t) => a -> (Int, Int) -> t a -> Matrix a
fromBlocks :: Context a => a -> [[Matrix a]] -> Matrix a
isSymmetric :: (Context a, Eq a) => Matrix a -> Bool
force :: Context a => Matrix a -> Matrix a
foldl :: Context b => (a -> b -> a) -> a -> Matrix b -> a
map :: (Context a, Context b) => (a -> b) -> Matrix a -> Matrix b
imap :: (Context a, Context b) => ((Int, Int) -> a -> b) -> Matrix a -> Matrix b
mapM :: (Context a, Context b, Monad m) => (a -> m b) -> Matrix a -> m (Matrix b)

-- | O(m*n) Apply the monadic action to every element and its index,
--   yielding a matrix of results.
imapM :: (Context a, Context b, Monad m) => ((Int, Int) -> a -> m b) -> Matrix a -> m (Matrix b)
mapM_ :: (Context a, Monad m) => (a -> m b) -> Matrix a -> m ()

-- | O(m*n) Apply the monadic action to every element and its index,
--   ignoring the results.
imapM_ :: (Context a, Monad m) => ((Int, Int) -> a -> m b) -> Matrix a -> m ()
forM :: (Context a, Context b, Monad m) => Matrix a -> (a -> m b) -> m (Matrix b)
forM_ :: (Context a, Monad m) => Matrix a -> (a -> m b) -> m ()
zipWith :: (Context a, Context b, Context c) => (a -> b -> c) -> Matrix a -> Matrix b -> Matrix c
zipWith3 :: (Context a, Context b, Context c, Context d) => (a -> b -> c -> d) -> Matrix a -> Matrix b -> Matrix c -> Matrix d
zipWith4 :: (Context a, Context b, Context c, Context d, Context e) => (a -> b -> c -> d -> e) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e
zipWith5 :: (Context a, Context b, Context c, Context d, Context e, Context f) => (a -> b -> c -> d -> e -> f) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f
zipWith6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context g) => (a -> b -> c -> d -> e -> f -> g) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f -> Matrix g
izipWith :: (Context a, Context b, Context c) => ((Int, Int) -> a -> b -> c) -> Matrix a -> Matrix b -> Matrix c
izipWith3 :: (Context a, Context b, Context c, Context d) => ((Int, Int) -> a -> b -> c -> d) -> Matrix a -> Matrix b -> Matrix c -> Matrix d
izipWith4 :: (Context a, Context b, Context c, Context d, Context e) => ((Int, Int) -> a -> b -> c -> d -> e) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e
izipWith5 :: (Context a, Context b, Context c, Context d, Context e, Context f) => ((Int, Int) -> a -> b -> c -> d -> e -> f) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f
izipWith6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context g) => ((Int, Int) -> a -> b -> c -> d -> e -> f -> g) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f -> Matrix g
zip :: (Context a, Context b, Context (a, b)) => Matrix a -> Matrix b -> Matrix (a, b)
zip3 :: (Context a, Context b, Context c, Context (a, b, c)) => Matrix a -> Matrix b -> Matrix c -> Matrix (a, b, c)
zip4 :: (Context a, Context b, Context c, Context d, Context (a, b, c, d)) => Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix (a, b, c, d)
zip5 :: (Context a, Context b, Context c, Context d, Context e, Context (a, b, c, d, e)) => Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix (a, b, c, d, e)
zip6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context (a, b, c, d, e, f)) => Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f -> Matrix (a, b, c, d, e, f)
zipWithM :: (Context a, Context b, Context c, Monad m) => (a -> b -> m c) -> Matrix a -> Matrix b -> m (Matrix c)
zipWithM_ :: (Context a, Context b, Monad m) => (a -> b -> m c) -> Matrix a -> Matrix b -> m ()
unzip :: (Context a, Context b, Context (a, b)) => Matrix (a, b) -> (Matrix a, Matrix b)
unzip3 :: (Context a, Context b, Context c, Context (a, b, c)) => Matrix (a, b, c) -> (Matrix a, Matrix b, Matrix c)
unzip4 :: (Context a, Context b, Context c, Context d, Context (a, b, c, d)) => Matrix (a, b, c, d) -> (Matrix a, Matrix b, Matrix c, Matrix d)
unzip5 :: (Context a, Context b, Context c, Context d, Context e, Context (a, b, c, d, e)) => Matrix (a, b, c, d, e) -> (Matrix a, Matrix b, Matrix c, Matrix d, Matrix e)
unzip6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context (a, b, c, d, e, f)) => Matrix (a, b, c, d, e, f) -> (Matrix a, Matrix b, Matrix c, Matrix d, Matrix e, Matrix f)
generate :: Context a => (Int, Int) -> ((Int, Int) -> a) -> Matrix a
thaw :: (Context a, PrimMonad s) => Matrix a -> s (MMatrix (PrimState s) a)
unsafeThaw :: (Context a, PrimMonad s) => Matrix a -> s (MMatrix (PrimState s) a)
freeze :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> s (Matrix a)
unsafeFreeze :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> s (Matrix a)
create :: Context a => (forall s. ST s (MMatrix s a)) -> Matrix a

module Data.Matrix.Symmetric.Generic.Mutable

-- | mutable matrix
data SymMMatrix v s a
SymMMatrix :: !Int -> !v s a -> SymMMatrix v s a
dim :: MMatrix m v a => m v s a -> (Int, Int)

-- | Derived methods
write :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> a -> s ()
unsafeWrite :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> a -> s ()
read :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> s a
unsafeRead :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> s a

-- | Create a mutable matrix without initialization
new :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> s (m v (PrimState s) a)
replicate :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> a -> s (m v (PrimState s) a)
instance Data.Vector.Generic.Mutable.Base.MVector v a => Data.Matrix.Class.Mutable.MMatrix Data.Matrix.Symmetric.Generic.Mutable.SymMMatrix v a

module Data.Matrix.Symmetric.Generic

-- | Symmetric square matrix
data SymMatrix v a
SymMatrix :: !Int -> !v a -> SymMatrix v a
dim :: Matrix m v a => m v a -> (Int, Int)

-- | Derived methods
--   
--   Return the number of rows
rows :: Matrix m v a => m v a -> Int

-- | Return the number of columns
cols :: Matrix m v a => m v a -> Int
unsafeIndex :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Indexing
(!) :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Default algorithm is O((m*n) * O(unsafeIndex)).
flatten :: Matrix m v a => m v a -> v a
unsafeFromVector :: Matrix m v a => (Int, Int) -> v a -> m v a
fromVector :: Matrix m v a => (Int, Int) -> v a -> m v a

-- | Extract a row.
takeRow :: Matrix m v a => m v a -> Int -> v a
thaw :: (Matrix m v a, PrimMonad s) => m v a -> s (Mutable m (Mutable v) (PrimState s) a)
unsafeThaw :: (Matrix m v a, PrimMonad s) => m v a -> s (Mutable m (Mutable v) (PrimState s) a)
freeze :: (Matrix m v a, PrimMonad s) => Mutable m (Mutable v) (PrimState s) a -> s (m v a)
unsafeFreeze :: (Matrix m v a, PrimMonad s) => Mutable m (Mutable v) (PrimState s) a -> s (m v a)
create :: Matrix m v a => (forall s. ST s (Mutable m (Mutable v) s a)) -> m v a
map :: (Vector v a, Vector v b) => (a -> b) -> SymMatrix v a -> SymMatrix v b

-- | Upper triangular imap, i.e., i &lt;= j
imap :: (Vector v a, Vector v b) => ((Int, Int) -> a -> b) -> SymMatrix v a -> SymMatrix v b
zip :: (Vector v a, Vector v b, Vector v (a, b)) => SymMatrix v a -> SymMatrix v b -> SymMatrix v (a, b)
zipWith :: (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> SymMatrix v a -> SymMatrix v b -> SymMatrix v c
instance GHC.Classes.Eq (v a) => GHC.Classes.Eq (Data.Matrix.Symmetric.Generic.SymMatrix v a)
instance GHC.Generics.Generic (Data.Matrix.Symmetric.Generic.SymMatrix v a)
instance GHC.Read.Read (v a) => GHC.Read.Read (Data.Matrix.Symmetric.Generic.SymMatrix v a)
instance GHC.Show.Show (v a) => GHC.Show.Show (Data.Matrix.Symmetric.Generic.SymMatrix v a)
instance Data.Vector.Generic.Base.Vector v a => Data.Matrix.Class.Matrix Data.Matrix.Symmetric.Generic.SymMatrix v a

module Data.Matrix.Unboxed.Mutable
type MMatrix a = MMatrix MVector a
dim :: Context a => MMatrix s a -> (Int, Int)
takeRow :: Context a => MMatrix s a -> Int -> MVector s a
write :: Context a => PrimMonad s => MMatrix (PrimState s) a -> (Int, Int) -> a -> s ()
unsafeWrite :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> (Int, Int) -> a -> s ()
read :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> (Int, Int) -> s a
unsafeRead :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> (Int, Int) -> s a

-- | Create a mutable matrix without initialization
new :: (Context a, PrimMonad s) => (Int, Int) -> s (MMatrix (PrimState s) a)
replicate :: (Context a, PrimMonad s) => (Int, Int) -> a -> s (MMatrix (PrimState s) a)

module Data.Matrix.Unboxed
type Matrix = Matrix Vector
dim :: Context a => Matrix a -> (Int, Int)
rows :: Context a => Matrix a -> Int
cols :: Context a => Matrix a -> Int
unsafeIndex :: Context a => Matrix a -> (Int, Int) -> a
(!) :: Context a => Matrix a -> (Int, Int) -> a
takeRow :: Context a => Matrix a -> Int -> Vector a
takeColumn :: Context a => Matrix a -> Int -> Vector a
takeDiag :: Context a => Matrix a -> Vector a
unsafeFromVector :: Context a => (Int, Int) -> Vector a -> Matrix a
fromVector :: Context a => (Int, Int) -> Vector a -> Matrix a

-- | O(m*n) Matrix construction
matrix :: Context a => Int -> [a] -> Matrix a
fromList :: Context a => (Int, Int) -> [a] -> Matrix a

-- | O(m*n) Create matrix from list of lists, it doesn't check if the list
--   of list is a valid matrix
fromLists :: Context a => [[a]] -> Matrix a

-- | O(m*n) Create matrix from rows
fromRows :: Context a => [Vector a] -> Matrix a

-- | O(m*n) Create matrix from columns
fromColumns :: Context a => [Vector a] -> Matrix a
empty :: Context a => Matrix a
flatten :: Context a => Matrix a -> Vector a

-- | O(m) Return the rows
toRows :: Context a => Matrix a -> [Vector a]
toColumns :: Context a => Matrix a -> [Vector a]

-- | O(m*n) Create a list by concatenating rows
toList :: Context a => Matrix a -> [a]

-- | O(m*n) List of lists
toLists :: Context a => Matrix a -> [[a]]

-- | O(m*n) Matrix transpose
tr :: Context a => Matrix a -> Matrix a

-- | O(1) Extract sub matrix
subMatrix :: Context a => (Int, Int) -> (Int, Int) -> Matrix a -> Matrix a

-- | O(m*n) Create an identity matrix
ident :: (Context a, Num a) => Int -> Matrix a

-- | O(m*n) Create a square matrix with given diagonal, other entries
--   default to 0
diag :: (Context a, Num a, Foldable t) => t a -> Matrix a

-- | O(m*n) Create a rectangular matrix with default values and given
--   diagonal
diagRect :: (Context a, Foldable t) => a -> (Int, Int) -> t a -> Matrix a
fromBlocks :: Context a => a -> [[Matrix a]] -> Matrix a
isSymmetric :: (Context a, Eq a) => Matrix a -> Bool
force :: Context a => Matrix a -> Matrix a
foldl :: Context b => (a -> b -> a) -> a -> Matrix b -> a
map :: (Context a, Context b) => (a -> b) -> Matrix a -> Matrix b
imap :: (Context a, Context b) => ((Int, Int) -> a -> b) -> Matrix a -> Matrix b
mapM :: (Context a, Context b, Monad m) => (a -> m b) -> Matrix a -> m (Matrix b)

-- | O(m*n) Apply the monadic action to every element and its index,
--   yielding a matrix of results.
imapM :: (Context a, Context b, Monad m) => ((Int, Int) -> a -> m b) -> Matrix a -> m (Matrix b)
mapM_ :: (Context a, Monad m) => (a -> m b) -> Matrix a -> m ()

-- | O(m*n) Apply the monadic action to every element and its index,
--   ignoring the results.
imapM_ :: (Context a, Monad m) => ((Int, Int) -> a -> m b) -> Matrix a -> m ()
forM :: (Context a, Context b, Monad m) => Matrix a -> (a -> m b) -> m (Matrix b)
forM_ :: (Context a, Monad m) => Matrix a -> (a -> m b) -> m ()
zipWith :: (Context a, Context b, Context c) => (a -> b -> c) -> Matrix a -> Matrix b -> Matrix c
zipWith3 :: (Context a, Context b, Context c, Context d) => (a -> b -> c -> d) -> Matrix a -> Matrix b -> Matrix c -> Matrix d
zipWith4 :: (Context a, Context b, Context c, Context d, Context e) => (a -> b -> c -> d -> e) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e
zipWith5 :: (Context a, Context b, Context c, Context d, Context e, Context f) => (a -> b -> c -> d -> e -> f) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f
zipWith6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context g) => (a -> b -> c -> d -> e -> f -> g) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f -> Matrix g
izipWith :: (Context a, Context b, Context c) => ((Int, Int) -> a -> b -> c) -> Matrix a -> Matrix b -> Matrix c
izipWith3 :: (Context a, Context b, Context c, Context d) => ((Int, Int) -> a -> b -> c -> d) -> Matrix a -> Matrix b -> Matrix c -> Matrix d
izipWith4 :: (Context a, Context b, Context c, Context d, Context e) => ((Int, Int) -> a -> b -> c -> d -> e) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e
izipWith5 :: (Context a, Context b, Context c, Context d, Context e, Context f) => ((Int, Int) -> a -> b -> c -> d -> e -> f) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f
izipWith6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context g) => ((Int, Int) -> a -> b -> c -> d -> e -> f -> g) -> Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f -> Matrix g
zip :: (Context a, Context b, Context (a, b)) => Matrix a -> Matrix b -> Matrix (a, b)
zip3 :: (Context a, Context b, Context c, Context (a, b, c)) => Matrix a -> Matrix b -> Matrix c -> Matrix (a, b, c)
zip4 :: (Context a, Context b, Context c, Context d, Context (a, b, c, d)) => Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix (a, b, c, d)
zip5 :: (Context a, Context b, Context c, Context d, Context e, Context (a, b, c, d, e)) => Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix (a, b, c, d, e)
zip6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context (a, b, c, d, e, f)) => Matrix a -> Matrix b -> Matrix c -> Matrix d -> Matrix e -> Matrix f -> Matrix (a, b, c, d, e, f)
zipWithM :: (Context a, Context b, Context c, Monad m) => (a -> b -> m c) -> Matrix a -> Matrix b -> m (Matrix c)
zipWithM_ :: (Context a, Context b, Monad m) => (a -> b -> m c) -> Matrix a -> Matrix b -> m ()
unzip :: (Context a, Context b, Context (a, b)) => Matrix (a, b) -> (Matrix a, Matrix b)
unzip3 :: (Context a, Context b, Context c, Context (a, b, c)) => Matrix (a, b, c) -> (Matrix a, Matrix b, Matrix c)
unzip4 :: (Context a, Context b, Context c, Context d, Context (a, b, c, d)) => Matrix (a, b, c, d) -> (Matrix a, Matrix b, Matrix c, Matrix d)
unzip5 :: (Context a, Context b, Context c, Context d, Context e, Context (a, b, c, d, e)) => Matrix (a, b, c, d, e) -> (Matrix a, Matrix b, Matrix c, Matrix d, Matrix e)
unzip6 :: (Context a, Context b, Context c, Context d, Context e, Context f, Context (a, b, c, d, e, f)) => Matrix (a, b, c, d, e, f) -> (Matrix a, Matrix b, Matrix c, Matrix d, Matrix e, Matrix f)
generate :: Context a => (Int, Int) -> ((Int, Int) -> a) -> Matrix a
thaw :: (Context a, PrimMonad s) => Matrix a -> s (MMatrix (PrimState s) a)
unsafeThaw :: (Context a, PrimMonad s) => Matrix a -> s (MMatrix (PrimState s) a)
freeze :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> s (Matrix a)
unsafeFreeze :: (Context a, PrimMonad s) => MMatrix (PrimState s) a -> s (Matrix a)
create :: Context a => (forall s. ST s (MMatrix s a)) -> Matrix a
