-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Linear Algebra
--   
--   Types and combinators for linear algebra on free vector spaces
@package linear
@version 1.21.6


-- | Serialization of statically-sized types with the <a>Data.Binary</a>
--   library.
module Linear.Binary

-- | Serialize a linear type.
putLinear :: (Binary a, Foldable t) => t a -> Put

-- | Deserialize a linear type.
getLinear :: (Binary a, Applicative t, Traversable t) => Get (t a)


-- | Involutive rings
module Linear.Conjugate

-- | An involutive ring
class Num a => Conjugate a

-- | Conjugate a value. This defaults to the trivial involution.
--   
--   <pre>
--   &gt;&gt;&gt; conjugate (1 :+ 2)
--   1.0 :+ (-2.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conjugate 1
--   1
--   </pre>
conjugate :: Conjugate a => a -> a

-- | Conjugate a value. This defaults to the trivial involution.
--   
--   <pre>
--   &gt;&gt;&gt; conjugate (1 :+ 2)
--   1.0 :+ (-2.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conjugate 1
--   1
--   </pre>
conjugate :: (Conjugate a, TrivialConjugate a) => a -> a

-- | Requires and provides a default definition such that
--   
--   <pre>
--   <a>conjugate</a> = <a>id</a>
--   </pre>
class Conjugate a => TrivialConjugate a
instance Linear.Conjugate.Conjugate GHC.Integer.Type.Integer
instance Linear.Conjugate.Conjugate GHC.Types.Int
instance Linear.Conjugate.Conjugate GHC.Int.Int64
instance Linear.Conjugate.Conjugate GHC.Int.Int32
instance Linear.Conjugate.Conjugate GHC.Int.Int16
instance Linear.Conjugate.Conjugate GHC.Int.Int8
instance Linear.Conjugate.Conjugate GHC.Types.Word
instance Linear.Conjugate.Conjugate GHC.Word.Word64
instance Linear.Conjugate.Conjugate GHC.Word.Word32
instance Linear.Conjugate.Conjugate GHC.Word.Word16
instance Linear.Conjugate.Conjugate GHC.Word.Word8
instance Linear.Conjugate.Conjugate GHC.Types.Double
instance Linear.Conjugate.Conjugate GHC.Types.Float
instance Linear.Conjugate.Conjugate Foreign.C.Types.CFloat
instance Linear.Conjugate.Conjugate Foreign.C.Types.CDouble
instance (Linear.Conjugate.Conjugate a, GHC.Float.RealFloat a) => Linear.Conjugate.Conjugate (Data.Complex.Complex a)
instance Linear.Conjugate.TrivialConjugate GHC.Integer.Type.Integer
instance Linear.Conjugate.TrivialConjugate GHC.Types.Int
instance Linear.Conjugate.TrivialConjugate GHC.Int.Int64
instance Linear.Conjugate.TrivialConjugate GHC.Int.Int32
instance Linear.Conjugate.TrivialConjugate GHC.Int.Int16
instance Linear.Conjugate.TrivialConjugate GHC.Int.Int8
instance Linear.Conjugate.TrivialConjugate GHC.Types.Word
instance Linear.Conjugate.TrivialConjugate GHC.Word.Word64
instance Linear.Conjugate.TrivialConjugate GHC.Word.Word32
instance Linear.Conjugate.TrivialConjugate GHC.Word.Word16
instance Linear.Conjugate.TrivialConjugate GHC.Word.Word8
instance Linear.Conjugate.TrivialConjugate GHC.Types.Double
instance Linear.Conjugate.TrivialConjugate GHC.Types.Float
instance Linear.Conjugate.TrivialConjugate Foreign.C.Types.CFloat
instance Linear.Conjugate.TrivialConjugate Foreign.C.Types.CDouble


-- | Testing for values "near" zero
module Linear.Epsilon

-- | Provides a fairly subjective test to see if a quantity is near zero.
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-11 :: Double)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-17 :: Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-5 :: Float)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nearZero (1e-7 :: Float)
--   True
--   </pre>
class Num a => Epsilon a

-- | Determine if a quantity is near zero.
nearZero :: Epsilon a => a -> Bool
instance Linear.Epsilon.Epsilon GHC.Types.Float
instance Linear.Epsilon.Epsilon GHC.Types.Double
instance Linear.Epsilon.Epsilon Foreign.C.Types.CFloat
instance Linear.Epsilon.Epsilon Foreign.C.Types.CDouble
instance (Linear.Epsilon.Epsilon a, GHC.Float.RealFloat a) => Linear.Epsilon.Epsilon (Data.Complex.Complex a)


-- | Re-exports orphan instances for <tt>Complex</tt> from the
--   <tt>base-orphans</tt> package.
module Linear.Instances


-- | Operations on free vector spaces.
module Linear.Vector

-- | A vector is an additive group with additional structure.
class Functor f => Additive f

-- | The zero vector
zero :: (Additive f, Num a) => f a

-- | The zero vector
zero :: (Additive f, GAdditive (Rep1 f), Generic1 f, Num a) => f a

-- | Compute the sum of two vectors
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 ^+^ V2 3 4
--   V2 4 6
--   </pre>
(^+^) :: (Additive f, Num a) => f a -> f a -> f a

-- | Compute the difference between two vectors
--   
--   <pre>
--   &gt;&gt;&gt; V2 4 5 ^-^ V2 3 1
--   V2 1 4
--   </pre>
(^-^) :: (Additive f, Num a) => f a -> f a -> f a

-- | Linearly interpolate between two vectors.
lerp :: (Additive f, Num a) => a -> f a -> f a -> f a

-- | Apply a function to merge the 'non-zero' components of two vectors,
--   unioning the rest of the values.
--   
--   <ul>
--   <li>For a dense vector this is equivalent to <a>liftA2</a>.</li>
--   <li>For a sparse vector this is equivalent to <a>unionWith</a>.</li>
--   </ul>
liftU2 :: Additive f => (a -> a -> a) -> f a -> f a -> f a

-- | Apply a function to merge the 'non-zero' components of two vectors,
--   unioning the rest of the values.
--   
--   <ul>
--   <li>For a dense vector this is equivalent to <a>liftA2</a>.</li>
--   <li>For a sparse vector this is equivalent to <a>unionWith</a>.</li>
--   </ul>
liftU2 :: (Additive f, Applicative f) => (a -> a -> a) -> f a -> f a -> f a

-- | Apply a function to the components of two vectors.
--   
--   <ul>
--   <li>For a dense vector this is equivalent to <a>liftA2</a>.</li>
--   <li>For a sparse vector this is equivalent to
--   <a>intersectionWith</a>.</li>
--   </ul>
liftI2 :: Additive f => (a -> b -> c) -> f a -> f b -> f c

-- | Apply a function to the components of two vectors.
--   
--   <ul>
--   <li>For a dense vector this is equivalent to <a>liftA2</a>.</li>
--   <li>For a sparse vector this is equivalent to
--   <a>intersectionWith</a>.</li>
--   </ul>
liftI2 :: (Additive f, Applicative f) => (a -> b -> c) -> f a -> f b -> f c
infixl 6 ^+^
infixl 6 ^-^

-- | Basis element
newtype E t
E :: (forall x. Lens' (t x) x) -> E t
[el] :: E t -> forall x. Lens' (t x) x

-- | Compute the negation of a vector
--   
--   <pre>
--   &gt;&gt;&gt; negated (V2 2 4)
--   V2 (-2) (-4)
--   </pre>
negated :: (Functor f, Num a) => f a -> f a

-- | Compute the right scalar product
--   
--   <pre>
--   &gt;&gt;&gt; V2 3 4 ^* 2
--   V2 6 8
--   </pre>
(^*) :: (Functor f, Num a) => f a -> a -> f a
infixl 7 ^*

-- | Compute the left scalar product
--   
--   <pre>
--   &gt;&gt;&gt; 2 *^ V2 3 4
--   V2 6 8
--   </pre>
(*^) :: (Functor f, Num a) => a -> f a -> f a
infixl 7 *^

-- | Compute division by a scalar on the right.
(^/) :: (Functor f, Fractional a) => f a -> a -> f a
infixl 7 ^/

-- | Sum over multiple vectors
--   
--   <pre>
--   &gt;&gt;&gt; sumV [V2 1 1, V2 3 4]
--   V2 4 5
--   </pre>
sumV :: (Foldable f, Additive v, Num a) => f (v a) -> v a

-- | Produce a default basis for a vector space. If the dimensionality of
--   the vector space is not statically known, see <a>basisFor</a>.
basis :: (Additive t, Traversable t, Num a) => [t a]

-- | Produce a default basis for a vector space from which the argument is
--   drawn.
basisFor :: (Traversable t, Num a) => t b -> [t a]

-- | Produce a diagonal (scale) matrix from a vector.
--   
--   <pre>
--   &gt;&gt;&gt; scaled (V2 2 3)
--   V2 (V2 2 0) (V2 0 3)
--   </pre>
scaled :: (Traversable t, Num a) => t a -> t (t a)

-- | Outer (tensor) product of two vectors
outer :: (Functor f, Functor g, Num a) => f a -> g a -> f (g a)

-- | Create a unit vector.
--   
--   <pre>
--   &gt;&gt;&gt; unit _x :: V2 Int
--   V2 1 0
--   </pre>
unit :: (Additive t, Num a) => ASetter' (t a) a -> t a
instance (Linear.Vector.Additive f, Linear.Vector.GAdditive g) => Linear.Vector.GAdditive (f GHC.Generics.:.: g)
instance Linear.Vector.Additive f => Linear.Vector.GAdditive (GHC.Generics.Rec1 f)
instance (Linear.Vector.Additive f, Linear.Vector.Additive g) => Linear.Vector.Additive (Data.Functor.Product.Product f g)
instance (Linear.Vector.Additive f, Linear.Vector.Additive g) => Linear.Vector.Additive (Data.Functor.Compose.Compose f g)
instance Linear.Vector.Additive Control.Applicative.ZipList
instance Linear.Vector.Additive Data.Vector.Vector
instance Linear.Vector.Additive GHC.Maybe.Maybe
instance Linear.Vector.Additive []
instance Linear.Vector.Additive Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord k => Linear.Vector.Additive (Data.Map.Internal.Map k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Linear.Vector.Additive (Data.HashMap.Internal.HashMap k)
instance Linear.Vector.Additive ((->) b)
instance Linear.Vector.Additive Data.Complex.Complex
instance Linear.Vector.Additive Data.Functor.Identity.Identity
instance Linear.Vector.GAdditive GHC.Generics.U1
instance (Linear.Vector.GAdditive f, Linear.Vector.GAdditive g) => Linear.Vector.GAdditive (f GHC.Generics.:*: g)
instance Linear.Vector.GAdditive f => Linear.Vector.GAdditive (GHC.Generics.M1 i c f)
instance Linear.Vector.GAdditive GHC.Generics.Par1


-- | Free metric spaces
module Linear.Metric

-- | Free and sparse inner product/metric spaces.
class Additive f => Metric f

-- | Compute the inner product of two vectors or (equivalently) convert a
--   vector <tt>f a</tt> into a covector <tt>f a -&gt; a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 `dot` V2 3 4
--   11
--   </pre>
dot :: (Metric f, Num a) => f a -> f a -> a

-- | Compute the inner product of two vectors or (equivalently) convert a
--   vector <tt>f a</tt> into a covector <tt>f a -&gt; a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 `dot` V2 3 4
--   11
--   </pre>
dot :: (Metric f, Foldable f, Num a) => f a -> f a -> a

-- | Compute the squared norm. The name quadrance arises from Norman J.
--   Wildberger's rational trigonometry.
quadrance :: (Metric f, Num a) => f a -> a

-- | Compute the quadrance of the difference
qd :: (Metric f, Num a) => f a -> f a -> a

-- | Compute the distance between two vectors in a metric space
distance :: (Metric f, Floating a) => f a -> f a -> a

-- | Compute the norm of a vector in a metric space
norm :: (Metric f, Floating a) => f a -> a

-- | Convert a non-zero vector to unit vector.
signorm :: (Metric f, Floating a) => f a -> f a

-- | Normalize a <a>Metric</a> functor to have unit <a>norm</a>. This
--   function does not change the functor if its <a>norm</a> is 0 or 1.
normalize :: (Floating a, Metric f, Epsilon a) => f a -> f a

-- | <tt>project u v</tt> computes the projection of <tt>v</tt> onto
--   <tt>u</tt>.
project :: (Metric v, Fractional a) => v a -> v a -> v a
instance (Linear.Metric.Metric f, Linear.Metric.Metric g) => Linear.Metric.Metric (Data.Functor.Product.Product f g)
instance (Linear.Metric.Metric f, Linear.Metric.Metric g) => Linear.Metric.Metric (Data.Functor.Compose.Compose f g)
instance Linear.Metric.Metric Data.Functor.Identity.Identity
instance Linear.Metric.Metric []
instance Linear.Metric.Metric GHC.Maybe.Maybe
instance Linear.Metric.Metric Control.Applicative.ZipList
instance Linear.Metric.Metric Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord k => Linear.Metric.Metric (Data.Map.Internal.Map k)
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Linear.Metric.Metric (Data.HashMap.Internal.HashMap k)
instance Linear.Metric.Metric Data.Vector.Vector


-- | n-D Vectors
module Linear.V
newtype V n a
V :: Vector a -> V n a
[toVector] :: V n a -> Vector a

-- | This can be used to generate a template haskell splice for a type
--   level version of a given <a>int</a>.
--   
--   This does not use GHC TypeLits, instead it generates a numeric type by
--   hand similar to the ones used in the "Functional Pearl: Implicit
--   Configurations" paper by Oleg Kiselyov and Chung-Chieh Shan.
--   
--   <tt>instance Num (Q Exp)</tt> provided in this package allows writing
--   <tt>$(3)</tt> instead of <tt>$(int 3)</tt>. Sometimes the two will
--   produce the same representation (if compiled without the
--   <tt>-DUSE_TYPE_LITS</tt> preprocessor directive).
int :: Int -> TypeQ
dim :: forall n a. Dim n => V n a -> Int
class Dim n
reflectDim :: Dim n => p n -> Int
reifyDim :: Int -> (forall (n :: *). Dim n => Proxy n -> r) -> r
reifyVector :: forall a r. Vector a -> (forall (n :: *). Dim n => V n a -> r) -> r
reifyDimNat :: Int -> (forall (n :: Nat). KnownNat n => Proxy n -> r) -> r
reifyVectorNat :: forall a r. Vector a -> (forall (n :: Nat). KnownNat n => V n a -> r) -> r
fromVector :: forall n a. Dim n => Vector a -> Maybe (V n a)
class Finite v where {
    type family Size (v :: * -> *) :: Nat;
}
toV :: Finite v => v a -> V (Size v) a
toV :: (Finite v, Foldable v) => v a -> V (Size v) a
fromV :: Finite v => V (Size v) a -> v a
_V :: (Finite u, Finite v) => Iso (V (Size u) a) (V (Size v) b) (u a) (v b)
_V' :: Finite v => Iso (V (Size v) a) (V (Size v) b) (v a) (v b)
instance forall k (n :: k). GHC.Generics.Generic1 (Linear.V.V n)
instance forall k (n :: k) a. GHC.Generics.Generic (Linear.V.V n a)
instance forall k (n :: k) a. Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Linear.V.V n a)
instance forall k (n :: k) a. GHC.Read.Read a => GHC.Read.Read (Linear.V.V n a)
instance forall k (n :: k) a. GHC.Show.Show a => GHC.Show.Show (Linear.V.V n a)
instance forall k (n :: k) a. GHC.Classes.Ord a => GHC.Classes.Ord (Linear.V.V n a)
instance forall k (n :: k) a. GHC.Classes.Eq a => GHC.Classes.Eq (Linear.V.V n a)
instance Data.Reflection.Reifies s GHC.Types.Int => Linear.V.Dim (Linear.V.ReifiedDim s)
instance Linear.V.Finite Data.Complex.Complex
instance Linear.V.Finite (Linear.V.V n)
instance forall k (n :: k) a. (Linear.V.Dim n, System.Random.Random a) => System.Random.Random (Linear.V.V n a)
instance forall k (n :: k) a. Linear.V.Dim n => Linear.V.Dim (Linear.V.V n a)
instance forall k (n :: k) a. (Linear.V.Dim n, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Linear.V.V n a)
instance forall k (n :: k) a. (Linear.V.Dim n, GHC.Base.Monoid a) => GHC.Base.Monoid (Linear.V.V n a)
instance forall k (n :: k). GHC.Base.Functor (Linear.V.V n)
instance forall k (n :: k). WithIndex.FunctorWithIndex GHC.Types.Int (Linear.V.V n)
instance forall k (n :: k). Data.Foldable.Foldable (Linear.V.V n)
instance forall k (n :: k). WithIndex.FoldableWithIndex GHC.Types.Int (Linear.V.V n)
instance forall k (n :: k). Data.Traversable.Traversable (Linear.V.V n)
instance forall k (n :: k). WithIndex.TraversableWithIndex GHC.Types.Int (Linear.V.V n)
instance forall k (n :: k). Control.Lens.Indexed.FunctorWithIndex GHC.Types.Int (Linear.V.V n)
instance forall k (n :: k). Control.Lens.Indexed.FoldableWithIndex GHC.Types.Int (Linear.V.V n)
instance forall k (n :: k). Control.Lens.Indexed.TraversableWithIndex GHC.Types.Int (Linear.V.V n)
instance forall k (n :: k). Data.Functor.Bind.Class.Apply (Linear.V.V n)
instance forall k (n :: k). Linear.V.Dim n => GHC.Base.Applicative (Linear.V.V n)
instance forall k (n :: k). Data.Functor.Bind.Class.Bind (Linear.V.V n)
instance forall k (n :: k). Linear.V.Dim n => GHC.Base.Monad (Linear.V.V n)
instance forall k (n :: k). Linear.V.Dim n => Linear.Vector.Additive (Linear.V.V n)
instance forall k (n :: k) a. (Linear.V.Dim n, GHC.Num.Num a) => GHC.Num.Num (Linear.V.V n a)
instance forall k (n :: k) a. (Linear.V.Dim n, GHC.Real.Fractional a) => GHC.Real.Fractional (Linear.V.V n a)
instance forall k (n :: k) a. (Linear.V.Dim n, GHC.Float.Floating a) => GHC.Float.Floating (Linear.V.V n a)
instance forall k (n :: k). Linear.V.Dim n => Data.Distributive.Distributive (Linear.V.V n)
instance forall k a (n :: k). Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Linear.V.V n a)
instance forall k (n :: k). Linear.V.Dim n => Data.Hashable.Class.Hashable1 (Linear.V.V n)
instance forall k (n :: k) a. (Linear.V.Dim n, Foreign.Storable.Storable a) => Foreign.Storable.Storable (Linear.V.V n a)
instance forall k (n :: k) a. (Linear.V.Dim n, Linear.Epsilon.Epsilon a) => Linear.Epsilon.Epsilon (Linear.V.V n a)
instance forall k (n :: k). Linear.V.Dim n => Linear.Metric.Metric (Linear.V.V n)
instance forall k (n :: k). Linear.V.Dim n => Data.Functor.Rep.Representable (Linear.V.V n)
instance forall k (n :: k) a. Control.Lens.At.Ixed (Linear.V.V n a)
instance forall k (n :: k). Linear.V.Dim n => Control.Monad.Zip.MonadZip (Linear.V.V n)
instance forall k (n :: k). Linear.V.Dim n => Control.Monad.Fix.MonadFix (Linear.V.V n)
instance forall k (n :: k) a b. Control.Lens.Each.Each (Linear.V.V n a) (Linear.V.V n b) a b
instance forall k a (n :: k). (GHC.Enum.Bounded a, Linear.V.Dim n) => GHC.Enum.Bounded (Linear.V.V n a)
instance forall k (n :: k) a. (Data.Typeable.Internal.Typeable (Linear.V.V n), Data.Typeable.Internal.Typeable (Linear.V.V n a), Linear.V.Dim n, Data.Data.Data a) => Data.Data.Data (Linear.V.V n a)
instance forall k (n :: k). Linear.V.Dim n => Data.Bytes.Serial.Serial1 (Linear.V.V n)
instance forall k (n :: k) a. (Linear.V.Dim n, Data.Bytes.Serial.Serial a) => Data.Bytes.Serial.Serial (Linear.V.V n a)
instance forall k (n :: k) a. (Linear.V.Dim n, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Linear.V.V n a)
instance forall k (n :: k) a. (Linear.V.Dim n, Data.Serialize.Serialize a) => Data.Serialize.Serialize (Linear.V.V n a)
instance forall k (n :: k). Data.Functor.Classes.Eq1 (Linear.V.V n)
instance forall k (n :: k). Data.Functor.Classes.Ord1 (Linear.V.V n)
instance forall k (n :: k). Data.Functor.Classes.Show1 (Linear.V.V n)
instance forall k (n :: k). Linear.V.Dim n => Data.Functor.Classes.Read1 (Linear.V.V n)
instance forall k (n :: k) a. (Linear.V.Dim n, Data.Vector.Unboxed.Base.Unbox a) => Data.Vector.Unboxed.Base.Unbox (Linear.V.V n a)
instance forall k (n :: k) a. (Linear.V.Dim n, Data.Vector.Unboxed.Base.Unbox a) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Linear.V.V n a)
instance forall k (n :: k) a. (Linear.V.Dim n, Data.Vector.Unboxed.Base.Unbox a) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Linear.V.V n a)
instance (1 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field1 (Linear.V.V n a) (Linear.V.V n a) a a
instance (2 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field2 (Linear.V.V n a) (Linear.V.V n a) a a
instance (3 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field3 (Linear.V.V n a) (Linear.V.V n a) a a
instance (4 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field4 (Linear.V.V n a) (Linear.V.V n a) a a
instance (5 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field5 (Linear.V.V n a) (Linear.V.V n a) a a
instance (6 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field6 (Linear.V.V n a) (Linear.V.V n a) a a
instance (7 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field7 (Linear.V.V n a) (Linear.V.V n a) a a
instance (8 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field8 (Linear.V.V n a) (Linear.V.V n a) a a
instance (9 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field9 (Linear.V.V n a) (Linear.V.V n a) a a
instance (10 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field10 (Linear.V.V n a) (Linear.V.V n a) a a
instance (11 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field11 (Linear.V.V n a) (Linear.V.V n a) a a
instance (12 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field12 (Linear.V.V n a) (Linear.V.V n a) a a
instance (13 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field13 (Linear.V.V n a) (Linear.V.V n a) a a
instance (14 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field14 (Linear.V.V n a) (Linear.V.V n a) a a
instance (15 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field15 (Linear.V.V n a) (Linear.V.V n a) a a
instance (16 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field16 (Linear.V.V n a) (Linear.V.V n a) a a
instance (17 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field17 (Linear.V.V n a) (Linear.V.V n a) a a
instance (18 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field18 (Linear.V.V n a) (Linear.V.V n a) a a
instance (19 GHC.TypeNats.<= n) => Control.Lens.Tuple.Field19 (Linear.V.V n a) (Linear.V.V n a) a a
instance GHC.TypeNats.KnownNat n => Linear.V.Dim n


-- | 1-D Vectors
module Linear.V1

-- | A 1-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V1 Int
--   V1 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 + V1 3
--   V1 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 * V1 3
--   V1 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum (V1 2)
--   2
--   </pre>
newtype V1 a
V1 :: a -> V1 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t

-- | <pre>
--   &gt;&gt;&gt; V1 2 ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 &amp; _x .~ 3
--   V1 3
--   </pre>
_x :: R1 t => Lens' (t a) a
ex :: R1 t => E t
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Linear.V1.V1 a)
instance GHC.Generics.Generic1 Linear.V1.V1
instance GHC.Generics.Generic (Linear.V1.V1 a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Linear.V1.V1 a)
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Linear.V1.V1 a)
instance Linear.Epsilon.Epsilon a => Linear.Epsilon.Epsilon (Linear.V1.V1 a)
instance Data.Traversable.Traversable Linear.V1.V1
instance GHC.Base.Functor Linear.V1.V1
instance Data.Data.Data a => Data.Data.Data (Linear.V1.V1 a)
instance GHC.Read.Read a => GHC.Read.Read (Linear.V1.V1 a)
instance GHC.Show.Show a => GHC.Show.Show (Linear.V1.V1 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Linear.V1.V1 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Linear.V1.V1 a)
instance Linear.V1.R1 Linear.V1.V1
instance Linear.V1.R1 Data.Functor.Identity.Identity
instance Data.Foldable.Foldable Linear.V1.V1
instance Linear.V.Finite Linear.V1.V1
instance Data.Semigroup.Foldable.Class.Foldable1 Linear.V1.V1
instance Data.Semigroup.Traversable.Class.Traversable1 Linear.V1.V1
instance Data.Functor.Bind.Class.Apply Linear.V1.V1
instance GHC.Base.Applicative Linear.V1.V1
instance Linear.Vector.Additive Linear.V1.V1
instance Data.Functor.Bind.Class.Bind Linear.V1.V1
instance GHC.Base.Monad Linear.V1.V1
instance GHC.Num.Num a => GHC.Num.Num (Linear.V1.V1 a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Linear.V1.V1 a)
instance GHC.Float.Floating a => GHC.Float.Floating (Linear.V1.V1 a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Linear.V1.V1 a)
instance Data.Hashable.Class.Hashable1 Linear.V1.V1
instance Linear.Metric.Metric Linear.V1.V1
instance Data.Distributive.Distributive Linear.V1.V1
instance GHC.Ix.Ix a => GHC.Ix.Ix (Linear.V1.V1 a)
instance Data.Functor.Rep.Representable Linear.V1.V1
instance WithIndex.FunctorWithIndex (Linear.Vector.E Linear.V1.V1) Linear.V1.V1
instance WithIndex.FoldableWithIndex (Linear.Vector.E Linear.V1.V1) Linear.V1.V1
instance WithIndex.TraversableWithIndex (Linear.Vector.E Linear.V1.V1) Linear.V1.V1
instance Control.Lens.Indexed.FunctorWithIndex (Linear.Vector.E Linear.V1.V1) Linear.V1.V1
instance Control.Lens.Indexed.FoldableWithIndex (Linear.Vector.E Linear.V1.V1) Linear.V1.V1
instance Control.Lens.Indexed.TraversableWithIndex (Linear.Vector.E Linear.V1.V1) Linear.V1.V1
instance Control.Lens.At.Ixed (Linear.V1.V1 a)
instance Control.Lens.Each.Each (Linear.V1.V1 a) (Linear.V1.V1 b) a b
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Linear.V1.V1 a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Linear.V1.V1 a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Linear.V1.V1 a)
instance Control.Monad.Zip.MonadZip Linear.V1.V1
instance Control.Monad.Fix.MonadFix Linear.V1.V1
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Linear.V1.V1 a)
instance Data.Bytes.Serial.Serial1 Linear.V1.V1
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Linear.V1.V1 a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Linear.V1.V1 a)
instance Data.Serialize.Serialize a => Data.Serialize.Serialize (Linear.V1.V1 a)
instance System.Random.Random a => System.Random.Random (Linear.V1.V1 a)
instance Data.Functor.Classes.Eq1 Linear.V1.V1
instance Data.Functor.Classes.Ord1 Linear.V1.V1
instance Data.Functor.Classes.Show1 Linear.V1.V1
instance Data.Functor.Classes.Read1 Linear.V1.V1
instance Control.Lens.Tuple.Field1 (Linear.V1.V1 a) (Linear.V1.V1 b) a b
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Linear.V1.V1 a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Linear.V1.V1 a)


-- | 2-D Vectors
module Linear.V2

-- | A 2-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V2 Int
--   V2 1 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 + V2 3 4
--   V2 4 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 * V2 3 4
--   V2 3 8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum (V2 1 2)
--   3
--   </pre>
data V2 a
V2 :: !a -> !a -> V2 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t

-- | <pre>
--   &gt;&gt;&gt; V1 2 ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 &amp; _x .~ 3
--   V1 3
--   </pre>
_x :: R1 t => Lens' (t a) a

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class R1 t => R2 t

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^._y
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 &amp; _y .~ 3
--   V2 1 3
--   </pre>
_y :: R2 t => Lens' (t a) a
_xy :: R2 t => Lens' (t a) (V2 a)

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^. _yx
--   V2 2 1
--   </pre>
_yx :: R2 t => Lens' (t a) (V2 a)
ex :: R1 t => E t
ey :: R2 t => E t

-- | the counter-clockwise perpendicular vector
--   
--   <pre>
--   &gt;&gt;&gt; perp $ V2 10 20
--   V2 (-20) 10
--   </pre>
perp :: Num a => V2 a -> V2 a
angle :: Floating a => a -> V2 a
unangle :: (Floating a, Ord a) => V2 a -> a

-- | The Z-component of the cross product of two vectors in the XY-plane.
--   
--   <pre>
--   &gt;&gt;&gt; crossZ (V2 1 0) (V2 0 1)
--   1
--   </pre>
crossZ :: Num a => V2 a -> V2 a -> a
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Linear.V2.V2 a)
instance GHC.Generics.Generic1 Linear.V2.V2
instance GHC.Generics.Generic (Linear.V2.V2 a)
instance Data.Data.Data a => Data.Data.Data (Linear.V2.V2 a)
instance GHC.Read.Read a => GHC.Read.Read (Linear.V2.V2 a)
instance GHC.Show.Show a => GHC.Show.Show (Linear.V2.V2 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Linear.V2.V2 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Linear.V2.V2 a)
instance Linear.V2.R2 Linear.V2.V2
instance Linear.V.Finite Linear.V2.V2
instance System.Random.Random a => System.Random.Random (Linear.V2.V2 a)
instance GHC.Base.Functor Linear.V2.V2
instance Data.Foldable.Foldable Linear.V2.V2
instance Data.Traversable.Traversable Linear.V2.V2
instance Data.Semigroup.Foldable.Class.Foldable1 Linear.V2.V2
instance Data.Semigroup.Traversable.Class.Traversable1 Linear.V2.V2
instance Data.Functor.Bind.Class.Apply Linear.V2.V2
instance GHC.Base.Applicative Linear.V2.V2
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Linear.V2.V2 a)
instance Data.Hashable.Class.Hashable1 Linear.V2.V2
instance Linear.Vector.Additive Linear.V2.V2
instance Data.Functor.Bind.Class.Bind Linear.V2.V2
instance GHC.Base.Monad Linear.V2.V2
instance GHC.Num.Num a => GHC.Num.Num (Linear.V2.V2 a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Linear.V2.V2 a)
instance GHC.Float.Floating a => GHC.Float.Floating (Linear.V2.V2 a)
instance Linear.Metric.Metric Linear.V2.V2
instance Linear.V1.R1 Linear.V2.V2
instance Data.Distributive.Distributive Linear.V2.V2
instance Linear.Epsilon.Epsilon a => Linear.Epsilon.Epsilon (Linear.V2.V2 a)
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Linear.V2.V2 a)
instance GHC.Ix.Ix a => GHC.Ix.Ix (Linear.V2.V2 a)
instance Data.Functor.Rep.Representable Linear.V2.V2
instance WithIndex.FunctorWithIndex (Linear.Vector.E Linear.V2.V2) Linear.V2.V2
instance WithIndex.FoldableWithIndex (Linear.Vector.E Linear.V2.V2) Linear.V2.V2
instance WithIndex.TraversableWithIndex (Linear.Vector.E Linear.V2.V2) Linear.V2.V2
instance Control.Lens.Indexed.FunctorWithIndex (Linear.Vector.E Linear.V2.V2) Linear.V2.V2
instance Control.Lens.Indexed.FoldableWithIndex (Linear.Vector.E Linear.V2.V2) Linear.V2.V2
instance Control.Lens.Indexed.TraversableWithIndex (Linear.Vector.E Linear.V2.V2) Linear.V2.V2
instance Control.Lens.At.Ixed (Linear.V2.V2 a)
instance Control.Lens.Each.Each (Linear.V2.V2 a) (Linear.V2.V2 b) a b
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Linear.V2.V2 a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Linear.V2.V2 a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Linear.V2.V2 a)
instance Control.Monad.Zip.MonadZip Linear.V2.V2
instance Control.Monad.Fix.MonadFix Linear.V2.V2
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Linear.V2.V2 a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Linear.V2.V2 a)
instance Data.Bytes.Serial.Serial1 Linear.V2.V2
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Linear.V2.V2 a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Linear.V2.V2 a)
instance Data.Serialize.Serialize a => Data.Serialize.Serialize (Linear.V2.V2 a)
instance Data.Functor.Classes.Eq1 Linear.V2.V2
instance Data.Functor.Classes.Ord1 Linear.V2.V2
instance Data.Functor.Classes.Read1 Linear.V2.V2
instance Data.Functor.Classes.Show1 Linear.V2.V2
instance Control.Lens.Tuple.Field1 (Linear.V2.V2 a) (Linear.V2.V2 a) a a
instance Control.Lens.Tuple.Field2 (Linear.V2.V2 a) (Linear.V2.V2 a) a a
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Linear.V2.V2 a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Linear.V2.V2 a)


-- | 3-D Vectors
module Linear.V3

-- | A 3-dimensional vector
data V3 a
V3 :: !a -> !a -> !a -> V3 a

-- | cross product
cross :: Num a => V3 a -> V3 a -> V3 a

-- | scalar triple product
triple :: Num a => V3 a -> V3 a -> V3 a -> a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t

-- | <pre>
--   &gt;&gt;&gt; V1 2 ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 &amp; _x .~ 3
--   V1 3
--   </pre>
_x :: R1 t => Lens' (t a) a

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class R1 t => R2 t

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^._y
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 &amp; _y .~ 3
--   V2 1 3
--   </pre>
_y :: R2 t => Lens' (t a) a
_xy :: R2 t => Lens' (t a) (V2 a)

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^. _yx
--   V2 2 1
--   </pre>
_yx :: R2 t => Lens' (t a) (V2 a)

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (It may have more)
class R2 t => R3 t

-- | <pre>
--   &gt;&gt;&gt; V3 1 2 3 ^. _z
--   3
--   </pre>
_z :: R3 t => Lens' (t a) a
_xyz :: R3 t => Lens' (t a) (V3 a)
_xz :: R3 t => Lens' (t a) (V2 a)
_yz :: R3 t => Lens' (t a) (V2 a)
_zx :: R3 t => Lens' (t a) (V2 a)
_zy :: R3 t => Lens' (t a) (V2 a)
_xzy :: R3 t => Lens' (t a) (V3 a)
_yxz :: R3 t => Lens' (t a) (V3 a)
_yzx :: R3 t => Lens' (t a) (V3 a)
_zxy :: R3 t => Lens' (t a) (V3 a)
_zyx :: R3 t => Lens' (t a) (V3 a)
ex :: R1 t => E t
ey :: R2 t => E t
ez :: R3 t => E t
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Linear.V3.V3 a)
instance GHC.Generics.Generic1 Linear.V3.V3
instance GHC.Generics.Generic (Linear.V3.V3 a)
instance Data.Data.Data a => Data.Data.Data (Linear.V3.V3 a)
instance GHC.Read.Read a => GHC.Read.Read (Linear.V3.V3 a)
instance GHC.Show.Show a => GHC.Show.Show (Linear.V3.V3 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Linear.V3.V3 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Linear.V3.V3 a)
instance Linear.V3.R3 Linear.V3.V3
instance Linear.V.Finite Linear.V3.V3
instance GHC.Base.Functor Linear.V3.V3
instance Data.Foldable.Foldable Linear.V3.V3
instance System.Random.Random a => System.Random.Random (Linear.V3.V3 a)
instance Data.Traversable.Traversable Linear.V3.V3
instance Data.Semigroup.Foldable.Class.Foldable1 Linear.V3.V3
instance Data.Semigroup.Traversable.Class.Traversable1 Linear.V3.V3
instance Data.Functor.Bind.Class.Apply Linear.V3.V3
instance GHC.Base.Applicative Linear.V3.V3
instance Linear.Vector.Additive Linear.V3.V3
instance Data.Functor.Bind.Class.Bind Linear.V3.V3
instance GHC.Base.Monad Linear.V3.V3
instance GHC.Num.Num a => GHC.Num.Num (Linear.V3.V3 a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Linear.V3.V3 a)
instance GHC.Float.Floating a => GHC.Float.Floating (Linear.V3.V3 a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Linear.V3.V3 a)
instance Data.Hashable.Class.Hashable1 Linear.V3.V3
instance Linear.Metric.Metric Linear.V3.V3
instance Data.Distributive.Distributive Linear.V3.V3
instance Linear.V1.R1 Linear.V3.V3
instance Linear.V2.R2 Linear.V3.V3
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Linear.V3.V3 a)
instance Linear.Epsilon.Epsilon a => Linear.Epsilon.Epsilon (Linear.V3.V3 a)
instance GHC.Ix.Ix a => GHC.Ix.Ix (Linear.V3.V3 a)
instance Data.Functor.Rep.Representable Linear.V3.V3
instance WithIndex.FunctorWithIndex (Linear.Vector.E Linear.V3.V3) Linear.V3.V3
instance WithIndex.FoldableWithIndex (Linear.Vector.E Linear.V3.V3) Linear.V3.V3
instance WithIndex.TraversableWithIndex (Linear.Vector.E Linear.V3.V3) Linear.V3.V3
instance Control.Lens.Indexed.FunctorWithIndex (Linear.Vector.E Linear.V3.V3) Linear.V3.V3
instance Control.Lens.Indexed.FoldableWithIndex (Linear.Vector.E Linear.V3.V3) Linear.V3.V3
instance Control.Lens.Indexed.TraversableWithIndex (Linear.Vector.E Linear.V3.V3) Linear.V3.V3
instance Control.Lens.At.Ixed (Linear.V3.V3 a)
instance Control.Lens.Each.Each (Linear.V3.V3 a) (Linear.V3.V3 b) a b
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Linear.V3.V3 a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Linear.V3.V3 a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Linear.V3.V3 a)
instance Control.Monad.Zip.MonadZip Linear.V3.V3
instance Control.Monad.Fix.MonadFix Linear.V3.V3
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Linear.V3.V3 a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Linear.V3.V3 a)
instance Data.Bytes.Serial.Serial1 Linear.V3.V3
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Linear.V3.V3 a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Linear.V3.V3 a)
instance Data.Serialize.Serialize a => Data.Serialize.Serialize (Linear.V3.V3 a)
instance Data.Functor.Classes.Eq1 Linear.V3.V3
instance Data.Functor.Classes.Ord1 Linear.V3.V3
instance Data.Functor.Classes.Read1 Linear.V3.V3
instance Data.Functor.Classes.Show1 Linear.V3.V3
instance Control.Lens.Tuple.Field1 (Linear.V3.V3 a) (Linear.V3.V3 a) a a
instance Control.Lens.Tuple.Field2 (Linear.V3.V3 a) (Linear.V3.V3 a) a a
instance Control.Lens.Tuple.Field3 (Linear.V3.V3 a) (Linear.V3.V3 a) a a
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Linear.V3.V3 a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Linear.V3.V3 a)


-- | 4-D Vectors
module Linear.V4

-- | A 4-dimensional vector.
data V4 a
V4 :: !a -> !a -> !a -> !a -> V4 a

-- | Convert a 3-dimensional affine vector into a 4-dimensional homogeneous
--   vector, i.e. sets the <tt>w</tt> coordinate to 0.
vector :: Num a => V3 a -> V4 a

-- | Convert a 3-dimensional affine point into a 4-dimensional homogeneous
--   vector, i.e. sets the <tt>w</tt> coordinate to 1.
point :: Num a => V3 a -> V4 a

-- | Convert 4-dimensional projective coordinates to a 3-dimensional point.
--   This operation may be denoted, <tt>euclidean [x:y:z:w] = (x/w, y/w,
--   z/w)</tt> where the projective, homogenous, coordinate
--   <tt>[x:y:z:w]</tt> is one of many associated with a single point
--   <tt>(x/w, y/w, z/w)</tt>.
normalizePoint :: Fractional a => V4 a -> V3 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 t

-- | <pre>
--   &gt;&gt;&gt; V1 2 ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 &amp; _x .~ 3
--   V1 3
--   </pre>
_x :: R1 t => Lens' (t a) a

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class R1 t => R2 t

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^._y
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 &amp; _y .~ 3
--   V2 1 3
--   </pre>
_y :: R2 t => Lens' (t a) a
_xy :: R2 t => Lens' (t a) (V2 a)

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^. _yx
--   V2 2 1
--   </pre>
_yx :: R2 t => Lens' (t a) (V2 a)

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (It may have more)
class R2 t => R3 t

-- | <pre>
--   &gt;&gt;&gt; V3 1 2 3 ^. _z
--   3
--   </pre>
_z :: R3 t => Lens' (t a) a
_xyz :: R3 t => Lens' (t a) (V3 a)
_xz :: R3 t => Lens' (t a) (V2 a)
_yz :: R3 t => Lens' (t a) (V2 a)
_zx :: R3 t => Lens' (t a) (V2 a)
_zy :: R3 t => Lens' (t a) (V2 a)
_xzy :: R3 t => Lens' (t a) (V3 a)
_yxz :: R3 t => Lens' (t a) (V3 a)
_yzx :: R3 t => Lens' (t a) (V3 a)
_zxy :: R3 t => Lens' (t a) (V3 a)
_zyx :: R3 t => Lens' (t a) (V3 a)

-- | A space that distinguishes orthogonal basis vectors <a>_x</a>,
--   <a>_y</a>, <a>_z</a>, <a>_w</a>. (It may have more.)
class R3 t => R4 t

-- | <pre>
--   &gt;&gt;&gt; V4 1 2 3 4 ^._w
--   4
--   </pre>
_w :: R4 t => Lens' (t a) a
_xyzw :: R4 t => Lens' (t a) (V4 a)
_xw :: R4 t => Lens' (t a) (V2 a)
_yw :: R4 t => Lens' (t a) (V2 a)
_zw :: R4 t => Lens' (t a) (V2 a)
_wx :: R4 t => Lens' (t a) (V2 a)
_wy :: R4 t => Lens' (t a) (V2 a)
_wz :: R4 t => Lens' (t a) (V2 a)
_xyw :: R4 t => Lens' (t a) (V3 a)
_xzw :: R4 t => Lens' (t a) (V3 a)
_xwy :: R4 t => Lens' (t a) (V3 a)
_xwz :: R4 t => Lens' (t a) (V3 a)
_yxw :: R4 t => Lens' (t a) (V3 a)
_yzw :: R4 t => Lens' (t a) (V3 a)
_ywx :: R4 t => Lens' (t a) (V3 a)
_ywz :: R4 t => Lens' (t a) (V3 a)
_zxw :: R4 t => Lens' (t a) (V3 a)
_zyw :: R4 t => Lens' (t a) (V3 a)
_zwx :: R4 t => Lens' (t a) (V3 a)
_zwy :: R4 t => Lens' (t a) (V3 a)
_wxy :: R4 t => Lens' (t a) (V3 a)
_wxz :: R4 t => Lens' (t a) (V3 a)
_wyx :: R4 t => Lens' (t a) (V3 a)
_wyz :: R4 t => Lens' (t a) (V3 a)
_wzx :: R4 t => Lens' (t a) (V3 a)
_wzy :: R4 t => Lens' (t a) (V3 a)
_xywz :: R4 t => Lens' (t a) (V4 a)
_xzyw :: R4 t => Lens' (t a) (V4 a)
_xzwy :: R4 t => Lens' (t a) (V4 a)
_xwyz :: R4 t => Lens' (t a) (V4 a)
_xwzy :: R4 t => Lens' (t a) (V4 a)
_yxzw :: R4 t => Lens' (t a) (V4 a)
_yxwz :: R4 t => Lens' (t a) (V4 a)
_yzxw :: R4 t => Lens' (t a) (V4 a)
_yzwx :: R4 t => Lens' (t a) (V4 a)
_ywxz :: R4 t => Lens' (t a) (V4 a)
_ywzx :: R4 t => Lens' (t a) (V4 a)
_zxyw :: R4 t => Lens' (t a) (V4 a)
_zxwy :: R4 t => Lens' (t a) (V4 a)
_zyxw :: R4 t => Lens' (t a) (V4 a)
_zywx :: R4 t => Lens' (t a) (V4 a)
_zwxy :: R4 t => Lens' (t a) (V4 a)
_zwyx :: R4 t => Lens' (t a) (V4 a)
_wxyz :: R4 t => Lens' (t a) (V4 a)
_wxzy :: R4 t => Lens' (t a) (V4 a)
_wyxz :: R4 t => Lens' (t a) (V4 a)
_wyzx :: R4 t => Lens' (t a) (V4 a)
_wzxy :: R4 t => Lens' (t a) (V4 a)
_wzyx :: R4 t => Lens' (t a) (V4 a)
ex :: R1 t => E t
ey :: R2 t => E t
ez :: R3 t => E t
ew :: R4 t => E t
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Linear.V4.V4 a)
instance GHC.Generics.Generic1 Linear.V4.V4
instance GHC.Generics.Generic (Linear.V4.V4 a)
instance Data.Data.Data a => Data.Data.Data (Linear.V4.V4 a)
instance GHC.Read.Read a => GHC.Read.Read (Linear.V4.V4 a)
instance GHC.Show.Show a => GHC.Show.Show (Linear.V4.V4 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Linear.V4.V4 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Linear.V4.V4 a)
instance Linear.V4.R4 Linear.V4.V4
instance Linear.V.Finite Linear.V4.V4
instance GHC.Base.Functor Linear.V4.V4
instance Data.Foldable.Foldable Linear.V4.V4
instance System.Random.Random a => System.Random.Random (Linear.V4.V4 a)
instance Data.Traversable.Traversable Linear.V4.V4
instance Data.Semigroup.Foldable.Class.Foldable1 Linear.V4.V4
instance Data.Semigroup.Traversable.Class.Traversable1 Linear.V4.V4
instance GHC.Base.Applicative Linear.V4.V4
instance Data.Functor.Bind.Class.Apply Linear.V4.V4
instance Linear.Vector.Additive Linear.V4.V4
instance Data.Functor.Bind.Class.Bind Linear.V4.V4
instance GHC.Base.Monad Linear.V4.V4
instance GHC.Num.Num a => GHC.Num.Num (Linear.V4.V4 a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Linear.V4.V4 a)
instance GHC.Float.Floating a => GHC.Float.Floating (Linear.V4.V4 a)
instance Linear.Metric.Metric Linear.V4.V4
instance Data.Distributive.Distributive Linear.V4.V4
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Linear.V4.V4 a)
instance Data.Hashable.Class.Hashable1 Linear.V4.V4
instance Linear.V1.R1 Linear.V4.V4
instance Linear.V2.R2 Linear.V4.V4
instance Linear.V3.R3 Linear.V4.V4
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Linear.V4.V4 a)
instance Linear.Epsilon.Epsilon a => Linear.Epsilon.Epsilon (Linear.V4.V4 a)
instance GHC.Ix.Ix a => GHC.Ix.Ix (Linear.V4.V4 a)
instance Data.Functor.Rep.Representable Linear.V4.V4
instance WithIndex.FunctorWithIndex (Linear.Vector.E Linear.V4.V4) Linear.V4.V4
instance WithIndex.FoldableWithIndex (Linear.Vector.E Linear.V4.V4) Linear.V4.V4
instance WithIndex.TraversableWithIndex (Linear.Vector.E Linear.V4.V4) Linear.V4.V4
instance Control.Lens.Indexed.FunctorWithIndex (Linear.Vector.E Linear.V4.V4) Linear.V4.V4
instance Control.Lens.Indexed.FoldableWithIndex (Linear.Vector.E Linear.V4.V4) Linear.V4.V4
instance Control.Lens.Indexed.TraversableWithIndex (Linear.Vector.E Linear.V4.V4) Linear.V4.V4
instance Control.Lens.At.Ixed (Linear.V4.V4 a)
instance Control.Lens.Each.Each (Linear.V4.V4 a) (Linear.V4.V4 b) a b
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Linear.V4.V4 a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Linear.V4.V4 a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Linear.V4.V4 a)
instance Control.Monad.Zip.MonadZip Linear.V4.V4
instance Control.Monad.Fix.MonadFix Linear.V4.V4
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Linear.V4.V4 a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Linear.V4.V4 a)
instance Data.Bytes.Serial.Serial1 Linear.V4.V4
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Linear.V4.V4 a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Linear.V4.V4 a)
instance Data.Serialize.Serialize a => Data.Serialize.Serialize (Linear.V4.V4 a)
instance Data.Functor.Classes.Eq1 Linear.V4.V4
instance Data.Functor.Classes.Ord1 Linear.V4.V4
instance Data.Functor.Classes.Read1 Linear.V4.V4
instance Data.Functor.Classes.Show1 Linear.V4.V4
instance Control.Lens.Tuple.Field1 (Linear.V4.V4 a) (Linear.V4.V4 a) a a
instance Control.Lens.Tuple.Field2 (Linear.V4.V4 a) (Linear.V4.V4 a) a a
instance Control.Lens.Tuple.Field3 (Linear.V4.V4 a) (Linear.V4.V4 a) a a
instance Control.Lens.Tuple.Field4 (Linear.V4.V4 a) (Linear.V4.V4 a) a a
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Linear.V4.V4 a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Linear.V4.V4 a)


-- | 0-D Vectors
module Linear.V0

-- | A 0-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V0 Int
--   V0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V0 + V0
--   V0
--   </pre>
data V0 a
V0 :: V0 a
instance Language.Haskell.TH.Syntax.Lift (Linear.V0.V0 a)
instance GHC.Generics.Generic1 Linear.V0.V0
instance GHC.Generics.Generic (Linear.V0.V0 a)
instance Data.Data.Data a => Data.Data.Data (Linear.V0.V0 a)
instance GHC.Enum.Enum (Linear.V0.V0 a)
instance GHC.Ix.Ix (Linear.V0.V0 a)
instance GHC.Read.Read (Linear.V0.V0 a)
instance GHC.Show.Show (Linear.V0.V0 a)
instance GHC.Classes.Ord (Linear.V0.V0 a)
instance GHC.Classes.Eq (Linear.V0.V0 a)
instance Linear.V.Finite Linear.V0.V0
instance System.Random.Random (Linear.V0.V0 a)
instance Data.Bytes.Serial.Serial1 Linear.V0.V0
instance Data.Bytes.Serial.Serial (Linear.V0.V0 a)
instance Data.Binary.Class.Binary (Linear.V0.V0 a)
instance Data.Serialize.Serialize (Linear.V0.V0 a)
instance GHC.Base.Functor Linear.V0.V0
instance Data.Foldable.Foldable Linear.V0.V0
instance Data.Traversable.Traversable Linear.V0.V0
instance Data.Functor.Bind.Class.Apply Linear.V0.V0
instance GHC.Base.Applicative Linear.V0.V0
instance GHC.Base.Semigroup (Linear.V0.V0 a)
instance GHC.Base.Monoid (Linear.V0.V0 a)
instance Linear.Vector.Additive Linear.V0.V0
instance Data.Functor.Bind.Class.Bind Linear.V0.V0
instance GHC.Base.Monad Linear.V0.V0
instance GHC.Num.Num (Linear.V0.V0 a)
instance GHC.Real.Fractional (Linear.V0.V0 a)
instance GHC.Float.Floating (Linear.V0.V0 a)
instance Linear.Metric.Metric Linear.V0.V0
instance Data.Distributive.Distributive Linear.V0.V0
instance Data.Hashable.Class.Hashable (Linear.V0.V0 a)
instance Data.Hashable.Class.Hashable1 Linear.V0.V0
instance Linear.Epsilon.Epsilon (Linear.V0.V0 a)
instance Foreign.Storable.Storable (Linear.V0.V0 a)
instance WithIndex.FunctorWithIndex (Linear.Vector.E Linear.V0.V0) Linear.V0.V0
instance WithIndex.FoldableWithIndex (Linear.Vector.E Linear.V0.V0) Linear.V0.V0
instance WithIndex.TraversableWithIndex (Linear.Vector.E Linear.V0.V0) Linear.V0.V0
instance Control.Lens.Indexed.FunctorWithIndex (Linear.Vector.E Linear.V0.V0) Linear.V0.V0
instance Control.Lens.Indexed.FoldableWithIndex (Linear.Vector.E Linear.V0.V0) Linear.V0.V0
instance Control.Lens.Indexed.TraversableWithIndex (Linear.Vector.E Linear.V0.V0) Linear.V0.V0
instance Data.Functor.Rep.Representable Linear.V0.V0
instance Control.Lens.At.Ixed (Linear.V0.V0 a)
instance Control.Lens.Each.Each (Linear.V0.V0 a) (Linear.V0.V0 b) a b
instance Data.Vector.Unboxed.Base.Unbox (Linear.V0.V0 a)
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Linear.V0.V0 a)
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Linear.V0.V0 a)
instance Control.Monad.Zip.MonadZip Linear.V0.V0
instance Control.Monad.Fix.MonadFix Linear.V0.V0
instance GHC.Enum.Bounded (Linear.V0.V0 a)
instance Control.DeepSeq.NFData (Linear.V0.V0 a)
instance Data.Functor.Classes.Eq1 Linear.V0.V0
instance Data.Functor.Classes.Ord1 Linear.V0.V0
instance Data.Functor.Classes.Show1 Linear.V0.V0
instance Data.Functor.Classes.Read1 Linear.V0.V0


-- | Quaternions
module Linear.Quaternion

-- | Quaternions
data Quaternion a
Quaternion :: !a -> {-# UNPACK #-} !V3 a -> Quaternion a

-- | A vector space that includes the basis elements <a>_e</a> and
--   <a>_i</a>
class Complicated t
_e :: Complicated t => Lens' (t a) a
_i :: Complicated t => Lens' (t a) a

-- | A vector space that includes the basis elements <a>_e</a>, <a>_i</a>,
--   <a>_j</a> and <a>_k</a>
class Complicated t => Hamiltonian t
_j :: Hamiltonian t => Lens' (t a) a
_k :: Hamiltonian t => Lens' (t a) a
_ijk :: Hamiltonian t => Lens' (t a) (V3 a)
ee :: Complicated t => E t
ei :: Complicated t => E t
ej :: Hamiltonian t => E t
ek :: Hamiltonian t => E t

-- | Spherical linear interpolation between two quaternions.
slerp :: RealFloat a => Quaternion a -> Quaternion a -> a -> Quaternion a

-- | <a>asin</a> with a specified branch cut.
asinq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | <a>acos</a> with a specified branch cut.
acosq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | <a>atan</a> with a specified branch cut.
atanq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | <a>asinh</a> with a specified branch cut.
asinhq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | <a>acosh</a> with a specified branch cut.
acoshq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | <a>atanh</a> with a specified branch cut.
atanhq :: RealFloat a => Quaternion a -> Quaternion a -> Quaternion a

-- | norm of the imaginary component
absi :: Floating a => Quaternion a -> a

-- | raise a <a>Quaternion</a> to a scalar power
pow :: RealFloat a => Quaternion a -> a -> Quaternion a

-- | Apply a rotation to a vector.
rotate :: (Conjugate a, RealFloat a) => Quaternion a -> V3 a -> V3 a

-- | <tt><a>axisAngle</a> axis theta</tt> builds a <a>Quaternion</a>
--   representing a rotation of <tt>theta</tt> radians about <tt>axis</tt>.
axisAngle :: (Epsilon a, Floating a) => V3 a -> a -> Quaternion a
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Linear.Quaternion.Quaternion a)
instance GHC.Generics.Generic1 Linear.Quaternion.Quaternion
instance GHC.Generics.Generic (Linear.Quaternion.Quaternion a)
instance Data.Data.Data a => Data.Data.Data (Linear.Quaternion.Quaternion a)
instance GHC.Show.Show a => GHC.Show.Show (Linear.Quaternion.Quaternion a)
instance GHC.Read.Read a => GHC.Read.Read (Linear.Quaternion.Quaternion a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Linear.Quaternion.Quaternion a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Linear.Quaternion.Quaternion a)
instance Linear.Quaternion.Hamiltonian Linear.Quaternion.Quaternion
instance Linear.Quaternion.Complicated Data.Complex.Complex
instance Linear.Quaternion.Complicated Linear.Quaternion.Quaternion
instance Linear.V.Finite Linear.Quaternion.Quaternion
instance System.Random.Random a => System.Random.Random (Linear.Quaternion.Quaternion a)
instance GHC.Base.Functor Linear.Quaternion.Quaternion
instance Data.Functor.Bind.Class.Apply Linear.Quaternion.Quaternion
instance GHC.Base.Applicative Linear.Quaternion.Quaternion
instance Linear.Vector.Additive Linear.Quaternion.Quaternion
instance Data.Functor.Bind.Class.Bind Linear.Quaternion.Quaternion
instance GHC.Base.Monad Linear.Quaternion.Quaternion
instance GHC.Ix.Ix a => GHC.Ix.Ix (Linear.Quaternion.Quaternion a)
instance Data.Functor.Rep.Representable Linear.Quaternion.Quaternion
instance WithIndex.FunctorWithIndex (Linear.Vector.E Linear.Quaternion.Quaternion) Linear.Quaternion.Quaternion
instance WithIndex.FoldableWithIndex (Linear.Vector.E Linear.Quaternion.Quaternion) Linear.Quaternion.Quaternion
instance WithIndex.TraversableWithIndex (Linear.Vector.E Linear.Quaternion.Quaternion) Linear.Quaternion.Quaternion
instance Control.Lens.Indexed.FunctorWithIndex (Linear.Vector.E Linear.Quaternion.Quaternion) Linear.Quaternion.Quaternion
instance Control.Lens.Indexed.FoldableWithIndex (Linear.Vector.E Linear.Quaternion.Quaternion) Linear.Quaternion.Quaternion
instance Control.Lens.Indexed.TraversableWithIndex (Linear.Vector.E Linear.Quaternion.Quaternion) Linear.Quaternion.Quaternion
instance Control.Lens.At.Ixed (Linear.Quaternion.Quaternion a)
instance Control.Lens.Each.Each (Linear.Quaternion.Quaternion a) (Linear.Quaternion.Quaternion b) a b
instance Data.Foldable.Foldable Linear.Quaternion.Quaternion
instance Data.Traversable.Traversable Linear.Quaternion.Quaternion
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Linear.Quaternion.Quaternion a)
instance GHC.Float.RealFloat a => GHC.Num.Num (Linear.Quaternion.Quaternion a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Linear.Quaternion.Quaternion a)
instance Data.Hashable.Class.Hashable1 Linear.Quaternion.Quaternion
instance GHC.Float.RealFloat a => GHC.Real.Fractional (Linear.Quaternion.Quaternion a)
instance Linear.Metric.Metric Linear.Quaternion.Quaternion
instance Data.Distributive.Distributive Linear.Quaternion.Quaternion
instance (Linear.Conjugate.Conjugate a, GHC.Float.RealFloat a) => Linear.Conjugate.Conjugate (Linear.Quaternion.Quaternion a)
instance GHC.Float.RealFloat a => GHC.Float.Floating (Linear.Quaternion.Quaternion a)
instance (GHC.Float.RealFloat a, Linear.Epsilon.Epsilon a) => Linear.Epsilon.Epsilon (Linear.Quaternion.Quaternion a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Linear.Quaternion.Quaternion a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Linear.Quaternion.Quaternion a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Linear.Quaternion.Quaternion a)
instance Control.Monad.Zip.MonadZip Linear.Quaternion.Quaternion
instance Control.Monad.Fix.MonadFix Linear.Quaternion.Quaternion
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Linear.Quaternion.Quaternion a)
instance Data.Bytes.Serial.Serial1 Linear.Quaternion.Quaternion
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Linear.Quaternion.Quaternion a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Linear.Quaternion.Quaternion a)
instance Data.Serialize.Serialize a => Data.Serialize.Serialize (Linear.Quaternion.Quaternion a)
instance Data.Functor.Classes.Eq1 Linear.Quaternion.Quaternion
instance Data.Functor.Classes.Ord1 Linear.Quaternion.Quaternion
instance Data.Functor.Classes.Show1 Linear.Quaternion.Quaternion
instance Data.Functor.Classes.Read1 Linear.Quaternion.Quaternion
instance Control.Lens.Tuple.Field1 (Linear.Quaternion.Quaternion a) (Linear.Quaternion.Quaternion a) a a
instance Control.Lens.Tuple.Field2 (Linear.Quaternion.Quaternion a) (Linear.Quaternion.Quaternion a) a a
instance Control.Lens.Tuple.Field3 (Linear.Quaternion.Quaternion a) (Linear.Quaternion.Quaternion a) a a
instance Control.Lens.Tuple.Field4 (Linear.Quaternion.Quaternion a) (Linear.Quaternion.Quaternion a) a a
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Linear.Quaternion.Quaternion a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Linear.Quaternion.Quaternion a)
instance Linear.V1.R1 Linear.Quaternion.Quaternion
instance Linear.V2.R2 Linear.Quaternion.Quaternion
instance Linear.V3.R3 Linear.Quaternion.Quaternion
instance Linear.V4.R4 Linear.Quaternion.Quaternion


-- | Plücker coordinates for lines in 3d homogeneous space.
module Linear.Plucker

-- | Plücker coordinates for lines in a 3-dimensional space.
data Plucker a
Plucker :: !a -> !a -> !a -> !a -> !a -> !a -> Plucker a

-- | Valid Plücker coordinates <tt>p</tt> will have <tt><a>squaredError</a>
--   p <a>==</a> 0</tt>
--   
--   That said, floating point makes a mockery of this claim, so you may
--   want to use <a>nearZero</a>.
squaredError :: Num a => Plucker a -> a

-- | Checks if the line is near-isotropic (isotropic vectors in this
--   quadratic space represent lines in real 3d space).
isotropic :: Epsilon a => Plucker a -> Bool

-- | This isn't th actual metric because this bilinear form gives rise to
--   an isotropic quadratic space
(><) :: Num a => Plucker a -> Plucker a -> a
infixl 5 ><

-- | Given a pair of points represented by homogeneous coordinates generate
--   Plücker coordinates for the line through them, directed from the
--   second towards the first.
plucker :: Num a => V4 a -> V4 a -> Plucker a

-- | Given a pair of 3D points, generate Plücker coordinates for the line
--   through them, directed from the second towards the first.
plucker3D :: Num a => V3 a -> V3 a -> Plucker a

-- | Checks if two lines are parallel.
parallel :: Epsilon a => Plucker a -> Plucker a -> Bool

-- | Checks if two lines intersect (or nearly intersect).
intersects :: (Epsilon a, Ord a) => Plucker a -> Plucker a -> Bool

-- | Describe how two lines pass each other.
data LinePass

-- | The lines are coplanar (parallel or intersecting).
Coplanar :: LinePass

-- | The lines pass each other clockwise (right-handed screw)
Clockwise :: LinePass

-- | The lines pass each other counterclockwise (left-handed screw).
Counterclockwise :: LinePass

-- | Check how two lines pass each other. <tt>passes l1 l2</tt> describes
--   <tt>l2</tt> when looking down <tt>l1</tt>.
passes :: (Epsilon a, Ord a) => Plucker a -> Plucker a -> LinePass

-- | The minimum squared distance of a line from the origin.
quadranceToOrigin :: Fractional a => Plucker a -> a

-- | The point where a line is closest to the origin.
closestToOrigin :: Fractional a => Plucker a -> V3 a

-- | Not all 6-dimensional points correspond to a line in 3D. This
--   predicate tests that a Plücker coordinate lies on the Grassmann
--   manifold, and does indeed represent a 3D line.
isLine :: Epsilon a => Plucker a -> Bool

-- | Checks if two lines coincide in space. In other words, undirected
--   equality.
coincides :: (Epsilon a, Fractional a) => Plucker a -> Plucker a -> Bool

-- | Checks if two lines coincide in space, and have the same orientation.
coincides' :: (Epsilon a, Fractional a, Ord a) => Plucker a -> Plucker a -> Bool

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p01 :: Lens' (Plucker a) a

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p02 :: Lens' (Plucker a) a

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p03 :: Lens' (Plucker a) a

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p10 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p12 :: Lens' (Plucker a) a

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p13 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p20 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p21 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p23 :: Lens' (Plucker a) a

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p30 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)

-- | These elements form a basis for the Plücker space, or the Grassmanian
--   manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p01</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p02</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p03</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p23</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p31</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p12</a> :: <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p31 :: Lens' (Plucker a) a

-- | These elements form an alternate basis for the Plücker space, or the
--   Grassmanian manifold <tt>Gr(2,V4)</tt>.
--   
--   <pre>
--   <a>p10</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p20</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p30</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p32</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p13</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   <a>p21</a> :: <a>Num</a> a =&gt; <a>Lens'</a> (<a>Plucker</a> a) a
--   </pre>
p32 :: (Functor f, Num a) => (a -> f a) -> Plucker a -> f (Plucker a)
e01 :: E Plucker
e02 :: E Plucker
e03 :: E Plucker
e12 :: E Plucker
e31 :: E Plucker
e23 :: E Plucker
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Linear.Plucker.Plucker a)
instance GHC.Generics.Generic1 Linear.Plucker.Plucker
instance GHC.Generics.Generic (Linear.Plucker.Plucker a)
instance GHC.Read.Read a => GHC.Read.Read (Linear.Plucker.Plucker a)
instance GHC.Show.Show a => GHC.Show.Show (Linear.Plucker.Plucker a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Linear.Plucker.Plucker a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Linear.Plucker.Plucker a)
instance GHC.Generics.Generic Linear.Plucker.LinePass
instance GHC.Show.Show Linear.Plucker.LinePass
instance GHC.Classes.Eq Linear.Plucker.LinePass
instance Linear.V.Finite Linear.Plucker.Plucker
instance System.Random.Random a => System.Random.Random (Linear.Plucker.Plucker a)
instance GHC.Base.Functor Linear.Plucker.Plucker
instance Data.Functor.Bind.Class.Apply Linear.Plucker.Plucker
instance GHC.Base.Applicative Linear.Plucker.Plucker
instance Linear.Vector.Additive Linear.Plucker.Plucker
instance Data.Functor.Bind.Class.Bind Linear.Plucker.Plucker
instance GHC.Base.Monad Linear.Plucker.Plucker
instance Data.Distributive.Distributive Linear.Plucker.Plucker
instance Data.Functor.Rep.Representable Linear.Plucker.Plucker
instance Data.Foldable.Foldable Linear.Plucker.Plucker
instance Data.Traversable.Traversable Linear.Plucker.Plucker
instance Data.Semigroup.Foldable.Class.Foldable1 Linear.Plucker.Plucker
instance Data.Semigroup.Traversable.Class.Traversable1 Linear.Plucker.Plucker
instance GHC.Ix.Ix a => GHC.Ix.Ix (Linear.Plucker.Plucker a)
instance GHC.Num.Num a => GHC.Num.Num (Linear.Plucker.Plucker a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Linear.Plucker.Plucker a)
instance GHC.Float.Floating a => GHC.Float.Floating (Linear.Plucker.Plucker a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Linear.Plucker.Plucker a)
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Linear.Plucker.Plucker a)
instance Linear.Metric.Metric Linear.Plucker.Plucker
instance Linear.Epsilon.Epsilon a => Linear.Epsilon.Epsilon (Linear.Plucker.Plucker a)
instance WithIndex.FunctorWithIndex (Linear.Vector.E Linear.Plucker.Plucker) Linear.Plucker.Plucker
instance WithIndex.FoldableWithIndex (Linear.Vector.E Linear.Plucker.Plucker) Linear.Plucker.Plucker
instance WithIndex.TraversableWithIndex (Linear.Vector.E Linear.Plucker.Plucker) Linear.Plucker.Plucker
instance Control.Lens.Indexed.FunctorWithIndex (Linear.Vector.E Linear.Plucker.Plucker) Linear.Plucker.Plucker
instance Control.Lens.Indexed.FoldableWithIndex (Linear.Vector.E Linear.Plucker.Plucker) Linear.Plucker.Plucker
instance Control.Lens.Indexed.TraversableWithIndex (Linear.Vector.E Linear.Plucker.Plucker) Linear.Plucker.Plucker
instance Control.Lens.At.Ixed (Linear.Plucker.Plucker a)
instance Control.Lens.Each.Each (Linear.Plucker.Plucker a) (Linear.Plucker.Plucker b) a b
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Unboxed.Base.Unbox (Linear.Plucker.Plucker a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Linear.Plucker.Plucker a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Linear.Plucker.Plucker a)
instance Control.Monad.Zip.MonadZip Linear.Plucker.Plucker
instance Control.Monad.Fix.MonadFix Linear.Plucker.Plucker
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Linear.Plucker.Plucker a)
instance Data.Bytes.Serial.Serial1 Linear.Plucker.Plucker
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Linear.Plucker.Plucker a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Linear.Plucker.Plucker a)
instance Data.Serialize.Serialize a => Data.Serialize.Serialize (Linear.Plucker.Plucker a)
instance Data.Functor.Classes.Eq1 Linear.Plucker.Plucker
instance Data.Functor.Classes.Ord1 Linear.Plucker.Plucker
instance Data.Functor.Classes.Read1 Linear.Plucker.Plucker
instance Data.Functor.Classes.Show1 Linear.Plucker.Plucker
instance Control.Lens.Tuple.Field1 (Linear.Plucker.Plucker a) (Linear.Plucker.Plucker a) a a
instance Control.Lens.Tuple.Field2 (Linear.Plucker.Plucker a) (Linear.Plucker.Plucker a) a a
instance Control.Lens.Tuple.Field3 (Linear.Plucker.Plucker a) (Linear.Plucker.Plucker a) a a
instance Control.Lens.Tuple.Field4 (Linear.Plucker.Plucker a) (Linear.Plucker.Plucker a) a a
instance Control.Lens.Tuple.Field5 (Linear.Plucker.Plucker a) (Linear.Plucker.Plucker a) a a
instance Control.Lens.Tuple.Field6 (Linear.Plucker.Plucker a) (Linear.Plucker.Plucker a) a a
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Linear.Plucker.Plucker a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Linear.Plucker.Plucker a)


-- | Simple matrix operation for low-dimensional primitives.
module Linear.Trace
class Functor m => Trace m

-- | Compute the trace of a matrix
--   
--   <pre>
--   &gt;&gt;&gt; trace (V2 (V2 a b) (V2 c d))
--   a + d
--   </pre>
trace :: (Trace m, Num a) => m (m a) -> a

-- | Compute the trace of a matrix
--   
--   <pre>
--   &gt;&gt;&gt; trace (V2 (V2 a b) (V2 c d))
--   a + d
--   </pre>
trace :: (Trace m, Foldable m, Num a) => m (m a) -> a

-- | Compute the diagonal of a matrix
--   
--   <pre>
--   &gt;&gt;&gt; diagonal (V2 (V2 a b) (V2 c d))
--   V2 a d
--   </pre>
diagonal :: Trace m => m (m a) -> m a

-- | Compute the diagonal of a matrix
--   
--   <pre>
--   &gt;&gt;&gt; diagonal (V2 (V2 a b) (V2 c d))
--   V2 a d
--   </pre>
diagonal :: (Trace m, Monad m) => m (m a) -> m a

-- | Compute the <a>Frobenius norm</a> of a matrix.
frobenius :: (Num a, Foldable f, Additive f, Additive g, Distributive g, Trace g) => f (g a) -> a
instance Linear.Trace.Trace Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord k => Linear.Trace.Trace (Data.Map.Internal.Map k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Linear.Trace.Trace (Data.HashMap.Internal.HashMap k)
instance forall k (n :: k). Linear.V.Dim n => Linear.Trace.Trace (Linear.V.V n)
instance Linear.Trace.Trace Linear.V0.V0
instance Linear.Trace.Trace Linear.V1.V1
instance Linear.Trace.Trace Linear.V2.V2
instance Linear.Trace.Trace Linear.V3.V3
instance Linear.Trace.Trace Linear.V4.V4
instance Linear.Trace.Trace Linear.Plucker.Plucker
instance Linear.Trace.Trace Linear.Quaternion.Quaternion
instance Linear.Trace.Trace Data.Complex.Complex
instance (Linear.Trace.Trace f, Linear.Trace.Trace g) => Linear.Trace.Trace (Data.Functor.Product.Product f g)
instance (Data.Distributive.Distributive g, Linear.Trace.Trace g, Linear.Trace.Trace f) => Linear.Trace.Trace (Data.Functor.Compose.Compose g f)


-- | Utility for working with Plücker coordinates for lines in 3d
--   homogeneous space.
module Linear.Plucker.Coincides

-- | When lines are represented as Plücker coordinates, we have the ability
--   to check for both directed and undirected equality. Undirected
--   equality between <a>Line</a>s (or a <a>Line</a> and a <a>Ray</a>)
--   checks that the two lines coincide in 3D space. Directed equality,
--   between two <a>Ray</a>s, checks that two lines coincide in 3D, and
--   have the same direction. To accomodate these two notions of equality,
--   we use an <a>Eq</a> instance on the <a>Coincides</a> data type.
--   
--   For example, to check the <i>directed</i> equality between two lines,
--   <tt>p1</tt> and <tt>p2</tt>, we write, <tt>Ray p1 == Ray p2</tt>.
data Coincides a
[Line] :: (Epsilon a, Fractional a) => Plucker a -> Coincides a
[Ray] :: (Epsilon a, Fractional a, Ord a) => Plucker a -> Coincides a
instance GHC.Classes.Eq (Linear.Plucker.Coincides.Coincides a)


-- | Simple matrix operation for low-dimensional primitives.
module Linear.Matrix

-- | Matrix product. This can compute any combination of sparse and dense
--   multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !*! V3 (V2 1 2) (V2 3 4) (V2 4 5)
--   V2 (V2 19 25) (V2 43 58)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 (IntMap.fromList [(1,2)]) (IntMap.fromList [(2,3)]) !*! IntMap.fromList [(1,V3 0 0 1), (2, V3 0 0 5)]
--   V2 (V3 0 0 2) (V3 0 0 15)
--   </pre>
(!*!) :: (Functor m, Foldable t, Additive t, Additive n, Num a) => m (t a) -> t (n a) -> m (n a)
infixl 7 !*!

-- | Entry-wise matrix addition.
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !+! V2 (V3 7 8 9) (V3 1 2 3)
--   V2 (V3 8 10 12) (V3 5 7 9)
--   </pre>
(!+!) :: (Additive m, Additive n, Num a) => m (n a) -> m (n a) -> m (n a)
infixl 6 !+!

-- | Entry-wise matrix subtraction.
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !-! V2 (V3 7 8 9) (V3 1 2 3)
--   V2 (V3 (-6) (-6) (-6)) (V3 3 3 3)
--   </pre>
(!-!) :: (Additive m, Additive n, Num a) => m (n a) -> m (n a) -> m (n a)
infixl 6 !-!

-- | Matrix * column vector
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) !* V3 7 8 9
--   V2 50 122
--   </pre>
(!*) :: (Functor m, Foldable r, Additive r, Num a) => m (r a) -> r a -> m a
infixl 7 !*

-- | Row vector * matrix
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 *! V2 (V3 3 4 5) (V3 6 7 8)
--   V3 15 18 21
--   </pre>
(*!) :: (Num a, Foldable t, Additive f, Additive t) => t a -> t (f a) -> f a
infixl 7 *!

-- | Matrix-scalar product
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V2 1 2) (V2 3 4) !!* 5
--   V2 (V2 5 10) (V2 15 20)
--   </pre>
(!!*) :: (Functor m, Functor r, Num a) => m (r a) -> a -> m (r a)
infixl 7 !!*

-- | Scalar-matrix product
--   
--   <pre>
--   &gt;&gt;&gt; 5 *!! V2 (V2 1 2) (V2 3 4)
--   V2 (V2 5 10) (V2 15 20)
--   </pre>
(*!!) :: (Functor m, Functor r, Num a) => a -> m (r a) -> m (r a)
infixl 7 *!!

-- | Matrix-scalar division
(!!/) :: (Functor m, Functor r, Fractional a) => m (r a) -> a -> m (r a)
infixl 7 !!/

-- | This is a generalization of <a>inside</a> to work over any
--   corepresentable <a>Functor</a>.
--   
--   <pre>
--   <a>column</a> :: <a>Representable</a> f =&gt; <a>Lens</a> s t a b -&gt; <a>Lens</a> (f s) (f t) (f a) (f b)
--   </pre>
--   
--   In practice it is used to access a column of a matrix.
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) ^._x
--   V3 1 2 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 (V3 1 2 3) (V3 4 5 6) ^.column _x
--   V2 1 4
--   </pre>
column :: Representable f => LensLike (Context a b) s t a b -> Lens (f s) (f t) (f a) (f b)

-- | Hermitian conjugate or conjugate transpose
--   
--   <pre>
--   &gt;&gt;&gt; adjoint (V2 (V2 (1 :+ 2) (3 :+ 4)) (V2 (5 :+ 6) (7 :+ 8)))
--   V2 (V2 (1.0 :+ (-2.0)) (5.0 :+ (-6.0))) (V2 (3.0 :+ (-4.0)) (7.0 :+ (-8.0)))
--   </pre>
adjoint :: (Functor m, Distributive n, Conjugate a) => m (n a) -> n (m a)

-- | A 2x2 matrix with row-major representation
type M22 a = V2 (V2 a)

-- | A 2x3 matrix with row-major representation
type M23 a = V2 (V3 a)

-- | A 2x4 matrix with row-major representation
type M24 a = V2 (V4 a)

-- | A 3x2 matrix with row-major representation
type M32 a = V3 (V2 a)

-- | A 3x3 matrix with row-major representation
type M33 a = V3 (V3 a)

-- | A 3x4 matrix with row-major representation
type M34 a = V3 (V4 a)

-- | A 4x2 matrix with row-major representation
type M42 a = V4 (V2 a)

-- | A 4x3 matrix with row-major representation
type M43 a = V4 (V3 a)

-- | A 4x4 matrix with row-major representation
type M44 a = V4 (V4 a)

-- | Convert a 3x3 matrix to a 4x4 matrix extending it with 0's in the new
--   row and column.
m33_to_m44 :: Num a => M33 a -> M44 a

-- | Convert from a 4x3 matrix to a 4x4 matrix, extending it with the <tt>[
--   0 0 0 1 ]</tt> column vector
m43_to_m44 :: Num a => M43 a -> M44 a

-- | 2x2 matrix determinant.
--   
--   <pre>
--   &gt;&gt;&gt; det22 (V2 (V2 a b) (V2 c d))
--   a * d - b * c
--   </pre>
det22 :: Num a => M22 a -> a

-- | 3x3 matrix determinant.
--   
--   <pre>
--   &gt;&gt;&gt; det33 (V3 (V3 a b c) (V3 d e f) (V3 g h i))
--   a * (e * i - f * h) - d * (b * i - c * h) + g * (b * f - c * e)
--   </pre>
det33 :: Num a => M33 a -> a

-- | 4x4 matrix determinant.
det44 :: Num a => M44 a -> a

-- | 2x2 matrix inverse.
--   
--   <pre>
--   &gt;&gt;&gt; inv22 $ V2 (V2 1 2) (V2 3 4)
--   V2 (V2 (-2.0) 1.0) (V2 1.5 (-0.5))
--   </pre>
inv22 :: Fractional a => M22 a -> M22 a

-- | 3x3 matrix inverse.
--   
--   <pre>
--   &gt;&gt;&gt; inv33 $ V3 (V3 1 2 4) (V3 4 2 2) (V3 1 1 1)
--   V3 (V3 0.0 0.5 (-1.0)) (V3 (-0.5) (-0.75) 3.5) (V3 0.5 0.25 (-1.5))
--   </pre>
inv33 :: Fractional a => M33 a -> M33 a

-- | 4x4 matrix inverse.
inv44 :: Fractional a => M44 a -> M44 a

-- | The identity matrix for any dimension vector.
--   
--   <pre>
--   &gt;&gt;&gt; identity :: M44 Int
--   V4 (V4 1 0 0 0) (V4 0 1 0 0) (V4 0 0 1 0) (V4 0 0 0 1)
--   
--   &gt;&gt;&gt; identity :: V3 (V3 Int)
--   V3 (V3 1 0 0) (V3 0 1 0) (V3 0 0 1)
--   </pre>
identity :: (Num a, Traversable t, Applicative t) => t (t a)
class Functor m => Trace m

-- | Compute the trace of a matrix
--   
--   <pre>
--   &gt;&gt;&gt; trace (V2 (V2 a b) (V2 c d))
--   a + d
--   </pre>
trace :: (Trace m, Num a) => m (m a) -> a

-- | Compute the trace of a matrix
--   
--   <pre>
--   &gt;&gt;&gt; trace (V2 (V2 a b) (V2 c d))
--   a + d
--   </pre>
trace :: (Trace m, Foldable m, Num a) => m (m a) -> a

-- | Compute the diagonal of a matrix
--   
--   <pre>
--   &gt;&gt;&gt; diagonal (V2 (V2 a b) (V2 c d))
--   V2 a d
--   </pre>
diagonal :: Trace m => m (m a) -> m a

-- | Compute the diagonal of a matrix
--   
--   <pre>
--   &gt;&gt;&gt; diagonal (V2 (V2 a b) (V2 c d))
--   V2 a d
--   </pre>
diagonal :: (Trace m, Monad m) => m (m a) -> m a

-- | Extract the translation vector (first three entries of the last
--   column) from a 3x4 or 4x4 matrix.
translation :: (Representable t, R3 t, R4 v) => Lens' (t (v a)) (V3 a)

-- | <a>transpose</a> is just an alias for <a>distribute</a>
--   
--   <pre>
--   transpose (V3 (V2 1 2) (V2 3 4) (V2 5 6))
--   </pre>
--   
--   V2 (V3 1 3 5) (V3 2 4 6)
transpose :: (Distributive g, Functor f) => f (g a) -> g (f a)

-- | Build a rotation matrix from a unit <a>Quaternion</a>.
fromQuaternion :: Num a => Quaternion a -> M33 a

-- | Build a transformation matrix from a rotation expressed as a
--   <a>Quaternion</a> and a translation vector.
mkTransformation :: Num a => Quaternion a -> V3 a -> M44 a

-- | Build a transformation matrix from a rotation matrix and a translation
--   vector.
mkTransformationMat :: Num a => M33 a -> V3 a -> M44 a

-- | Extract a 2x2 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m22 :: (Representable t, R2 t, R2 v) => Lens' (t (v a)) (M22 a)

-- | Extract a 2x3 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m23 :: (Representable t, R2 t, R3 v) => Lens' (t (v a)) (M23 a)

-- | Extract a 2x4 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m24 :: (Representable t, R2 t, R4 v) => Lens' (t (v a)) (M24 a)

-- | Extract a 3x2 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m32 :: (Representable t, R3 t, R2 v) => Lens' (t (v a)) (M32 a)

-- | Extract a 3x3 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m33 :: (Representable t, R3 t, R3 v) => Lens' (t (v a)) (M33 a)

-- | Extract a 3x4 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m34 :: (Representable t, R3 t, R4 v) => Lens' (t (v a)) (M34 a)

-- | Extract a 4x2 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m42 :: (Representable t, R4 t, R2 v) => Lens' (t (v a)) (M42 a)

-- | Extract a 4x3 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m43 :: (Representable t, R4 t, R3 v) => Lens' (t (v a)) (M43 a)

-- | Extract a 4x4 matrix from a matrix of higher dimensions by dropping
--   excess rows and columns.
_m44 :: (Representable t, R4 t, R4 v) => Lens' (t (v a)) (M44 a)

-- | Compute the (L, U) decomposition of a square matrix using Crout's
--   algorithm. The <a>Index</a> of the vectors must be <a>Integral</a>.
lu :: (Num a, Fractional a, Foldable m, Traversable m, Applicative m, Additive m, Ixed (m a), Ixed (m (m a)), i ~ Index (m a), i ~ Index (m (m a)), Eq i, Integral i, a ~ IxValue (m a), m a ~ IxValue (m (m a)), Num (m a)) => m (m a) -> (m (m a), m (m a))

-- | Compute the (L, U) decomposition of a square matrix using Crout's
--   algorithm, using the vector's <a>Finite</a> instance to provide an
--   index.
luFinite :: (Num a, Fractional a, Functor m, Finite m, n ~ Size m, KnownNat n, Num (m a)) => m (m a) -> (m (m a), m (m a))

-- | Solve a linear system with a lower-triangular matrix of coefficients
--   with forwards substitution.
forwardSub :: (Num a, Fractional a, Foldable m, Additive m, Ixed (m a), Ixed (m (m a)), i ~ Index (m a), i ~ Index (m (m a)), Eq i, Ord i, Integral i, a ~ IxValue (m a), m a ~ IxValue (m (m a))) => m (m a) -> m a -> m a

-- | Solve a linear system with a lower-triangular matrix of coefficients
--   with forwards substitution, using the vector's <a>Finite</a> instance
--   to provide an index.
forwardSubFinite :: (Num a, Fractional a, Foldable m, n ~ Size m, KnownNat n, Additive m, Finite m) => m (m a) -> m a -> m a

-- | Solve a linear system with an upper-triangular matrix of coefficients
--   with backwards substitution.
backwardSub :: (Num a, Fractional a, Foldable m, Additive m, Ixed (m a), Ixed (m (m a)), i ~ Index (m a), i ~ Index (m (m a)), Eq i, Ord i, Integral i, a ~ IxValue (m a), m a ~ IxValue (m (m a))) => m (m a) -> m a -> m a

-- | Solve a linear system with an upper-triangular matrix of coefficients
--   with backwards substitution, using the vector's <a>Finite</a> instance
--   to provide an index.
backwardSubFinite :: (Num a, Fractional a, Foldable m, n ~ Size m, KnownNat n, Additive m, Finite m) => m (m a) -> m a -> m a

-- | Solve a linear system with LU decomposition.
luSolve :: (Num a, Fractional a, Foldable m, Traversable m, Applicative m, Additive m, Ixed (m a), Ixed (m (m a)), i ~ Index (m a), i ~ Index (m (m a)), Eq i, Integral i, a ~ IxValue (m a), m a ~ IxValue (m (m a)), Num (m a)) => m (m a) -> m a -> m a

-- | Solve a linear system with LU decomposition, using the vector's
--   <a>Finite</a> instance to provide an index.
luSolveFinite :: (Num a, Fractional a, Functor m, Finite m, n ~ Size m, KnownNat n, Num (m a)) => m (m a) -> m a -> m a

-- | Invert a matrix with LU decomposition.
luInv :: (Num a, Fractional a, Foldable m, Traversable m, Applicative m, Additive m, Distributive m, Ixed (m a), Ixed (m (m a)), i ~ Index (m a), i ~ Index (m (m a)), Eq i, Integral i, a ~ IxValue (m a), m a ~ IxValue (m (m a)), Num (m a)) => m (m a) -> m (m a)

-- | Invert a matrix with LU decomposition, using the vector's
--   <a>Finite</a> instance to provide an index.
luInvFinite :: (Num a, Fractional a, Functor m, Finite m, n ~ Size m, KnownNat n, Num (m a)) => m (m a) -> m (m a)

-- | Compute the determinant of a matrix using LU decomposition.
luDet :: (Num a, Fractional a, Foldable m, Traversable m, Applicative m, Additive m, Trace m, Ixed (m a), Ixed (m (m a)), i ~ Index (m a), i ~ Index (m (m a)), Eq i, Integral i, a ~ IxValue (m a), m a ~ IxValue (m (m a)), Num (m a)) => m (m a) -> a

-- | Compute the determinant of a matrix using LU decomposition, using the
--   vector's <a>Finite</a> instance to provide an index.
luDetFinite :: (Num a, Fractional a, Functor m, Finite m, n ~ Size m, KnownNat n, Num (m a)) => m (m a) -> a


-- | Common projection matrices: e.g. perspective/orthographic
--   transformation matrices.
--   
--   Analytically derived inverses are also supplied, because they can be
--   much more accurate in practice than computing them through general
--   purpose means
module Linear.Projection

-- | Build a look at view matrix
lookAt :: (Epsilon a, Floating a) => V3 a -> V3 a -> V3 a -> M44 a

-- | Build a matrix for a symmetric perspective-view frustum
perspective :: Floating a => a -> a -> a -> a -> M44 a

-- | Build an inverse perspective matrix
inversePerspective :: Floating a => a -> a -> a -> a -> M44 a

-- | Build a matrix for a symmetric perspective-view frustum with a far
--   plane at infinite
infinitePerspective :: Floating a => a -> a -> a -> M44 a
inverseInfinitePerspective :: Floating a => a -> a -> a -> M44 a

-- | Build a perspective matrix per the classic <tt>glFrustum</tt>
--   arguments.
frustum :: Floating a => a -> a -> a -> a -> a -> a -> M44 a
inverseFrustum :: Floating a => a -> a -> a -> a -> a -> a -> M44 a

-- | Build an orthographic perspective matrix from 6 clipping planes. This
--   matrix takes the region delimited by these planes and maps it to
--   normalized device coordinates between [-1,1]
--   
--   This call is designed to mimic the parameters to the OpenGL
--   <tt>glOrtho</tt> call, so it has a slightly strange convention:
--   Notably: the near and far planes are negated.
--   
--   Consequently:
--   
--   <pre>
--   <a>ortho</a> l r b t n f !* <a>V4</a> l b (-n) 1 = <a>V4</a> (-1) (-1) (-1) 1
--   <a>ortho</a> l r b t n f !* <a>V4</a> r t (-f) 1 = <a>V4</a> 1 1 1 1
--   </pre>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; ortho 1 2 3 4 5 6 !* V4 1 3 (-5) 1
--   V4 (-1.0) (-1.0) (-1.0) 1.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ortho 1 2 3 4 5 6 !* V4 2 4 (-6) 1
--   V4 1.0 1.0 1.0 1.0
--   </pre>
ortho :: Fractional a => a -> a -> a -> a -> a -> a -> M44 a

-- | Build an inverse orthographic perspective matrix from 6 clipping
--   planes
inverseOrtho :: Fractional a => a -> a -> a -> a -> a -> a -> M44 a


module Linear.Algebra

-- | An associative unital algebra over a ring
class Num r => Algebra r m
mult :: Algebra r m => (m -> m -> r) -> m -> r
unital :: Algebra r m => r -> m -> r

-- | A coassociative counital coalgebra over a ring
class Num r => Coalgebra r m
comult :: Coalgebra r m => (m -> r) -> m -> m -> r
counital :: Coalgebra r m => (m -> r) -> r
multRep :: (Representable f, Algebra r (Rep f)) => f (f r) -> f r
unitalRep :: (Representable f, Algebra r (Rep f)) => r -> f r
comultRep :: (Representable f, Coalgebra r (Rep f)) => f r -> f (f r)
counitalRep :: (Representable f, Coalgebra r (Rep f)) => f r -> r
instance GHC.Num.Num r => Linear.Algebra.Coalgebra r Data.Void.Void
instance GHC.Num.Num r => Linear.Algebra.Coalgebra r ()
instance GHC.Num.Num r => Linear.Algebra.Coalgebra r (Linear.Vector.E Linear.V0.V0)
instance GHC.Num.Num r => Linear.Algebra.Coalgebra r (Linear.Vector.E Linear.V1.V1)
instance GHC.Num.Num r => Linear.Algebra.Coalgebra r (Linear.Vector.E Linear.V2.V2)
instance GHC.Num.Num r => Linear.Algebra.Coalgebra r (Linear.Vector.E Linear.V3.V3)
instance GHC.Num.Num r => Linear.Algebra.Coalgebra r (Linear.Vector.E Linear.V4.V4)
instance GHC.Num.Num r => Linear.Algebra.Coalgebra r (Linear.Vector.E Data.Complex.Complex)
instance (GHC.Num.Num r, Linear.Conjugate.TrivialConjugate r) => Linear.Algebra.Coalgebra r (Linear.Vector.E Linear.Quaternion.Quaternion)
instance (Linear.Algebra.Coalgebra r m, Linear.Algebra.Coalgebra r n) => Linear.Algebra.Coalgebra r (m, n)
instance GHC.Num.Num r => Linear.Algebra.Algebra r Data.Void.Void
instance GHC.Num.Num r => Linear.Algebra.Algebra r (Linear.Vector.E Linear.V0.V0)
instance GHC.Num.Num r => Linear.Algebra.Algebra r (Linear.Vector.E Linear.V1.V1)
instance GHC.Num.Num r => Linear.Algebra.Algebra r ()
instance (Linear.Algebra.Algebra r a, Linear.Algebra.Algebra r b) => Linear.Algebra.Algebra r (a, b)
instance GHC.Num.Num r => Linear.Algebra.Algebra r (Linear.Vector.E Data.Complex.Complex)
instance (GHC.Num.Num r, Linear.Conjugate.TrivialConjugate r) => Linear.Algebra.Algebra r (Linear.Vector.E Linear.Quaternion.Quaternion)


-- | Operations on affine spaces.
module Linear.Covector

-- | Linear functionals from elements of an (infinite) free module to a
--   scalar
newtype Covector r a
Covector :: ((a -> r) -> r) -> Covector r a
[runCovector] :: Covector r a -> (a -> r) -> r
($*) :: Representable f => Covector r (Rep f) -> f r -> r
infixr 0 $*
instance GHC.Base.Functor (Linear.Covector.Covector r)
instance Data.Functor.Bind.Class.Apply (Linear.Covector.Covector r)
instance GHC.Base.Applicative (Linear.Covector.Covector r)
instance Data.Functor.Bind.Class.Bind (Linear.Covector.Covector r)
instance GHC.Base.Monad (Linear.Covector.Covector r)
instance GHC.Num.Num r => Data.Functor.Alt.Alt (Linear.Covector.Covector r)
instance GHC.Num.Num r => Data.Functor.Plus.Plus (Linear.Covector.Covector r)
instance GHC.Num.Num r => GHC.Base.Alternative (Linear.Covector.Covector r)
instance GHC.Num.Num r => GHC.Base.MonadPlus (Linear.Covector.Covector r)
instance Linear.Algebra.Coalgebra r m => GHC.Num.Num (Linear.Covector.Covector r m)


-- | Operations on affine spaces.
module Linear.Affine

-- | An affine space is roughly a vector space in which we have forgotten
--   or at least pretend to have forgotten the origin.
--   
--   <pre>
--   a .+^ (b .-. a)  =  b@
--   (a .+^ u) .+^ v  =  a .+^ (u ^+^ v)@
--   (a .-. b) ^+^ v  =  (a .+^ v) .-. q@
--   </pre>
class Additive (Diff p) => Affine p where {
    type family Diff p :: * -> *;
}

-- | Get the difference between two points as a vector offset.
(.-.) :: (Affine p, Num a) => p a -> p a -> Diff p a

-- | Add a vector offset to a point.
(.+^) :: (Affine p, Num a) => p a -> Diff p a -> p a

-- | Subtract a vector offset from a point.
(.-^) :: (Affine p, Num a) => p a -> Diff p a -> p a
infixl 6 .-^
infixl 6 .+^
infixl 6 .-.

-- | Compute the quadrance of the difference (the square of the distance)
qdA :: (Affine p, Foldable (Diff p), Num a) => p a -> p a -> a

-- | Distance between two points in an affine space
distanceA :: (Floating a, Foldable (Diff p), Affine p) => p a -> p a -> a

-- | A handy wrapper to help distinguish points from vectors at the type
--   level
newtype Point f a
P :: f a -> Point f a
lensP :: Lens' (Point g a) (g a)
_Point :: Iso' (Point f a) (f a)
(.#) :: Coercible b a => (b -> c) -> (a -> b) -> a -> c
(#.) :: Coercible c b => (b -> c) -> (a -> b) -> a -> c
unP :: Point f a -> f a

-- | Vector spaces have origins.
origin :: (Additive f, Num a) => Point f a

-- | An isomorphism between points and vectors, given a reference point.
relative :: (Additive f, Num a) => Point f a -> Iso' (Point f a) (f a)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable a, Data.Data.Data (f a)) => Data.Data.Data (Linear.Affine.Point f a)
instance GHC.Generics.Generic1 (Linear.Affine.Point f)
instance GHC.Generics.Generic (Linear.Affine.Point f a)
instance Data.Hashable.Class.Hashable (f a) => Data.Hashable.Class.Hashable (Linear.Affine.Point f a)
instance System.Random.Random (f a) => System.Random.Random (Linear.Affine.Point f a)
instance GHC.Base.Monoid (f a) => GHC.Base.Monoid (Linear.Affine.Point f a)
instance GHC.Base.Semigroup (f a) => GHC.Base.Semigroup (Linear.Affine.Point f a)
instance Linear.Epsilon.Epsilon (f a) => Linear.Epsilon.Epsilon (Linear.Affine.Point f a)
instance Foreign.Storable.Storable (f a) => Foreign.Storable.Storable (Linear.Affine.Point f a)
instance GHC.Ix.Ix (f a) => GHC.Ix.Ix (Linear.Affine.Point f a)
instance GHC.Num.Num (f a) => GHC.Num.Num (Linear.Affine.Point f a)
instance GHC.Real.Fractional (f a) => GHC.Real.Fractional (Linear.Affine.Point f a)
instance Linear.Metric.Metric f => Linear.Metric.Metric (Linear.Affine.Point f)
instance Linear.Vector.Additive f => Linear.Vector.Additive (Linear.Affine.Point f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Linear.Affine.Point f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Linear.Affine.Point f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Linear.Affine.Point f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Linear.Affine.Point f)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Linear.Affine.Point f)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Linear.Affine.Point f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Linear.Affine.Point f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Linear.Affine.Point f)
instance GHC.Base.Functor f => GHC.Base.Functor (Linear.Affine.Point f)
instance GHC.Base.Monad f => GHC.Base.Monad (Linear.Affine.Point f)
instance GHC.Read.Read (f a) => GHC.Read.Read (Linear.Affine.Point f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Linear.Affine.Point f a)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Linear.Affine.Point f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Linear.Affine.Point f a)
instance Linear.V.Finite f => Linear.V.Finite (Linear.Affine.Point f)
instance Control.DeepSeq.NFData (f a) => Control.DeepSeq.NFData (Linear.Affine.Point f a)
instance Data.Bytes.Serial.Serial1 f => Data.Bytes.Serial.Serial1 (Linear.Affine.Point f)
instance Data.Bytes.Serial.Serial (f a) => Data.Bytes.Serial.Serial (Linear.Affine.Point f a)
instance Data.Binary.Class.Binary (f a) => Data.Binary.Class.Binary (Linear.Affine.Point f a)
instance Data.Serialize.Serialize (f a) => Data.Serialize.Serialize (Linear.Affine.Point f a)
instance Data.Hashable.Class.Hashable1 f => Data.Hashable.Class.Hashable1 (Linear.Affine.Point f)
instance (t GHC.Types.~ Linear.Affine.Point g b) => Control.Lens.Wrapped.Rewrapped (Linear.Affine.Point f a) t
instance Control.Lens.Wrapped.Wrapped (Linear.Affine.Point f a)
instance Data.Functor.Bind.Class.Bind f => Data.Functor.Bind.Class.Bind (Linear.Affine.Point f)
instance Data.Distributive.Distributive f => Data.Distributive.Distributive (Linear.Affine.Point f)
instance Data.Functor.Rep.Representable f => Data.Functor.Rep.Representable (Linear.Affine.Point f)
instance Control.Lens.At.Ixed (f a) => Control.Lens.At.Ixed (Linear.Affine.Point f a)
instance Data.Traversable.Traversable f => Control.Lens.Each.Each (Linear.Affine.Point f a) (Linear.Affine.Point f b) a b
instance Linear.V1.R1 f => Linear.V1.R1 (Linear.Affine.Point f)
instance Linear.V2.R2 f => Linear.V2.R2 (Linear.Affine.Point f)
instance Linear.V3.R3 f => Linear.V3.R3 (Linear.Affine.Point f)
instance Linear.V4.R4 f => Linear.V4.R4 (Linear.Affine.Point f)
instance Linear.Vector.Additive f => Linear.Affine.Affine (Linear.Affine.Point f)
instance Data.Vector.Unboxed.Base.Unbox (f a) => Data.Vector.Unboxed.Base.Unbox (Linear.Affine.Point f a)
instance Data.Vector.Unboxed.Base.Unbox (f a) => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Linear.Affine.Point f a)
instance Data.Vector.Unboxed.Base.Unbox (f a) => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Linear.Affine.Point f a)
instance (Linear.Affine.Affine f, Linear.Affine.Affine g) => Linear.Affine.Affine (Data.Functor.Product.Product f g)
instance Linear.Affine.Affine []
instance Linear.Affine.Affine Data.Complex.Complex
instance Linear.Affine.Affine Control.Applicative.ZipList
instance Linear.Affine.Affine GHC.Maybe.Maybe
instance Linear.Affine.Affine Data.IntMap.Internal.IntMap
instance Linear.Affine.Affine Data.Functor.Identity.Identity
instance Linear.Affine.Affine Data.Vector.Vector
instance Linear.Affine.Affine Linear.V0.V0
instance Linear.Affine.Affine Linear.V1.V1
instance Linear.Affine.Affine Linear.V2.V2
instance Linear.Affine.Affine Linear.V3.V3
instance Linear.Affine.Affine Linear.V4.V4
instance Linear.Affine.Affine Linear.Plucker.Plucker
instance Linear.Affine.Affine Linear.Quaternion.Quaternion
instance Linear.Affine.Affine ((->) b)
instance GHC.Classes.Ord k => Linear.Affine.Affine (Data.Map.Internal.Map k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Linear.Affine.Affine (Data.HashMap.Internal.HashMap k)
instance Linear.V.Dim n => Linear.Affine.Affine (Linear.V.V n)


-- | This module simply re-exports everything from the various modules that
--   make up the linear package.
module Linear
