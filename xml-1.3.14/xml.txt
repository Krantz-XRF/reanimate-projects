-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple XML library.
--   
--   A simple XML library.
@package xml
@version 1.3.14


-- | Basic XML types.
module Text.XML.Light.Types

-- | A line is an Integer
type Line = Integer

-- | XML content
data Content
Elem :: Element -> Content
Text :: CData -> Content
CRef :: String -> Content

-- | XML elements
data Element
Element :: QName -> [Attr] -> [Content] -> Maybe Line -> Element
[elName] :: Element -> QName
[elAttribs] :: Element -> [Attr]
[elContent] :: Element -> [Content]
[elLine] :: Element -> Maybe Line

-- | XML attributes
data Attr
Attr :: QName -> String -> Attr
[attrKey] :: Attr -> QName
[attrVal] :: Attr -> String

-- | XML CData
data CData
CData :: CDataKind -> String -> Maybe Line -> CData
[cdVerbatim] :: CData -> CDataKind
[cdData] :: CData -> String
[cdLine] :: CData -> Maybe Line
data CDataKind

-- | Ordinary character data; pretty printer escapes &amp;, &lt; etc.
CDataText :: CDataKind

-- | Unescaped character data; pretty printer embeds it in &lt;![CDATA[..
CDataVerbatim :: CDataKind

-- | As-is character data; pretty printer passes it along without any
--   escaping or CDATA wrap-up.
CDataRaw :: CDataKind

-- | XML qualified names
data QName
QName :: String -> Maybe String -> Maybe String -> QName
[qName] :: QName -> String
[qURI] :: QName -> Maybe String
[qPrefix] :: QName -> Maybe String

-- | Blank names
blank_name :: QName

-- | Blank cdata
blank_cdata :: CData

-- | Blank elements
blank_element :: Element
instance Data.Data.Data Text.XML.Light.Types.CDataKind
instance GHC.Show.Show Text.XML.Light.Types.CDataKind
instance GHC.Classes.Eq Text.XML.Light.Types.CDataKind
instance Data.Data.Data Text.XML.Light.Types.CData
instance GHC.Show.Show Text.XML.Light.Types.CData
instance Data.Data.Data Text.XML.Light.Types.QName
instance GHC.Show.Show Text.XML.Light.Types.QName
instance Data.Data.Data Text.XML.Light.Types.Attr
instance GHC.Show.Show Text.XML.Light.Types.Attr
instance GHC.Classes.Ord Text.XML.Light.Types.Attr
instance GHC.Classes.Eq Text.XML.Light.Types.Attr
instance Data.Data.Data Text.XML.Light.Types.Content
instance GHC.Show.Show Text.XML.Light.Types.Content
instance Data.Data.Data Text.XML.Light.Types.Element
instance GHC.Show.Show Text.XML.Light.Types.Element
instance GHC.Classes.Eq Text.XML.Light.Types.QName
instance GHC.Classes.Ord Text.XML.Light.Types.QName


module Text.XML.Light.Proc

-- | Get the text value of an XML element. This function ignores non-text
--   elements, and concatenates all text elements.
strContent :: Element -> String

-- | Select only the elements from a list of XML content.
onlyElems :: [Content] -> [Element]

-- | Select only the elements from a parent.
elChildren :: Element -> [Element]

-- | Select only the text from a list of XML content.
onlyText :: [Content] -> [CData]

-- | Find all immediate children with the given name.
findChildren :: QName -> Element -> [Element]

-- | Filter all immediate children wrt a given predicate.
filterChildren :: (Element -> Bool) -> Element -> [Element]

-- | Filter all immediate children wrt a given predicate over their names.
filterChildrenName :: (QName -> Bool) -> Element -> [Element]

-- | Find an immediate child with the given name.
findChild :: QName -> Element -> Maybe Element

-- | Find an immediate child with the given name.
filterChild :: (Element -> Bool) -> Element -> Maybe Element

-- | Find an immediate child with name matching a predicate.
filterChildName :: (QName -> Bool) -> Element -> Maybe Element

-- | Find the left-most occurrence of an element matching given name.
findElement :: QName -> Element -> Maybe Element

-- | Filter the left-most occurrence of an element wrt. given predicate.
filterElement :: (Element -> Bool) -> Element -> Maybe Element

-- | Filter the left-most occurrence of an element wrt. given predicate.
filterElementName :: (QName -> Bool) -> Element -> Maybe Element

-- | Find all non-nested occurances of an element. (i.e., once we have
--   found an element, we do not search for more occurances among the
--   element's children).
findElements :: QName -> Element -> [Element]

-- | Find all non-nested occurrences of an element wrt. given predicate.
--   (i.e., once we have found an element, we do not search for more
--   occurances among the element's children).
filterElements :: (Element -> Bool) -> Element -> [Element]

-- | Find all non-nested occurences of an element wrt a predicate over
--   element names. (i.e., once we have found an element, we do not search
--   for more occurances among the element's children).
filterElementsName :: (QName -> Bool) -> Element -> [Element]

-- | Lookup the value of an attribute.
findAttr :: QName -> Element -> Maybe String

-- | Lookup attribute name from list.
lookupAttr :: QName -> [Attr] -> Maybe String

-- | Lookup the first attribute whose name satisfies the given predicate.
lookupAttrBy :: (QName -> Bool) -> [Attr] -> Maybe String

-- | Lookup the value of the first attribute whose name satisfies the given
--   predicate.
findAttrBy :: (QName -> Bool) -> Element -> Maybe String


-- | Output handling for the lightweight XML lib.
module Text.XML.Light.Output

-- | Adds the <a>?xml?</a> header.
showTopElement :: Element -> String
showContent :: Content -> String
showElement :: Element -> String
showCData :: CData -> String
showQName :: QName -> String
showAttr :: Attr -> String

-- | Pretty printing renders XML documents faithfully, with the exception
--   that whitespace may be added/removed in non-verbatim character data.
ppTopElement :: Element -> String

-- | Pretty printing content
ppContent :: Content -> String

-- | Pretty printing elements
ppElement :: Element -> String

-- | Pretty printing renders XML documents faithfully, with the exception
--   that whitespace may be added/removed in non-verbatim character data.
ppcTopElement :: ConfigPP -> Element -> String

-- | Pretty printing content
ppcContent :: ConfigPP -> Content -> String

-- | Pretty printing elements
ppcElement :: ConfigPP -> Element -> String
data ConfigPP

-- | Default pretty orinting configuration. * Always use abbreviate empty
--   tags.
defaultConfigPP :: ConfigPP

-- | A configuration that tries to make things pretty (possibly at the cost
--   of changing the semantics a bit through adding white space.)
prettyConfigPP :: ConfigPP

-- | The predicate specifies for which empty tags we should use XML's
--   abbreviated notation <a>/</a>. This is useful if we are working with
--   some XML-ish standards (such as certain versions of HTML) where some
--   empty tags should always be displayed in the <a>TAG</a><a>/TAG</a>
--   form.
useShortEmptyTags :: (QName -> Bool) -> ConfigPP -> ConfigPP

-- | Specify if we should use extra white-space to make document more
--   readable. WARNING: This adds additional white-space to text elements,
--   and so it may change the meaning of the document.
useExtraWhiteSpace :: Bool -> ConfigPP -> ConfigPP
tagEnd :: QName -> ShowS

-- | The XML 1.0 header
xml_header :: String

module Text.XML.Light.Lexer
class XmlSource s
uncons :: XmlSource s => s -> Maybe (Char, s)
linenumber :: XmlSource s => Integer -> s -> LString

-- | This type may be used to provide a custom scanning function for
--   extracting characters.
data Scanner s
Scanner :: Maybe (Char, s) -> (s -> Maybe (Char, s)) -> Scanner s

-- | This type may be used to provide a custom scanning function for
--   extracting characters.
customScanner :: (s -> Maybe (Char, s)) -> s -> Scanner s
type LChar = (Line, Char)
type LString = [LChar]
data Token
TokStart :: Line -> QName -> [Attr] -> Bool -> Token
TokEnd :: Line -> QName -> Token
TokCRef :: String -> Token
TokText :: CData -> Token
tokens :: XmlSource source => source -> [Token]
tokens' :: LString -> [Token]
special :: LChar -> LString -> [Token]
qualName :: LString -> (QName, LString)
tag :: LString -> [Token]
attribs :: LString -> ([Attr], Bool, [Token])
attrib :: LString -> (Attr, LString)
attr_val :: LString -> (String, LString)
dropSpace :: LString -> LString

-- | Match the value for an attribute. For malformed XML we do our best to
--   guess the programmer's intention.
string :: LString -> (String, LString)
break' :: (a -> Bool) -> [(b, a)] -> ([a], [(b, a)])
breakn :: (a -> Bool) -> [(b, a)] -> ([a], [(b, a)])
decode_attr :: String -> String
data Txt
TxtBit :: String -> Txt
CRefBit :: String -> Txt
decode_text :: [Char] -> [Txt]
cref_to_char :: [Char] -> Maybe Char
num_esc :: String -> Maybe Char
cvt_char :: Int -> Maybe Char
instance GHC.Show.Show Text.XML.Light.Lexer.Token
instance GHC.Show.Show Text.XML.Light.Lexer.Txt
instance Text.XML.Light.Lexer.XmlSource (Text.XML.Light.Lexer.Scanner s)
instance Text.XML.Light.Lexer.XmlSource GHC.Base.String
instance Text.XML.Light.Lexer.XmlSource Data.ByteString.Internal.ByteString
instance Text.XML.Light.Lexer.XmlSource Data.ByteString.Lazy.Internal.ByteString
instance Text.XML.Light.Lexer.XmlSource Data.Text.Internal.Text
instance Text.XML.Light.Lexer.XmlSource Data.Text.Internal.Lazy.Text


-- | Lightweight XML parsing
module Text.XML.Light.Input

-- | parseXML to a list of content chunks
parseXML :: XmlSource s => s -> [Content]

-- | parseXMLDoc, parse a XMLl document to maybe an element
parseXMLDoc :: XmlSource s => s -> Maybe Element


-- | XML cursors for working XML content withing the context of an XML
--   document. This implementation is based on the general tree zipper
--   written by Krasimir Angelov and Iavor S. Diatchki.
module Text.XML.Light.Cursor
data Tag
Tag :: QName -> [Attr] -> Maybe Line -> Tag
[tagName] :: Tag -> QName
[tagAttribs] :: Tag -> [Attr]
[tagLine] :: Tag -> Maybe Line
getTag :: Element -> Tag
setTag :: Tag -> Element -> Element
fromTag :: Tag -> [Content] -> Element

-- | The position of a piece of content in an XML document.
data Cursor
Cur :: Content -> [Content] -> [Content] -> Path -> Cursor

-- | The currently selected content.
[current] :: Cursor -> Content

-- | Siblings on the left, closest first.
[lefts] :: Cursor -> [Content]

-- | Siblings on the right, closest first.
[rights] :: Cursor -> [Content]

-- | The contexts of the parent elements of this location.
[parents] :: Cursor -> Path
type Path = [([Content], Tag, [Content])]

-- | A cursor for the given content.
fromContent :: Content -> Cursor

-- | A cursor for the given element.
fromElement :: Element -> Cursor

-- | The location of the first tree in a forest.
fromForest :: [Content] -> Maybe Cursor

-- | Computes the forest containing this location.
toForest :: Cursor -> [Content]

-- | Computes the tree containing this location.
toTree :: Cursor -> Content

-- | The parent of the given location.
parent :: Cursor -> Maybe Cursor

-- | The top-most parent of the given location.
root :: Cursor -> Cursor

-- | The child with the given index (starting from 0).
getChild :: Int -> Cursor -> Maybe Cursor

-- | The first child of the given location.
firstChild :: Cursor -> Maybe Cursor

-- | The last child of the given location.
lastChild :: Cursor -> Maybe Cursor

-- | The left sibling of the given location.
left :: Cursor -> Maybe Cursor

-- | The right sibling of the given location.
right :: Cursor -> Maybe Cursor

-- | The next position in a left-to-right depth-first traversal of a
--   document: either the first child, right sibling, or the right sibling
--   of a parent that has one.
nextDF :: Cursor -> Maybe Cursor

-- | The first child that satisfies a predicate.
findChild :: (Cursor -> Bool) -> Cursor -> Maybe Cursor

-- | Find the next left sibling that satisfies a predicate.
findLeft :: (Cursor -> Bool) -> Cursor -> Maybe Cursor

-- | Find the next right sibling that satisfies a predicate.
findRight :: (Cursor -> Bool) -> Cursor -> Maybe Cursor

-- | Perform a depth first search for a descendant that satisfies the given
--   predicate.
findRec :: (Cursor -> Bool) -> Cursor -> Maybe Cursor

-- | Are we at the top of the document?
isRoot :: Cursor -> Bool

-- | Are we at the left end of the the document?
isFirst :: Cursor -> Bool

-- | Are we at the right end of the document?
isLast :: Cursor -> Bool

-- | Are we at the bottom of the document?
isLeaf :: Cursor -> Bool

-- | Do we have a parent?
isChild :: Cursor -> Bool

-- | Do we have children?
hasChildren :: Cursor -> Bool

-- | Get the node index inside the sequence of children
getNodeIndex :: Cursor -> Int

-- | Change the current content.
setContent :: Content -> Cursor -> Cursor

-- | Modify the current content.
modifyContent :: (Content -> Content) -> Cursor -> Cursor

-- | Modify the current content, allowing for an effect.
modifyContentM :: Monad m => (Content -> m Content) -> Cursor -> m Cursor

-- | Insert content to the left of the current position.
insertLeft :: Content -> Cursor -> Cursor

-- | Insert content to the right of the current position.
insertRight :: Content -> Cursor -> Cursor

-- | Insert content to the left of the current position. The new content
--   becomes the current position.
insertGoLeft :: Content -> Cursor -> Cursor

-- | Insert content to the right of the current position. The new content
--   becomes the current position.
insertGoRight :: Content -> Cursor -> Cursor

-- | Remove the content on the left of the current position, if any.
removeLeft :: Cursor -> Maybe (Content, Cursor)

-- | Remove the content on the right of the current position, if any.
removeRight :: Cursor -> Maybe (Content, Cursor)

-- | Remove the current element. The new position is the one on the left.
removeGoLeft :: Cursor -> Maybe Cursor

-- | Remove the current element. The new position is the one on the right.
removeGoRight :: Cursor -> Maybe Cursor

-- | Remove the current element. The new position is the parent of the old
--   position.
removeGoUp :: Cursor -> Maybe Cursor
instance GHC.Show.Show Text.XML.Light.Cursor.Tag
instance GHC.Show.Show Text.XML.Light.Cursor.Cursor


-- | A lightweight XML parsing, filtering and generating library.
--   
--   This module reexports functions from:
--   
--   <ul>
--   <li><a>Text.XML.Light.Types</a></li>
--   <li><a>Text.XML.Light.Proc</a></li>
--   <li><a>Text.XML.Light.Input</a></li>
--   <li><a>Text.XML.Light.Output</a></li>
--   </ul>
module Text.XML.Light

-- | A smart element constructor which uses the type of its argument to
--   determine what sort of element to make.
class Node t
node :: Node t => QName -> t -> Element

-- | Add an attribute to an element.
add_attr :: Attr -> Element -> Element

-- | Add some attributes to an element.
add_attrs :: [Attr] -> Element -> Element

-- | Create an unqualified name.
unqual :: String -> QName

-- | Create node with unqualified name
unode :: Node t => String -> t -> Element
instance Text.XML.Light.Node ([Text.XML.Light.Types.Attr], [Text.XML.Light.Types.Content])
instance Text.XML.Light.Node [Text.XML.Light.Types.Attr]
instance Text.XML.Light.Node Text.XML.Light.Types.Attr
instance Text.XML.Light.Node ()
instance Text.XML.Light.Node [Text.XML.Light.Types.Content]
instance Text.XML.Light.Node Text.XML.Light.Types.Content
instance Text.XML.Light.Node ([Text.XML.Light.Types.Attr], Text.XML.Light.Types.Content)
instance Text.XML.Light.Node (Text.XML.Light.Types.Attr, Text.XML.Light.Types.Content)
instance Text.XML.Light.Node ([Text.XML.Light.Types.Attr], [Text.XML.Light.Types.Element])
instance Text.XML.Light.Node ([Text.XML.Light.Types.Attr], Text.XML.Light.Types.Element)
instance Text.XML.Light.Node (Text.XML.Light.Types.Attr, Text.XML.Light.Types.Element)
instance Text.XML.Light.Node [Text.XML.Light.Types.Element]
instance Text.XML.Light.Node Text.XML.Light.Types.Element
instance Text.XML.Light.Node ([Text.XML.Light.Types.Attr], [Text.XML.Light.Types.CData])
instance Text.XML.Light.Node ([Text.XML.Light.Types.Attr], Text.XML.Light.Types.CData)
instance Text.XML.Light.Node (Text.XML.Light.Types.Attr, Text.XML.Light.Types.CData)
instance Text.XML.Light.Node [Text.XML.Light.Types.CData]
instance Text.XML.Light.Node Text.XML.Light.Types.CData
instance Text.XML.Light.Node ([Text.XML.Light.Types.Attr], GHC.Base.String)
instance Text.XML.Light.Node (Text.XML.Light.Types.Attr, GHC.Base.String)
instance Text.XML.Light.Node [GHC.Types.Char]
