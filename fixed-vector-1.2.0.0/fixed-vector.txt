-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic vectors with statically known size.
--   
--   Generic library for vectors with statically known size. Implementation
--   is based on
--   <a>http://unlines.wordpress.com/2010/11/15/generics-for-small-fixed-size-vectors/</a>
--   Same functions could be used to work with both ADT based vector like
--   
--   <pre>
--   data Vec3 a = a a a
--   </pre>
--   
--   Tuples are vectors too:
--   
--   <pre>
--   &gt;&gt;&gt; sum (1,2,3)
--   6
--   </pre>
--   
--   Vectors which are represented internally by arrays are provided by
--   library. Both boxed and unboxed arrays are supported.
--   
--   Library is structured as follows:
--   
--   <ul>
--   <li>Data.Vector.Fixed Generic API. It's suitable for both ADT-based
--   vector like Complex and array-based ones.</li>
--   <li>Data.Vector.Fixed.Cont Continuation based vectors. Internally all
--   functions use them.</li>
--   <li>Data.Vector.Fixed.Mutable Type classes for array-based
--   implementation and API for working with mutable state.</li>
--   <li>Data.Vector.Fixed.Unboxed Unboxed vectors.</li>
--   <li>Data.Vector.Fixed.Boxed Boxed vector which can hold elements of
--   any type.</li>
--   <li>Data.Vector.Fixed.Storable Unboxed vectors of Storable types.</li>
--   <li>Data.Vector.Fixed.Primitive Unboxed vectors based on pritimive
--   package.</li>
--   </ul>
@package fixed-vector
@version 1.2.0.0


-- | API for Church-encoded vectors. Implementation of function from
--   <a>Data.Vector.Fixed</a> module uses these function internally in
--   order to provide shortcut fusion.
module Data.Vector.Fixed.Cont

-- | Peano numbers. Since type level naturals don't support induction we
--   have to convert type nats to Peano representation first and work with
--   it,
data PeanoNum
Z :: PeanoNum
S :: PeanoNum -> PeanoNum

-- | Convert type level natural to Peano representation
type family Peano (n :: Nat) :: PeanoNum

-- | Type family for sum of unary natural numbers.
type family Add (n :: PeanoNum) (m :: PeanoNum) :: PeanoNum

-- | Type family for n-ary functions. <tt>n</tt> is number of parameters of
--   type <tt>a</tt> and <tt>b</tt> is result type.
type family Fn (n :: PeanoNum) (a :: *) (b :: *)

-- | Newtype wrapper which is used to make <a>Fn</a> injective. It's also a
--   reader monad.
newtype Fun n a b
Fun :: Fn n a b -> Fun n a b
[unFun] :: Fun n a b -> Fn n a b

-- | Type class for type level number for which we can defined operations
--   over N-ary functions.
type Arity n = (ArityPeano (Peano n), KnownNat n, Peano (n + 1) ~ 'S (Peano n))

-- | Type class for handling <i>n</i>-ary functions.
class ArityPeano n

-- | Left fold over <i>n</i> elements exposed as n-ary function. These
--   elements are supplied as arguments to the function.
accum :: ArityPeano n => (forall k. t ('S k) -> a -> t k) -> (t 'Z -> b) -> t n -> Fun n a b

-- | Apply all parameters to the function.
applyFun :: ArityPeano n => (forall k. t ('S k) -> (a, t k)) -> t n -> (CVecPeano n a, t 'Z)

-- | Apply all parameters to the function using monadic actions. Note that
--   for identity monad it's same as applyFun. Ignoring newtypes:
--   
--   <pre>
--   forall b. Fn n a b -&gt; b  ~ ContVec n a
--   </pre>
applyFunM :: (ArityPeano n, Applicative f) => (forall k. t ('S k) -> (f a, t k)) -> t n -> (f (CVecPeano n a), t 'Z)

-- | Reverse order of parameters. It's implemented directly in type class
--   since expressing it in terms of <tt>accum</tt> will require putting
--   ArityPeano constraint on step funcion
reverseF :: ArityPeano n => Fun n a b -> Fun n a b

-- | Worker function for <a>gunfold</a>
gunfoldF :: (ArityPeano n, Data a) => (forall b x. Data b => c (b -> x) -> c x) -> T_gunfold c r a n -> c r

-- | Arity of function.
arity :: KnownNat n => proxy n -> Int

-- | Apply all parameters to the function.
apply :: Arity n => (forall k. t ('S k) -> (a, t k)) -> t (Peano n) -> ContVec n a

-- | Apply all parameters to the function using applicative actions.
applyM :: (Applicative f, Arity n) => (forall k. t ('S k) -> (f a, t k)) -> t (Peano n) -> f (ContVec n a)

-- | Prepend ignored parameter to function
constFun :: Fun n a b -> Fun ('S n) a b

-- | Curry first parameter of n-ary function
curryFirst :: Fun ('S n) a b -> a -> Fun n a b

-- | Uncurry first parameter of n-ary function
uncurryFirst :: (a -> Fun n a b) -> Fun ('S n) a b

-- | Curry last parameter of n-ary function
curryLast :: ArityPeano n => Fun ('S n) a b -> Fun n a (a -> b)

-- | Curry <i>n</i> first parameters of n-ary function
curryMany :: forall n k a b. ArityPeano n => Fun (Add n k) a b -> Fun n a (Fun k a b)

-- | Apply last parameter to function. Unlike <tt>apFun</tt> we need to
--   traverse all parameters but last hence <a>Arity</a> constraint.
apLast :: ArityPeano n => Fun ('S n) a b -> a -> Fun n a b

-- | Move function parameter to the result of N-ary function.
shuffleFun :: ArityPeano n => (b -> Fun n a r) -> Fun n a (b -> r)

-- | Recursive step for the function
withFun :: (Fun n a b -> Fun n a b) -> Fun ('S n) a b -> Fun ('S n) a b

-- | Size of vector expressed as type-level natural.
type family Dim (v :: * -> *) :: Nat

-- | Type class for vectors with fixed length. Instance should provide two
--   functions: one to create vector and another for vector deconstruction.
--   They must obey following law:
--   
--   <pre>
--   inspect v construct = v
--   </pre>
--   
--   For example instance for 2D vectors could be written as:
--   
--   <pre>
--   data V2 a = V2 a a
--   
--   type instance V2 = 2
--   instance Vector V2 a where
--     construct                = Fun V2
--     inspect (V2 a b) (Fun f) = f a b
--   </pre>
class Arity (Dim v) => Vector v a

-- | N-ary function for creation of vectors.
construct :: Vector v a => Fun (Peano (Dim v)) a (v a)

-- | Deconstruction of vector.
inspect :: Vector v a => v a -> Fun (Peano (Dim v)) a b -> b

-- | Optional more efficient implementation of indexing. Shouldn't be used
--   directly, use <a>!</a> instead.
basicIndex :: Vector v a => v a -> Int -> a

-- | Vector parametrized by length. In ideal world it should be:
--   
--   <pre>
--   forall n. (Arity n, Vector (v n) a, Dim (v n) ~ n) =&gt; VectorN v a
--   </pre>
--   
--   Alas polymorphic constraints aren't allowed in haskell.
class (Vector (v n) a, Dim (v n) ~ n) => VectorN v n a

-- | Length of vector. Function doesn't evaluate its argument.
length :: forall v a. KnownNat (Dim v) => v a -> Int

-- | Vector represented as continuation. Alternative wording: it's Church
--   encoded N-element vector.
newtype ContVec n a
ContVec :: (forall r. Fun (Peano n) a r -> r) -> ContVec n a

-- | Same as <a>ContVec</a> but its length is expressed as Peano number.
newtype CVecPeano n a
CVecPeano :: (forall r. Fun n a r -> r) -> CVecPeano n a

-- | Cons values to the <tt>CVecPeano</tt>.
consPeano :: a -> CVecPeano n a -> CVecPeano ('S n) a
toContVec :: CVecPeano (Peano n) a -> ContVec n a

-- | Run continuation vector. It's same as <a>inspect</a> but with
--   arguments flipped.
runContVec :: Fun (Peano n) a r -> ContVec n a -> r

-- | Convert regular vector to continuation based one.
cvec :: (Vector v a, Dim v ~ n) => v a -> ContVec n a

-- | Convert list to continuation-based vector. Will throw error if list is
--   shorter than resulting vector.
fromList :: Arity n => [a] -> ContVec n a

-- | Same as <a>fromList</a> bu throws error is list doesn't have same
--   length as vector.
fromList' :: forall n a. Arity n => [a] -> ContVec n a

-- | Convert list to continuation-based vector. Will fail with
--   <a>Nothing</a> if list doesn't have right length.
fromListM :: forall n a. Arity n => [a] -> Maybe (ContVec n a)

-- | Convert vector to the list
toList :: Arity n => ContVec n a -> [a]

-- | Execute monadic action for every element of vector. Synonym for
--   <a>pure</a>.
replicate :: Arity n => a -> ContVec n a

-- | Execute monadic action for every element of vector.
replicateM :: (Arity n, Applicative f) => f a -> f (ContVec n a)

-- | Generate vector from function which maps element's index to its value.
generate :: Arity n => (Int -> a) -> ContVec n a

-- | Generate vector from monadic function which maps element's index to
--   its value.
generateM :: (Applicative f, Arity n) => (Int -> f a) -> f (ContVec n a)

-- | Unfold vector.
unfoldr :: Arity n => (b -> (a, b)) -> b -> ContVec n a

-- | Unit vector along Nth axis.
basis :: (Num a, Arity n) => Int -> ContVec n a

-- | Create empty vector.
empty :: ContVec 0 a

-- | <i>O(1)</i> Prepend element to vector
cons :: Arity n => a -> ContVec n a -> ContVec (n + 1) a

-- | Prepend single element vector to another vector.
consV :: Arity n => ContVec 1 a -> ContVec n a -> ContVec (n + 1) a

-- | <i>O(1)</i> Append element to vector
snoc :: Arity n => a -> ContVec n a -> ContVec (n + 1) a

-- | Concatenate vector
concat :: (Arity n, Arity k, Arity (n + k), Peano (n + k) ~ Add (Peano n) (Peano k)) => ContVec n a -> ContVec k a -> ContVec (n + k) a
mk1 :: a -> ContVec 1 a
mk2 :: a -> a -> ContVec 2 a
mk3 :: a -> a -> a -> ContVec 3 a
mk4 :: a -> a -> a -> a -> ContVec 4 a
mk5 :: a -> a -> a -> a -> a -> ContVec 5 a

-- | Map over vector. Synonym for <a>fmap</a>
map :: Arity n => (a -> b) -> ContVec n a -> ContVec n b

-- | Apply function to every element of the vector and its index.
imap :: Arity n => (Int -> a -> b) -> ContVec n a -> ContVec n b

-- | Effectful map over vector.
mapM :: (Arity n, Applicative f) => (a -> f b) -> ContVec n a -> f (ContVec n b)

-- | Apply monadic function to every element of the vector and its index.
imapM :: (Arity n, Applicative f) => (Int -> a -> f b) -> ContVec n a -> f (ContVec n b)

-- | Apply monadic action to each element of vector and ignore result.
mapM_ :: (Arity n, Applicative f) => (a -> f b) -> ContVec n a -> f ()

-- | Apply monadic action to each element of vector and its index and
--   ignore result.
imapM_ :: (Arity n, Applicative f) => (Int -> a -> f b) -> ContVec n a -> f ()

-- | Left scan over vector
scanl :: Arity n => (b -> a -> b) -> b -> ContVec n a -> ContVec (n + 1) b

-- | Left scan over vector
scanl1 :: Arity n => (a -> a -> a) -> ContVec n a -> ContVec n a

-- | Evaluate every action in the vector from left to right.
sequence :: (Arity n, Applicative f) => ContVec n (f a) -> f (ContVec n a)

-- | Evaluate every action in the vector from left to right and ignore
--   result.
sequence_ :: (Arity n, Applicative f) => ContVec n (f a) -> f ()

-- | The dual of sequenceA
distribute :: (Functor f, Arity n) => f (ContVec n a) -> ContVec n (f a)
collect :: (Functor f, Arity n) => (a -> ContVec n b) -> f a -> ContVec n (f b)

-- | <i>O(1)</i> Tail of vector.
tail :: Arity n => ContVec (n + 1) a -> ContVec n a

-- | Reverse order of elements in the vector
reverse :: Arity n => ContVec n a -> ContVec n a

-- | Zip two vector together using function.
zipWith :: Arity n => (a -> b -> c) -> ContVec n a -> ContVec n b -> ContVec n c

-- | Zip three vectors together
zipWith3 :: Arity n => (a -> b -> c -> d) -> ContVec n a -> ContVec n b -> ContVec n c -> ContVec n d

-- | Zip two vector together using function which takes element index as
--   well.
izipWith :: Arity n => (Int -> a -> b -> c) -> ContVec n a -> ContVec n b -> ContVec n c

-- | Zip three vectors together
izipWith3 :: Arity n => (Int -> a -> b -> c -> d) -> ContVec n a -> ContVec n b -> ContVec n c -> ContVec n d

-- | Zip two vector together using monadic function.
zipWithM :: (Arity n, Applicative f) => (a -> b -> f c) -> ContVec n a -> ContVec n b -> f (ContVec n c)
zipWithM_ :: (Arity n, Applicative f) => (a -> b -> f c) -> ContVec n a -> ContVec n b -> f ()

-- | Zip two vector together using monadic function which takes element
--   index as well..
izipWithM :: (Arity n, Applicative f) => (Int -> a -> b -> f c) -> ContVec n a -> ContVec n b -> f (ContVec n c)
izipWithM_ :: (Arity n, Applicative f) => (Int -> a -> b -> f c) -> ContVec n a -> ContVec n b -> f ()

-- | Finalizer function for getting head of the vector.
head :: (Arity n, 1 <= n) => ContVec n a -> a

-- | <i>O(n)</i> Get value at specified index.
index :: Arity n => Int -> ContVec n a -> a

-- | Twan van Laarhoven lens for continuation based vector
element :: (Arity n, Functor f) => Int -> (a -> f a) -> ContVec n a -> f (ContVec n a)

-- | Convert continuation to the vector.
vector :: (Vector v a, Dim v ~ n) => ContVec n a -> v a

-- | Left fold over continuation vector.
foldl :: Arity n => (b -> a -> b) -> b -> ContVec n a -> b

-- | Left fold.
foldl1 :: (Arity n, 1 <= n) => (a -> a -> a) -> ContVec n a -> a

-- | Right fold over continuation vector
foldr :: Arity n => (a -> b -> b) -> b -> ContVec n a -> b

-- | Left fold over continuation vector.
ifoldl :: Arity n => (b -> Int -> a -> b) -> b -> ContVec n a -> b

-- | Right fold over continuation vector
ifoldr :: Arity n => (Int -> a -> b -> b) -> b -> ContVec n a -> b

-- | Monadic left fold over continuation vector.
foldM :: (Arity n, Monad m) => (b -> a -> m b) -> b -> ContVec n a -> m b

-- | Monadic left fold over continuation vector.
ifoldM :: (Arity n, Monad m) => (b -> Int -> a -> m b) -> b -> ContVec n a -> m b

-- | Sum all elements in the vector.
sum :: (Num a, Arity n) => ContVec n a -> a

-- | Minimal element of vector.
minimum :: (Ord a, Arity n, 1 <= n) => ContVec n a -> a

-- | Maximal element of vector.
maximum :: (Ord a, Arity n, 1 <= n) => ContVec n a -> a

-- | Conjunction of elements of a vector.
and :: Arity n => ContVec n Bool -> Bool

-- | Disjunction of all elements of a vector.
or :: Arity n => ContVec n Bool -> Bool

-- | Determines whether all elements of vector satisfy predicate.
all :: Arity n => (a -> Bool) -> ContVec n a -> Bool

-- | Determines whether any of element of vector satisfy predicate.
any :: Arity n => (a -> Bool) -> ContVec n a -> Bool

-- | The <a>find</a> function takes a predicate and a vector and returns
--   the leftmost element of the vector matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: Arity n => (a -> Bool) -> ContVec n a -> Maybe a

-- | Generic <a>gfoldl</a> which could work with any vector.
gfoldl :: forall c v a. (Vector v a, Data a) => (forall x y. Data x => c (x -> y) -> x -> c y) -> (forall x. x -> c x) -> v a -> c (v a)

-- | Generic <a>gunfoldl</a> which could work with any vector. Since vector
--   can only have one constructor argument for constructor is ignored.
gunfold :: forall con c v a. (Vector v a, Data a) => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> con -> c (v a)
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Cont.Vector (Data.Vector.Fixed.Cont.ContVec n) a
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Cont.VectorN Data.Vector.Fixed.Cont.ContVec n a
instance Data.Vector.Fixed.Cont.Arity n => Data.Traversable.Traversable (Data.Vector.Fixed.Cont.ContVec n)
instance Data.Vector.Fixed.Cont.Vector Data.Complex.Complex a
instance Data.Vector.Fixed.Cont.Vector Data.Functor.Identity.Identity a
instance (b GHC.Types.~ a) => Data.Vector.Fixed.Cont.Vector ((,) b) a
instance (b GHC.Types.~ a, c GHC.Types.~ a) => Data.Vector.Fixed.Cont.Vector ((,,) b c) a
instance (b GHC.Types.~ a, c GHC.Types.~ a, d GHC.Types.~ a) => Data.Vector.Fixed.Cont.Vector ((,,,) b c d) a
instance (b GHC.Types.~ a, c GHC.Types.~ a, d GHC.Types.~ a, e GHC.Types.~ a) => Data.Vector.Fixed.Cont.Vector ((,,,,) b c d e) a
instance (b GHC.Types.~ a, c GHC.Types.~ a, d GHC.Types.~ a, e GHC.Types.~ a, f GHC.Types.~ a) => Data.Vector.Fixed.Cont.Vector ((,,,,,) b c d e f) a
instance (b GHC.Types.~ a, c GHC.Types.~ a, d GHC.Types.~ a, e GHC.Types.~ a, f GHC.Types.~ a, g GHC.Types.~ a) => Data.Vector.Fixed.Cont.Vector ((,,,,,,) b c d e f g) a
instance Data.Vector.Fixed.Cont.Vector Data.Proxy.Proxy a
instance Data.Vector.Fixed.Cont.Arity n => GHC.Base.Functor (Data.Vector.Fixed.Cont.ContVec n)
instance Data.Vector.Fixed.Cont.Arity n => GHC.Base.Applicative (Data.Vector.Fixed.Cont.ContVec n)
instance Data.Vector.Fixed.Cont.Arity n => Data.Foldable.Foldable (Data.Vector.Fixed.Cont.ContVec n)
instance Data.Vector.Fixed.Cont.ArityPeano n => GHC.Base.Functor (Data.Vector.Fixed.Cont.Fun n a)
instance Data.Vector.Fixed.Cont.ArityPeano n => GHC.Base.Applicative (Data.Vector.Fixed.Cont.Fun n a)
instance Data.Vector.Fixed.Cont.ArityPeano n => GHC.Base.Monad (Data.Vector.Fixed.Cont.Fun n a)
instance Data.Vector.Fixed.Cont.ArityPeano 'Data.Vector.Fixed.Cont.Z
instance Data.Vector.Fixed.Cont.ArityPeano n => Data.Vector.Fixed.Cont.ArityPeano ('Data.Vector.Fixed.Cont.S n)


-- | More generic version of function from <a>Data.Vector.Fixed</a> module.
--   They do not require that all vector have same type, only same length.
--   All such functions have suffix <i>G</i>.
module Data.Vector.Fixed.Generic

-- | Map over vector
mapG :: (Vector v a, Vector w b, Dim v ~ Dim w) => (a -> b) -> v a -> w b

-- | Apply function to every element of the vector and its index.
imapG :: (Vector v a, Vector w b, Dim v ~ Dim w) => (Int -> a -> b) -> v a -> w b

-- | Monadic map over vector.
mapMG :: (Vector v a, Vector w b, Dim w ~ Dim v, Monad m) => (a -> m b) -> v a -> m (w b)

-- | Monadic map over vector.
imapMG :: (Vector v a, Vector w b, Dim w ~ Dim v, Monad m) => (Int -> a -> m b) -> v a -> m (w b)

-- | Zip two vector together using function.
zipWithG :: (Vector v a, Vector w b, Vector u c, Dim v ~ Dim u, Dim v ~ Dim w) => (a -> b -> c) -> v a -> w b -> u c

-- | Zip two vector together using function which takes element index as
--   well.
izipWithG :: (Vector v a, Vector w b, Vector u c, Dim v ~ Dim u, Dim v ~ Dim w) => (Int -> a -> b -> c) -> v a -> w b -> u c

-- | Zip two vector together using monadic function.
zipWithMG :: (Vector v a, Vector w b, Vector u c, Dim v ~ Dim u, Dim v ~ Dim w, Monad m) => (a -> b -> m c) -> v a -> w b -> m (u c)

-- | Zip two vector together using monadic function which takes element
--   index as well..
izipWithMG :: (Vector v a, Vector w b, Vector u c, Dim v ~ Dim u, Dim v ~ Dim w, Monad m) => (Int -> a -> b -> m c) -> v a -> w b -> m (u c)


-- | Generic API for vectors with fixed length.
--   
--   For encoding of vector size library uses Peano naturals defined in the
--   library. At come point in the future it would make sense to switch to
--   new GHC type level numerals.
--   
--   <ul>
--   <li><i><tt>Common pitfalls</tt></i></li>
--   </ul>
--   
--   Library provide instances for tuples. But there's a catch. Tuples are
--   monomorphic in element type. Let consider 2-tuple <tt>(Int,Int)</tt>.
--   Vector type <tt>v</tt> is <tt>(,) Int</tt> and only allowed element
--   type is <tt>Int</tt>. Because of that we cannot change element type
--   and following code will fail:
--   
--   <pre>
--   &gt;&gt;&gt; map (== 1) ((1,2) :: (Int,Int))
--   
--   &lt;interactive&gt;:3:1:
--       Couldn't match type `Int' with `Bool'
--       In the expression: F.map (== 1) ((1, 2) :: (Int, Int))
--       In an equation for `it': it = map (== 1) ((1, 2) :: (Int, Int))
--   </pre>
--   
--   To make it work we need to change vector type as well. Functions from
--   module <a>Data.Vector.Fixed.Generic</a> provide this functionality.
--   
--   <pre>
--   &gt;&gt;&gt; map (== 1) ((1,2) :: (Int,Int)) :: (Bool,Bool)
--   (True,False)
--   </pre>
module Data.Vector.Fixed

-- | Size of vector expressed as type-level natural.
type family Dim (v :: * -> *) :: Nat

-- | Type class for vectors with fixed length. Instance should provide two
--   functions: one to create vector and another for vector deconstruction.
--   They must obey following law:
--   
--   <pre>
--   inspect v construct = v
--   </pre>
--   
--   For example instance for 2D vectors could be written as:
--   
--   <pre>
--   data V2 a = V2 a a
--   
--   type instance V2 = 2
--   instance Vector V2 a where
--     construct                = Fun V2
--     inspect (V2 a b) (Fun f) = f a b
--   </pre>
class Arity (Dim v) => Vector v a

-- | N-ary function for creation of vectors.
construct :: Vector v a => Fun (Peano (Dim v)) a (v a)

-- | Deconstruction of vector.
inspect :: Vector v a => v a -> Fun (Peano (Dim v)) a b -> b

-- | Optional more efficient implementation of indexing. Shouldn't be used
--   directly, use <a>!</a> instead.
basicIndex :: Vector v a => v a -> Int -> a

-- | Vector parametrized by length. In ideal world it should be:
--   
--   <pre>
--   forall n. (Arity n, Vector (v n) a, Dim (v n) ~ n) =&gt; VectorN v a
--   </pre>
--   
--   Alas polymorphic constraints aren't allowed in haskell.
class (Vector (v n) a, Dim (v n) ~ n) => VectorN v n a

-- | Type class for type level number for which we can defined operations
--   over N-ary functions.
type Arity n = (ArityPeano (Peano n), KnownNat n, Peano (n + 1) ~ 'S (Peano n))

-- | Newtype wrapper which is used to make <a>Fn</a> injective. It's also a
--   reader monad.
newtype Fun n a b
Fun :: Fn n a b -> Fun n a b
[unFun] :: Fun n a b -> Fn n a b

-- | Length of vector. Function doesn't evaluate its argument.
length :: forall v a. KnownNat (Dim v) => v a -> Int
mk0 :: (Vector v a, Dim v ~ 0) => v a
mk1 :: (Vector v a, Dim v ~ 1) => a -> v a
mk2 :: (Vector v a, Dim v ~ 2) => a -> a -> v a
mk3 :: (Vector v a, Dim v ~ 3) => a -> a -> a -> v a
mk4 :: (Vector v a, Dim v ~ 4) => a -> a -> a -> a -> v a
mk5 :: (Vector v a, Dim v ~ 5) => a -> a -> a -> a -> a -> v a

-- | N-ary constructor. Despite scary signature it's just N-ary function
--   with additional type parameter which is used to fix type of vector
--   being constructed. It could be used as:
--   
--   <pre>
--   v = mkN (Proxy :: Proxy (Int,Int,Int)) 1 2 3
--   </pre>
--   
--   or using <tt>TypeApplications</tt> syntax:
--   
--   <pre>
--   v = mkN (Proxy @ (Int,Int,Int)) 1 2 3
--   </pre>
--   
--   or if type of <tt>v</tt> is fixed elsewhere
--   
--   <pre>
--   v = mkN [v] 1 2 3
--   </pre>
mkN :: forall proxy v a. Vector v a => proxy (v a) -> Fn (Peano (Dim v)) a (v a)

-- | Vector represented as continuation. Alternative wording: it's Church
--   encoded N-element vector.
data ContVec n a

-- | Create empty vector.
empty :: ContVec 0 a

-- | Convert continuation to the vector.
vector :: (Vector v a, Dim v ~ n) => ContVec n a -> v a

-- | Convert regular vector to continuation based one.
cvec :: (Vector v a, Dim v ~ n) => v a -> ContVec n a

-- | Replicate value <i>n</i> times.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec2)
--   
--   &gt;&gt;&gt; replicate 1 :: Vec2 Int
--   fromList [1,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate 2 :: (Double,Double,Double)
--   (2.0,2.0,2.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec4)
--   
--   &gt;&gt;&gt; replicate "foo" :: Vec4 String
--   fromList ["foo","foo","foo","foo"]
--   </pre>
replicate :: Vector v a => a -> v a

-- | Execute monadic action for every element of vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec2,Vec3)
--   
--   &gt;&gt;&gt; replicateM (Just 3) :: Maybe (Vec3 Int)
--   Just (fromList [3,3,3])
--   
--   &gt;&gt;&gt; replicateM (putStrLn "Hi!") :: IO (Vec2 ())
--   Hi!
--   Hi!
--   fromList [(),()]
--   </pre>
replicateM :: (Vector v a, Applicative f) => f a -> f (v a)

-- | Generate vector from function which maps element's index to its value.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Unboxed (Vec4)
--   
--   &gt;&gt;&gt; generate (^2) :: Vec4 Int
--   fromList [0,1,4,9]
--   </pre>
generate :: Vector v a => (Int -> a) -> v a

-- | Generate vector from monadic function which maps element's index to
--   its value.
generateM :: (Applicative f, Vector v a) => (Int -> f a) -> f (v a)

-- | Unfold vector.
unfoldr :: Vector v a => (b -> (a, b)) -> b -> v a

-- | Unit vector along Nth axis. If index is larger than vector dimensions
--   returns zero vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec3)
--   
--   &gt;&gt;&gt; basis 0 :: Vec3 Int
--   fromList [1,0,0]
--   
--   &gt;&gt;&gt; basis 1 :: Vec3 Int
--   fromList [0,1,0]
--   
--   &gt;&gt;&gt; basis 3 :: Vec3 Int
--   fromList [0,0,0]
--   </pre>
basis :: (Vector v a, Num a) => Int -> v a

-- | First element of vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec3)
--   
--   &gt;&gt;&gt; let x = mk3 1 2 3 :: Vec3 Int
--   
--   &gt;&gt;&gt; head x
--   1
--   </pre>
head :: (Vector v a, 1 <= Dim v) => v a -> a

-- | Tail of vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; tail (1,2,3) :: Complex Double
--   2.0 :+ 3.0
--   </pre>
tail :: (Vector v a, Vector w a, Dim v ~ (Dim w + 1)) => v a -> w a

-- | Cons element to the vector
cons :: (Vector v a, Vector w a, Dim w ~ (Dim v + 1)) => a -> v a -> w a

-- | Append element to the vector
snoc :: (Vector v a, Vector w a, Dim w ~ (Dim v + 1)) => a -> v a -> w a
concat :: (Vector v a, Vector u a, Vector w a, (Dim v + Dim u) ~ Dim w, Peano (Dim v + Dim u) ~ Add (Peano (Dim v)) (Peano (Dim u))) => v a -> u a -> w a

-- | Reverse order of elements in the vector
reverse :: Vector v a => v a -> v a

-- | Retrieve vector's element at index. Generic implementation is
--   <i>O(n)</i> but more efficient one is used when possible.
(!) :: Vector v a => v a -> Int -> a

-- | Get element from vector at statically known index
index :: (Vector v a, KnownNat k, (k + 1) <= Dim v) => v a -> proxy k -> a

-- | Set n'th element in the vector
set :: (Vector v a, KnownNat k, (k + 1) <= Dim v) => proxy k -> a -> v a -> v a

-- | Twan van Laarhoven's lens for element of vector
element :: (Vector v a, Functor f) => Int -> (a -> f a) -> v a -> f (v a)

-- | Twan van Laarhoven's lens for element of vector with statically known
--   index.
elementTy :: (Vector v a, KnownNat k, (k + 1) <= Dim v, Functor f) => proxy k -> (a -> f a) -> v a -> f (v a)

-- | Test two vectors for equality.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec2)
--   
--   &gt;&gt;&gt; let v0 = basis 0 :: Vec2 Int
--   
--   &gt;&gt;&gt; let v1 = basis 1 :: Vec2 Int
--   
--   &gt;&gt;&gt; v0 `eq` v0
--   True
--   
--   &gt;&gt;&gt; v0 `eq` v1
--   False
--   </pre>
eq :: (Vector v a, Eq a) => v a -> v a -> Bool

-- | Lexicographic ordering of two vectors.
ord :: (Vector v a, Ord a) => v a -> v a -> Ordering

-- | Map over vector
map :: (Vector v a, Vector v b) => (a -> b) -> v a -> v b

-- | Effectful map over vector.
mapM :: (Vector v a, Vector v b, Applicative f) => (a -> f b) -> v a -> f (v b)

-- | Apply monadic action to each element of vector and ignore result.
mapM_ :: (Vector v a, Applicative f) => (a -> f b) -> v a -> f ()

-- | Apply function to every element of the vector and its index.
imap :: (Vector v a, Vector v b) => (Int -> a -> b) -> v a -> v b

-- | Apply monadic function to every element of the vector and its index.
imapM :: (Vector v a, Vector v b, Applicative f) => (Int -> a -> f b) -> v a -> f (v b)

-- | Apply monadic function to every element of the vector and its index
--   and discard result.
imapM_ :: (Vector v a, Applicative f) => (Int -> a -> f b) -> v a -> f ()

-- | Left scan over vector
scanl :: (Vector v a, Vector w b, Dim w ~ (Dim v + 1)) => (b -> a -> b) -> b -> v a -> w b

-- | Left scan over vector
scanl1 :: Vector v a => (a -> a -> a) -> v a -> v a

-- | Evaluate every action in the vector from left to right.
sequence :: (Vector v a, Vector v (f a), Applicative f) => v (f a) -> f (v a)

-- | Evaluate every action in the vector from left to right and ignore
--   result
sequence_ :: (Vector v (f a), Applicative f) => v (f a) -> f ()

-- | Analog of <a>sequenceA</a> from <a>Traversable</a>.
sequenceA :: (Vector v a, Vector v (f a), Applicative f) => v (f a) -> f (v a)

-- | Analog of <a>traverse</a> from <a>Traversable</a>.
traverse :: (Vector v a, Vector v b, Applicative f) => (a -> f b) -> v a -> f (v b)
distribute :: (Vector v a, Vector v (f a), Functor f) => f (v a) -> v (f a)
collect :: (Vector v a, Vector v b, Vector v (f b), Functor f) => (a -> v b) -> f a -> v (f b)

-- | Left fold over vector
foldl :: Vector v a => (b -> a -> b) -> b -> v a -> b

-- | Right fold over vector
foldr :: Vector v a => (a -> b -> b) -> b -> v a -> b

-- | Left fold over vector
foldl1 :: (Vector v a, 1 <= Dim v) => (a -> a -> a) -> v a -> a

-- | Combine the elements of a structure using a monoid. Similar to
--   <a>fold</a>
fold :: (Vector v m, Monoid m) => v m -> m

-- | Map each element of the structure to a monoid, and combine the
--   results. Similar to <a>foldMap</a>
foldMap :: (Vector v a, Monoid m) => (a -> m) -> v a -> m

-- | Left fold over vector. Function is applied to each element and its
--   index.
ifoldl :: Vector v a => (b -> Int -> a -> b) -> b -> v a -> b

-- | Right fold over vector
ifoldr :: Vector v a => (Int -> a -> b -> b) -> b -> v a -> b

-- | Monadic fold over vector.
foldM :: (Vector v a, Monad m) => (b -> a -> m b) -> b -> v a -> m b

-- | Left monadic fold over vector. Function is applied to each element and
--   its index.
ifoldM :: (Vector v a, Monad m) => (b -> Int -> a -> m b) -> b -> v a -> m b

-- | Sum all elements in the vector.
sum :: (Vector v a, Num a) => v a -> a

-- | Maximal element of vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec3)
--   
--   &gt;&gt;&gt; let x = mk3 1 2 3 :: Vec3 Int
--   
--   &gt;&gt;&gt; maximum x
--   3
--   </pre>
maximum :: (Vector v a, 1 <= Dim v, Ord a) => v a -> a

-- | Minimal element of vector.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec3)
--   
--   &gt;&gt;&gt; let x = mk3 1 2 3 :: Vec3 Int
--   
--   &gt;&gt;&gt; minimum x
--   1
--   </pre>
minimum :: (Vector v a, 1 <= Dim v, Ord a) => v a -> a

-- | Conjunction of all elements of a vector.
and :: Vector v Bool => v Bool -> Bool

-- | Disjunction of all elements of a vector.
or :: Vector v Bool => v Bool -> Bool

-- | Determines whether all elements of vector satisfy predicate.
all :: Vector v a => (a -> Bool) -> v a -> Bool

-- | Determines whether any of element of vector satisfy predicate.
any :: Vector v a => (a -> Bool) -> v a -> Bool

-- | The <a>find</a> function takes a predicate and a vector and returns
--   the leftmost element of the vector matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: Vector v a => (a -> Bool) -> v a -> Maybe a

-- | Zip two vector together using function.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Vector.Fixed.Boxed (Vec3)
--   
--   &gt;&gt;&gt; let b0 = basis 0 :: Vec3 Int
--   
--   &gt;&gt;&gt; let b1 = basis 1 :: Vec3 Int
--   
--   &gt;&gt;&gt; let b2 = basis 2 :: Vec3 Int
--   
--   &gt;&gt;&gt; let vplus x y = zipWith (+) x y
--   
--   &gt;&gt;&gt; vplus b0 b1
--   fromList [1,1,0]
--   
--   &gt;&gt;&gt; vplus b0 b2
--   fromList [1,0,1]
--   
--   &gt;&gt;&gt; vplus b1 b2
--   fromList [0,1,1]
--   </pre>
zipWith :: (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> v a -> v b -> v c

-- | Zip three vector together
zipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (a -> b -> c -> d) -> v a -> v b -> v c -> v d

-- | Zip two vector together using monadic function.
zipWithM :: (Vector v a, Vector v b, Vector v c, Applicative f) => (a -> b -> f c) -> v a -> v b -> f (v c)

-- | Zip two vector elementwise using monadic function and discard result
zipWithM_ :: (Vector v a, Vector v b, Applicative f) => (a -> b -> f c) -> v a -> v b -> f ()

-- | Zip two vector together using function which takes element index as
--   well.
izipWith :: (Vector v a, Vector v b, Vector v c) => (Int -> a -> b -> c) -> v a -> v b -> v c

-- | Zip three vector together
izipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (Int -> a -> b -> c -> d) -> v a -> v b -> v c -> v d

-- | Zip two vector together using monadic function which takes element
--   index as well..
izipWithM :: (Vector v a, Vector v b, Vector v c, Applicative f) => (Int -> a -> b -> f c) -> v a -> v b -> f (v c)

-- | Zip two vector elementwise using monadic function and discard result
izipWithM_ :: (Vector v a, Vector v b, Vector v c, Applicative f, Vector v (f c)) => (Int -> a -> b -> f c) -> v a -> v b -> f ()

-- | Default implementation of <a>alignment</a> for <a>Storable</a> type
--   class for fixed vectors.
defaultAlignemnt :: forall a v. Storable a => v a -> Int

-- | Default implementation of <a>sizeOf</a> for <a>Storable</a> type class
--   for fixed vectors
defaultSizeOf :: forall a v. (Storable a, Vector v a) => v a -> Int

-- | Default implementation of <a>peek</a> for <a>Storable</a> type class
--   for fixed vector
defaultPeek :: (Storable a, Vector v a) => Ptr (v a) -> IO (v a)

-- | Default implementation of <a>poke</a> for <a>Storable</a> type class
--   for fixed vector
defaultPoke :: (Storable a, Vector v a) => Ptr (v a) -> v a -> IO ()

-- | Default implementation of <a>rnf</a> from <a>NFData</a> type class
defaultRnf :: (NFData a, Vector v a) => v a -> ()

-- | Convert between different vector types
convert :: (Vector v a, Vector w a, Dim v ~ Dim w) => v a -> w a

-- | Convert vector to the list
toList :: Vector v a => v a -> [a]

-- | Create vector form list. Will throw error if list is shorter than
--   resulting vector.
fromList :: Vector v a => [a] -> v a

-- | Create vector form list. Will throw error if list has different length
--   from resulting vector.
fromList' :: Vector v a => [a] -> v a

-- | Create vector form list. Will return <tt>Nothing</tt> if list has
--   different length from resulting vector.
fromListM :: Vector v a => [a] -> Maybe (v a)

-- | Create vector from <a>Foldable</a> data type. Will return
--   <tt>Nothing</tt> if data type different number of elements that
--   resulting vector.
fromFoldable :: (Vector v a, Foldable f) => f a -> Maybe (v a)

-- | Type-based vector with statically known length parametrized by GHC's
--   type naturals
newtype VecList (n :: Nat) a
VecList :: VecPeano (Peano n) a -> VecList (n :: Nat) a

-- | Standard GADT-based vector with statically known length parametrized
--   by Peano numbers.
data VecPeano (n :: PeanoNum) a
[Nil] :: VecPeano 'Z a
[Cons] :: a -> VecPeano n a -> VecPeano ('S n) a

-- | Single-element tuple.
newtype Only a
Only :: a -> Only a

-- | Empty tuple.
data Empty a
Empty :: Empty a
type Tuple2 a = (a, a)
type Tuple3 a = (a, a, a)
type Tuple4 a = (a, a, a, a)
type Tuple5 a = (a, a, a, a, a)
instance Data.Data.Data a => Data.Data.Data (Data.Vector.Fixed.Only a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Vector.Fixed.Only a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Vector.Fixed.Only a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Vector.Fixed.Only a)
instance forall k (a :: k). GHC.Classes.Ord (Data.Vector.Fixed.Empty a)
instance forall k (a :: k). GHC.Classes.Eq (Data.Vector.Fixed.Empty a)
instance forall k (a :: k). GHC.Show.Show (Data.Vector.Fixed.Empty a)
instance Data.Data.Data a => Data.Data.Data (Data.Vector.Fixed.Empty a)
instance GHC.Base.Functor Data.Vector.Fixed.Empty
instance Data.Foldable.Foldable Data.Vector.Fixed.Empty
instance Data.Traversable.Traversable Data.Vector.Fixed.Empty
instance forall k (a :: k). Control.DeepSeq.NFData (Data.Vector.Fixed.Empty a)
instance Data.Vector.Fixed.Cont.Vector Data.Vector.Fixed.Empty a
instance GHC.Base.Functor Data.Vector.Fixed.Only
instance Data.Foldable.Foldable Data.Vector.Fixed.Only
instance Data.Traversable.Traversable Data.Vector.Fixed.Only
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Vector.Fixed.Only a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Vector.Fixed.Only a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Vector.Fixed.Only a)
instance Data.Vector.Fixed.Cont.Vector Data.Vector.Fixed.Only a
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Vector.Fixed.Only a)
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Cont.Vector (Data.Vector.Fixed.VecList n) a
instance (Data.Vector.Fixed.Cont.Arity n, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Vector.Fixed.VecList n a)
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Cont.VectorN Data.Vector.Fixed.VecList n a
instance (GHC.Show.Show a, Data.Vector.Fixed.Cont.Arity n) => GHC.Show.Show (Data.Vector.Fixed.VecList n a)
instance (GHC.Classes.Eq a, Data.Vector.Fixed.Cont.Arity n) => GHC.Classes.Eq (Data.Vector.Fixed.VecList n a)
instance (GHC.Classes.Ord a, Data.Vector.Fixed.Cont.Arity n) => GHC.Classes.Ord (Data.Vector.Fixed.VecList n a)
instance Data.Vector.Fixed.Cont.Arity n => GHC.Base.Functor (Data.Vector.Fixed.VecList n)
instance Data.Vector.Fixed.Cont.Arity n => GHC.Base.Applicative (Data.Vector.Fixed.VecList n)
instance Data.Vector.Fixed.Cont.Arity n => Data.Foldable.Foldable (Data.Vector.Fixed.VecList n)
instance Data.Vector.Fixed.Cont.Arity n => Data.Traversable.Traversable (Data.Vector.Fixed.VecList n)
instance (Data.Vector.Fixed.Cont.Arity n, GHC.Base.Monoid a) => GHC.Base.Monoid (Data.Vector.Fixed.VecList n a)
instance (Data.Vector.Fixed.Cont.Arity n, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Vector.Fixed.VecList n a)
instance (Foreign.Storable.Storable a, Data.Vector.Fixed.Cont.Arity n) => Foreign.Storable.Storable (Data.Vector.Fixed.VecList n a)


-- | Type classes for vectors which are implemented on top of the arrays
--   and support in-place mutation. API is similar to one used in the
--   <tt>vector</tt> package.
module Data.Vector.Fixed.Mutable

-- | Type class for type level number for which we can defined operations
--   over N-ary functions.
type Arity n = (ArityPeano (Peano n), KnownNat n, Peano (n + 1) ~ 'S (Peano n))

-- | Arity of function.
arity :: KnownNat n => proxy n -> Int

-- | Mutable counterpart of fixed-length vector.
type family Mutable (v :: * -> *) :: * -> * -> *

-- | Dimension for mutable vector.
type family DimM (v :: * -> * -> *) :: Nat

-- | Type class for mutable vectors.
class (Arity (DimM v)) => MVector v a

-- | Copy vector. The two vectors may not overlap. Since vectors' length is
--   encoded in the type there is no need in runtime checks.
copy :: (MVector v a, PrimMonad m) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Copy vector. The two vectors may overlap. Since vectors' length is
--   encoded in the type there is no need in runtime checks.
move :: (MVector v a, PrimMonad m) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Allocate new vector
new :: (MVector v a, PrimMonad m) => m (v (PrimState m) a)

-- | Read value at index without bound checks.
unsafeRead :: (MVector v a, PrimMonad m) => v (PrimState m) a -> Int -> m a

-- | Write value at index without bound checks.
unsafeWrite :: (MVector v a, PrimMonad m) => v (PrimState m) a -> Int -> a -> m ()

-- | Length of mutable vector. Function doesn't evaluate its argument.
lengthM :: forall v s a. Arity (DimM v) => v s a -> Int

-- | Read value at index with bound checks.
read :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m a

-- | Write value at index with bound checks.
write :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m ()

-- | Create copy of vector.
clone :: (PrimMonad m, MVector v a) => v (PrimState m) a -> m (v (PrimState m) a)

-- | Type class for immutable vectors
class (Dim v ~ DimM (Mutable v), MVector (Mutable v) a) => IVector v a

-- | Convert vector to immutable state. Mutable vector must not be modified
--   afterwards.
unsafeFreeze :: (IVector v a, PrimMonad m) => Mutable v (PrimState m) a -> m (v a)

-- | Convert immutable vector to mutable. Immutable vector must not be used
--   afterwards.
unsafeThaw :: (IVector v a, PrimMonad m) => v a -> m (Mutable v (PrimState m) a)

-- | Get element at specified index without bounds check.
unsafeIndex :: IVector v a => v a -> Int -> a
index :: IVector v a => v a -> Int -> a

-- | Safely convert mutable vector to immutable.
freeze :: (PrimMonad m, IVector v a) => Mutable v (PrimState m) a -> m (v a)

-- | Safely convert immutable vector to mutable.
thaw :: (PrimMonad m, IVector v a) => v a -> m (Mutable v (PrimState m) a)

-- | Generic construct implementation for array-based vectors.
constructVec :: forall v a. (Arity (Dim v), IVector v a) => Fun (Peano (Dim v)) a (v a)

-- | Generic inspect implementation for array-based vectors.
inspectVec :: forall v a b. (Arity (Dim v), IVector v a) => v a -> Fun (Peano (Dim v)) a b -> b


-- | Vector which could hold any value.
module Data.Vector.Fixed.Boxed

-- | Vector with fixed length which can hold any value.
data Vec (n :: Nat) a
type Vec1 = Vec 1
type Vec2 = Vec 2
type Vec3 = Vec 3
type Vec4 = Vec 4
type Vec5 = Vec 5

-- | Mutable unboxed vector with fixed length
data MVec (n :: Nat) s a
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Boxed.MVec n) a
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Boxed.Vec n) a
instance (Data.Typeable.Internal.Typeable n, Data.Vector.Fixed.Cont.Arity n, Data.Data.Data a) => Data.Data.Data (Data.Vector.Fixed.Boxed.Vec n a)
instance (Foreign.Storable.Storable a, Data.Vector.Fixed.Cont.Arity n) => Foreign.Storable.Storable (Data.Vector.Fixed.Boxed.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, GHC.Show.Show a) => GHC.Show.Show (Data.Vector.Fixed.Boxed.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Vector.Fixed.Boxed.Vec n a)
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Cont.Vector (Data.Vector.Fixed.Boxed.Vec n) a
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Cont.VectorN Data.Vector.Fixed.Boxed.Vec n a
instance (Data.Vector.Fixed.Cont.Arity n, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Fixed.Boxed.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Fixed.Boxed.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, GHC.Base.Monoid a) => GHC.Base.Monoid (Data.Vector.Fixed.Boxed.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Vector.Fixed.Boxed.Vec n a)
instance Data.Vector.Fixed.Cont.Arity n => GHC.Base.Functor (Data.Vector.Fixed.Boxed.Vec n)
instance Data.Vector.Fixed.Cont.Arity n => GHC.Base.Applicative (Data.Vector.Fixed.Boxed.Vec n)
instance Data.Vector.Fixed.Cont.Arity n => Data.Foldable.Foldable (Data.Vector.Fixed.Boxed.Vec n)
instance Data.Vector.Fixed.Cont.Arity n => Data.Traversable.Traversable (Data.Vector.Fixed.Boxed.Vec n)


-- | Unboxed vectors with fixed length. Vectors from
--   <a>Data.Vector.Fixed.Unboxed</a> provide more flexibility at no
--   performeance cost.
module Data.Vector.Fixed.Primitive

-- | Unboxed vector with fixed length
data Vec (n :: Nat) a
type Vec1 = Vec 1
type Vec2 = Vec 2
type Vec3 = Vec 3
type Vec4 = Vec 4
type Vec5 = Vec 5

-- | Mutable unboxed vector with fixed length
data MVec (n :: Nat) s a

-- | Class of types supporting primitive array operations. This includes
--   interfacing with GC-managed memory (functions suffixed with
--   <tt>ByteArray#</tt>) and interfacing with unmanaged memory (functions
--   suffixed with <tt>Addr#</tt>). Endianness is platform-dependent.
class Prim a
instance (Data.Vector.Fixed.Cont.Arity n, Data.Primitive.Types.Prim a) => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Primitive.MVec n) a
instance (Data.Vector.Fixed.Cont.Arity n, Data.Primitive.Types.Prim a) => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Primitive.Vec n) a
instance (Data.Vector.Fixed.Cont.Arity n, Data.Primitive.Types.Prim a, GHC.Show.Show a) => GHC.Show.Show (Data.Vector.Fixed.Primitive.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Data.Primitive.Types.Prim a, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Vector.Fixed.Primitive.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Data.Primitive.Types.Prim a) => Data.Vector.Fixed.Cont.Vector (Data.Vector.Fixed.Primitive.Vec n) a
instance (Data.Vector.Fixed.Cont.Arity n, Data.Primitive.Types.Prim a) => Data.Vector.Fixed.Cont.VectorN Data.Vector.Fixed.Primitive.Vec n a
instance (Data.Vector.Fixed.Cont.Arity n, Data.Primitive.Types.Prim a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Fixed.Primitive.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Data.Primitive.Types.Prim a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Fixed.Primitive.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Data.Primitive.Types.Prim a, GHC.Base.Monoid a) => GHC.Base.Monoid (Data.Vector.Fixed.Primitive.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Data.Primitive.Types.Prim a, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Vector.Fixed.Primitive.Vec n a)
instance (Data.Typeable.Internal.Typeable n, Data.Vector.Fixed.Cont.Arity n, Data.Primitive.Types.Prim a, Data.Data.Data a) => Data.Data.Data (Data.Vector.Fixed.Primitive.Vec n a)
instance (Foreign.Storable.Storable a, Data.Primitive.Types.Prim a, Data.Vector.Fixed.Cont.Arity n) => Foreign.Storable.Storable (Data.Vector.Fixed.Primitive.Vec n a)


-- | Storable-based unboxed vectors.
module Data.Vector.Fixed.Storable

-- | Storable-based vector with fixed length
data Vec (n :: Nat) a
type Vec1 = Vec 1
type Vec2 = Vec 2
type Vec3 = Vec 3
type Vec4 = Vec 4
type Vec5 = Vec 5

-- | Construct vector from foreign pointer.
unsafeFromForeignPtr :: ForeignPtr a -> Vec n a

-- | Get underlying pointer. Data may not be modified through pointer.
unsafeToForeignPtr :: Vec n a -> ForeignPtr a
unsafeWith :: (Ptr a -> IO b) -> Vec n a -> IO b

-- | Storable-based mutable vector with fixed length
newtype MVec (n :: Nat) s a
MVec :: ForeignPtr a -> MVec (n :: Nat) s a

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class Storable a
instance (Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a) => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Storable.MVec n) a
instance (Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a) => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Storable.Vec n) a
instance (Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a) => Foreign.Storable.Storable (Data.Vector.Fixed.Storable.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a, GHC.Show.Show a) => GHC.Show.Show (Data.Vector.Fixed.Storable.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Vector.Fixed.Storable.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a) => Data.Vector.Fixed.Cont.Vector (Data.Vector.Fixed.Storable.Vec n) a
instance (Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a) => Data.Vector.Fixed.Cont.VectorN Data.Vector.Fixed.Storable.Vec n a
instance (Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Fixed.Storable.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Fixed.Storable.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a, GHC.Base.Monoid a) => GHC.Base.Monoid (Data.Vector.Fixed.Storable.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Vector.Fixed.Storable.Vec n a)
instance (Data.Typeable.Internal.Typeable n, Data.Vector.Fixed.Cont.Arity n, Foreign.Storable.Storable a, Data.Data.Data a) => Data.Data.Data (Data.Vector.Fixed.Storable.Vec n a)


-- | Unboxed vectors with fixed length.
module Data.Vector.Fixed.Unboxed
data family Vec (n :: Nat) a
type Vec1 = Vec 1
type Vec2 = Vec 2
type Vec3 = Vec 3
type Vec4 = Vec 4
type Vec5 = Vec 5
data family MVec (n :: Nat) s a
class (Arity n, IVector (Vec n) a, MVector (MVec n) a) => Unbox n a
instance (Data.Vector.Fixed.Cont.Arity n, GHC.Show.Show a, Data.Vector.Fixed.Unboxed.Unbox n a) => GHC.Show.Show (Data.Vector.Fixed.Unboxed.Vec n a)
instance (Data.Vector.Fixed.Cont.Arity n, Data.Vector.Fixed.Unboxed.Unbox n a, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Vector.Fixed.Unboxed.Vec n a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Cont.Vector (Data.Vector.Fixed.Unboxed.Vec n) a
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Cont.VectorN Data.Vector.Fixed.Unboxed.Vec n a
instance (Data.Vector.Fixed.Unboxed.Unbox n a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Fixed.Unboxed.Vec n a)
instance (Data.Vector.Fixed.Unboxed.Unbox n a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Fixed.Unboxed.Vec n a)
instance (Data.Vector.Fixed.Unboxed.Unbox n a, GHC.Base.Monoid a) => GHC.Base.Monoid (Data.Vector.Fixed.Unboxed.Vec n a)
instance (Data.Vector.Fixed.Unboxed.Unbox n a, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Vector.Fixed.Unboxed.Vec n a)
instance (Data.Typeable.Internal.Typeable n, Data.Vector.Fixed.Unboxed.Unbox n a, Data.Data.Data a) => Data.Data.Data (Data.Vector.Fixed.Unboxed.Vec n a)
instance (Foreign.Storable.Storable a, Data.Vector.Fixed.Unboxed.Unbox n a) => Foreign.Storable.Storable (Data.Vector.Fixed.Unboxed.Vec n a)
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n ()
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Types.Bool
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Types.Int
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Int.Int8
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Int.Int16
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Int.Int32
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Int.Int64
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Types.Word
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Word.Word8
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Word.Word16
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Word.Word32
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Word.Word64
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Types.Char
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Types.Float
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n GHC.Types.Double
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Unboxed.Unbox n (Data.Complex.Complex a)
instance (Data.Vector.Fixed.Unboxed.Unbox n a, Data.Vector.Fixed.Unboxed.Unbox n b) => Data.Vector.Fixed.Unboxed.Unbox n (a, b)
instance (Data.Vector.Fixed.Unboxed.Unbox n a, Data.Vector.Fixed.Unboxed.Unbox n b, Data.Vector.Fixed.Unboxed.Unbox n c) => Data.Vector.Fixed.Unboxed.Unbox n (a, b, c)
instance forall k (n :: GHC.Types.Nat) a (b :: k). Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Unboxed.Unbox n (Data.Functor.Const.Const a b)
instance forall k (n :: GHC.Types.Nat) a (b :: k). Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) (Data.Functor.Const.Const a b)
instance forall k (n :: GHC.Types.Nat) a (b :: k). Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) (Data.Functor.Const.Const a b)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Unboxed.Unbox n (Data.Functor.Identity.Identity a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) (Data.Functor.Identity.Identity a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) (Data.Functor.Identity.Identity a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Unboxed.Unbox n (Data.Ord.Down a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) (Data.Ord.Down a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) (Data.Ord.Down a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Unboxed.Unbox n (Data.Semigroup.Internal.Dual a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) (Data.Semigroup.Internal.Dual a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) (Data.Semigroup.Internal.Dual a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Unboxed.Unbox n (Data.Semigroup.Internal.Sum a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) (Data.Semigroup.Internal.Sum a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) (Data.Semigroup.Internal.Sum a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Unboxed.Unbox n (Data.Semigroup.Internal.Product a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) (Data.Semigroup.Internal.Product a)
instance Data.Vector.Fixed.Unboxed.Unbox n a => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) (Data.Semigroup.Internal.Product a)
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n Data.Semigroup.Internal.Any
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Unboxed.Unbox n Data.Semigroup.Internal.All
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) ()
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) ()
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Types.Bool
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Types.Bool
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Types.Int
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Types.Int
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Int.Int8
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Int.Int8
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Int.Int16
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Int.Int16
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Int.Int32
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Int.Int32
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Int.Int64
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Int.Int64
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Types.Word
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Types.Word
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Word.Word8
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Word.Word8
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Word.Word16
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Word.Word16
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Word.Word32
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Word.Word32
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Word.Word64
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Word.Word64
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Types.Char
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Types.Char
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Types.Float
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Types.Float
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) GHC.Types.Double
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) GHC.Types.Double
instance (Data.Vector.Fixed.Cont.Arity n, Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) a) => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) (Data.Complex.Complex a)
instance (Data.Vector.Fixed.Cont.Arity n, Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) a) => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) (Data.Complex.Complex a)
instance (Data.Vector.Fixed.Cont.Arity n, Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) a, Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) b) => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) (a, b)
instance (Data.Vector.Fixed.Cont.Arity n, Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) a, Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) b) => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) (a, b)
instance (Data.Vector.Fixed.Cont.Arity n, Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) a, Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) b, Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) c) => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) (a, b, c)
instance (Data.Vector.Fixed.Cont.Arity n, Data.Vector.Fixed.Cont.Vector (Data.Vector.Fixed.Unboxed.Vec n) a, Data.Vector.Fixed.Cont.Vector (Data.Vector.Fixed.Unboxed.Vec n) b, Data.Vector.Fixed.Cont.Vector (Data.Vector.Fixed.Unboxed.Vec n) c, Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) a, Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) b, Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) c) => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) (a, b, c)
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) Data.Semigroup.Internal.Any
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) Data.Semigroup.Internal.Any
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.MVector (Data.Vector.Fixed.Unboxed.MVec n) Data.Semigroup.Internal.All
instance Data.Vector.Fixed.Cont.Arity n => Data.Vector.Fixed.Mutable.IVector (Data.Vector.Fixed.Unboxed.Vec n) Data.Semigroup.Internal.All
