-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | shell-like (systems) programming in Haskell
--   
--   Shelly provides convenient systems programming in Haskell, similar in
--   spirit to POSIX shells. Shelly:
--   
--   <ul>
--   <li>is aimed at convenience and getting things done rather than being
--   a demonstration of elegance.</li>
--   <li>has detailed and useful error messages</li>
--   <li>maintains its own environment, making it thread-safe.</li>
--   <li>is modern, using Text filepath/directory</li>
--   </ul>
--   
--   Shelly is originally forked from the Shellish package.
--   
--   See the shelly-extra package for additional functionality.
--   
--   An overview is available in the README:
--   <a>https://github.com/yesodweb/Shelly.hs/blob/master/README.md</a>
@package shelly
@version 1.9.0


-- | A module for shell-like programming in Haskell. Shelly's focus is
--   entirely on ease of use for those coming from shell scripting.
--   However, it also tries to use modern libraries and techniques to keep
--   things efficient.
--   
--   The functionality provided by this module is (unlike standard Haskell
--   filesystem functionality) thread-safe: each Sh maintains its own
--   environment and its own working directory.
--   
--   Recommended usage includes putting the following at the top of your
--   program, otherwise you will likely need either type annotations or
--   type conversions
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE ExtendedDefaultRules #-}
--   {-# OPTIONS_GHC -fno-warn-type-defaults #-}
--   import Shelly
--   import qualified Data.Text as T
--   default (T.Text)
--   </pre>
module Shelly
data Sh a

-- | ShIO is Deprecated in favor of <a>Sh</a>, which is easier to type.

-- | <i>Deprecated: Use Sh instead of ShIO</i>
type ShIO a = Sh a

-- | Enter a Sh from (Monad)IO. The environment and working directories are
--   inherited from the current process-wide values. Any subsequent changes
--   in processwide working directory or environment are not reflected in
--   the running Sh.
shelly :: MonadIO m => Sh a -> m a

-- | Deprecated now, just use <a>shelly</a>, whose default has been
--   changed. Using this entry point does not create a <tt>.shelly</tt>
--   directory in the case of failure. Instead it logs directly into the
--   standard error stream (<tt>stderr</tt>).

-- | <i>Deprecated: Just use shelly. The default settings have changed</i>
shellyNoDir :: MonadIO m => Sh a -> m a

-- | Using this entry point creates a <tt>.shelly</tt> directory in the
--   case of failure where errors are recorded.
shellyFailDir :: MonadIO m => Sh a -> m a

-- | spawn an asynchronous action with a copy of the current state
asyncSh :: Sh a -> Sh (Async a)

-- | Enter a sub-Sh that inherits the environment The original state will
--   be restored when the sub-Sh completes. Exceptions are propagated
--   normally.
sub :: Sh a -> Sh a

-- | Create a sub-Sh in which external command outputs are not echoed and
--   commands are not printed. See <a>sub</a>.
silently :: Sh a -> Sh a

-- | Create a sub-Sh in which external command outputs are echoed and
--   Executed commands are printed See <a>sub</a>.
verbosely :: Sh a -> Sh a

-- | Create a sub-Sh with shell character escaping on or off. Defaults to
--   <tt>True</tt>.
--   
--   Setting to <tt>False</tt> allows for shell wildcard such as * to be
--   expanded by the shell along with any other special shell characters.
--   As a side-effect, setting to <tt>False</tt> causes changes to
--   <tt>PATH</tt> to be ignored: see the <a>run</a> documentation.
escaping :: Bool -> Sh a -> Sh a

-- | Create a sub-Sh with stdout printing on or off Defaults to True.
print_stdout :: Bool -> Sh a -> Sh a

-- | Create a sub-Sh with stderr printing on or off Defaults to True.
print_stderr :: Bool -> Sh a -> Sh a

-- | Create a sub-Sh with command echoing on or off Defaults to False, set
--   to True by <a>verbosely</a>
print_commands :: Bool -> Sh a -> Sh a

-- | When running an external command, apply the given initializers to the
--   specified handles for that command. This can for example be used to
--   change the encoding of the handles or set them into binary mode.
onCommandHandles :: StdInit -> Sh a -> Sh a

-- | Create a sub-Sh where commands are not traced Defaults to True. You
--   should only set to False temporarily for very specific reasons
tracing :: Bool -> Sh a -> Sh a

-- | named after bash -e errexit. Defaults to <tt>True</tt>. When
--   <tt>True</tt>, throw an exception on a non-zero exit code. When
--   <tt>False</tt>, ignore a non-zero exit code. Not recommended to set to
--   <tt>False</tt> unless you are specifically checking the error code
--   with <a>lastExitCode</a>.
errExit :: Bool -> Sh a -> Sh a

-- | Create a sub-Sh in which stdout is sent to the user-defined logger.
--   When running with <a>silently</a> the given log will not be called for
--   any output. Likewise the log will also not be called for output from
--   <a>run_</a> and <a>bash_</a> commands.
log_stdout_with :: (Text -> IO ()) -> Sh a -> Sh a

-- | Create a sub-Sh in which stderr is sent to the user-defined logger.
--   When running with <a>silently</a> the given log will not be called for
--   any output. However, unlike <a>log_stdout_with</a> the log will be
--   called for output from <a>run_</a> and <a>bash_</a> commands.
log_stderr_with :: (Text -> IO ()) -> Sh a -> Sh a

-- | Execute an external command. Takes the command name and arguments.
--   
--   You may prefer using <a>cmd</a> instead, which is a variadic argument
--   version of this function.
--   
--   <a>stdout</a> and <a>stderr</a> are collected. The <a>stdout</a> is
--   returned as a result of <a>run</a>, and complete stderr output is
--   available after the fact using <a>lastStderr</a>
--   
--   All of the stdout output will be loaded into memory. You can avoid
--   this if you don't need stdout by using <a>run_</a>, If you want to
--   avoid the memory and need to process the output then use
--   <a>runFoldLines</a> or <a>runHandle</a> or <a>runHandles</a>.
--   
--   By default shell characters are escaped and the command name is a name
--   of a program that can be found via <tt>PATH</tt>. Shelly will look
--   through the <tt>PATH</tt> itself to find the command.
--   
--   When <a>escaping</a> is set to <tt>False</tt>, shell characters are
--   allowed. Since there is no longer a guarantee that a single program
--   name is given, Shelly cannot look in the <tt>PATH</tt> for it. a
--   <tt>PATH</tt> modified by setenv is not taken into account when
--   finding the exe name. Instead the original Haskell program
--   <tt>PATH</tt> is used. On a Posix system the <tt>env</tt> command can
--   be used to make the <a>setenv</a> PATH used when <a>escaping</a> is
--   set to False. <tt>env echo hello</tt> instead of <tt>echo hello</tt>
run :: FilePath -> [Text] -> Sh Text

-- | the same as <a>run</a>, but return <tt>()</tt> instead of the stdout
--   content stdout will be read and discarded line-by-line
run_ :: FilePath -> [Text] -> Sh ()

-- | used by <a>run</a>. fold over stdout line-by-line as it is read to
--   avoid keeping it in memory stderr is still being placed in memory
--   under the assumption it is always relatively small
runFoldLines :: a -> FoldCallback a -> FilePath -> [Text] -> Sh a

-- | variadic argument version of <a>run</a>. Please see the documenation
--   for <a>run</a>.
--   
--   The syntax is more convenient, but more importantly it also allows the
--   use of a FilePath as a command argument. So an argument can be a Text
--   or a FilePath without manual conversions. a FilePath is automatically
--   converted to Text with <a>toTextIgnore</a>.
--   
--   Convenient usage of <a>cmd</a> requires the following:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE ExtendedDefaultRules #-}
--   {-# OPTIONS_GHC -fno-warn-type-defaults #-}
--   import Shelly
--   import qualified Data.Text as T
--   default (T.Text)
--   </pre>
cmd :: ShellCmd result => FilePath -> result
type FoldCallback a = (a -> Text -> a)

-- | Like <a>run</a>, but it invokes the user-requested program with
--   _bash_.
bash :: FilePath -> [Text] -> Sh Text
bash_ :: FilePath -> [Text] -> Sh ()

-- | Use this with <a>bash</a> to set _pipefail_
--   
--   <pre>
--   bashPipeFail $ bash "echo foo | echo"
--   </pre>
bashPipeFail :: (FilePath -> [Text] -> Sh a) -> FilePath -> [Text] -> Sh a

-- | Pipe operator. set the stdout the first command as the stdin of the
--   second. This does not create a shell-level pipe, but hopefully it will
--   in the future. To create a shell level pipe you can set <tt>escaping
--   False</tt> and use a pipe <tt>|</tt> character in a command.
(-|-) :: Sh Text -> Sh b -> Sh b

-- | The output of last external command. See <a>run</a>.
lastStderr :: Sh Text

-- | set the stdin to be used and cleared by the next <a>run</a>.
setStdin :: Text -> Sh ()

-- | The exit code from the last command. Unless you set <a>errExit</a> to
--   False you won't get a chance to use this: a non-zero exit code will
--   throw an exception.
lastExitCode :: Sh Int

-- | bind some arguments to <a>run</a> for re-use. Example:
--   
--   <pre>
--   monit = command "monit" ["-c", "monitrc"]
--   monit ["stop", "program"]
--   </pre>
command :: FilePath -> [Text] -> [Text] -> Sh Text

-- | bind some arguments to <a>run_</a> for re-use. Example:
--   
--   <pre>
--   monit_ = command_ "monit" ["-c", "monitrc"]
--   monit_ ["stop", "program"]
--   </pre>
command_ :: FilePath -> [Text] -> [Text] -> Sh ()

-- | bind some arguments to <a>run</a> for re-use, and require 1 argument.
--   Example:
--   
--   <pre>
--   git = command1 "git" []
--   git "pull" ["origin", "master"]
--   </pre>
command1 :: FilePath -> [Text] -> Text -> [Text] -> Sh Text

-- | bind some arguments to <a>run_</a> for re-use, and require 1 argument.
--   Example:
--   
--   <pre>
--   git_ = command1_ "git" []
--   git "pull" ["origin", "master"]
--   </pre>
command1_ :: FilePath -> [Text] -> Text -> [Text] -> Sh ()

-- | run commands over SSH. An ssh executable is expected in your path.
--   Commands are in the same form as <a>run</a>, but given as pairs
--   
--   <pre>
--   sshPairs "server-name" [("cd", "dir"), ("rm",["-r","dir2"])]
--   </pre>
--   
--   This interface is crude, but it works for now.
--   
--   Please note this sets <a>escaping</a> to False, and the remote
--   commands are quoted with single quotes, in a way such that the remote
--   commands will see the literal values you passed, this means that no
--   variable expansion and alike will done on either the local shell or
--   the remote shell, and that if there are a single or double quotes in
--   your arguments, they need not to be quoted manually.
--   
--   Internally the list of commands are combined with the string
--   <tt>&amp;&amp;</tt> before given to ssh.
sshPairs :: Text -> [(FilePath, [Text])] -> Sh Text

-- | Same as sshPairs, but combines commands with the string
--   <tt>&amp;</tt>, so they will be started in parallell.
sshPairsPar :: Text -> [(FilePath, [Text])] -> Sh Text

-- | same as <a>sshPairs</a>, but returns ()
sshPairs_ :: Text -> [(FilePath, [Text])] -> Sh ()

-- | same as <tt>sshPairsP</tt>, but returns ()
sshPairsPar_ :: Text -> [(FilePath, [Text])] -> Sh ()

-- | Like <a>sshPairs</a>, but allows for arguments to the call to ssh.
sshPairsWithOptions :: Text -> [Text] -> [(FilePath, [Text])] -> Sh Text
sshCommandText :: [(FilePath, [Text])] -> SshMode -> Text
data SshMode
ParSsh :: SshMode
SeqSsh :: SshMode

-- | For the variadic function <a>cmd</a>
--   
--   partially applied variadic functions require type signatures
class ShellCmd t
cmdAll :: ShellCmd t => FilePath -> [Text] -> t

-- | Argument converter for the variadic argument version of <a>run</a>
--   called <a>cmd</a>. Useful for a type signature of a function that uses
--   <a>cmd</a>
class CmdArg a
toTextArg :: CmdArg a => a -> Text

-- | Similar to <a>run</a> but gives the raw stdout handle in a callback.
--   If you want even more control, use <a>runHandles</a>.
runHandle :: FilePath -> [Text] -> (Handle -> Sh a) -> Sh a

-- | Similar to <a>run</a> but gives direct access to all input and output
--   handles.
--   
--   Be careful when using the optional input handles. If you specify
--   Inherit for a handle then attempting to access the handle in your
--   callback is an error
runHandles :: FilePath -> [Text] -> [StdHandle] -> (Handle -> Handle -> Handle -> Sh a) -> Sh a

-- | Transfer from one handle to another For example, send contents of a
--   process output to stdout. does not close the write handle.
--   
--   Also, return the complete contents being streamed line by line.
transferLinesAndCombine :: Handle -> (Text -> IO ()) -> IO Text

-- | Transfer from one handle to another For example, send contents of a
--   process output to stdout. does not close the write handle.
--   
--   Also, fold over the contents being streamed line by line
transferFoldHandleLines :: a -> FoldCallback a -> Handle -> (Text -> IO ()) -> IO a
data StdHandle
InHandle :: StdStream -> StdHandle
OutHandle :: StdStream -> StdHandle
ErrorHandle :: StdStream -> StdHandle
data StdStream

-- | Inherit Handle from parent
Inherit :: StdStream

-- | Use the supplied Handle
UseHandle :: Handle -> StdStream

-- | Create a new pipe. The returned <tt>Handle</tt> will use the default
--   encoding and newline translation mode (just like <tt>Handle</tt>s
--   created by <tt>openFile</tt>).
CreatePipe :: StdStream

-- | Close the stream's file descriptor without passing a Handle. On POSIX
--   systems this may lead to strange behavior in the child process because
--   attempting to read or write after the file has been closed throws an
--   error. This should only be used with child processes that don't use
--   the file descriptor at all. If you wish to ignore the child process's
--   output you should either create a pipe and drain it manually or pass a
--   <tt>Handle</tt> that writes to <tt>/dev/null</tt>.
NoStream :: StdStream

-- | Initialize a handle before using it
type HandleInitializer = Handle -> IO ()

-- | A collection of initializers for the three standard process handles
data StdInit
StdInit :: HandleInitializer -> HandleInitializer -> HandleInitializer -> StdInit
[inInit] :: StdInit -> HandleInitializer
[outInit] :: StdInit -> HandleInitializer
[errInit] :: StdInit -> HandleInitializer

-- | Apply a single initializer to the two output process handles (stdout
--   and stderr)
initOutputHandles :: HandleInitializer -> StdInit

-- | Apply a single initializer to all three standard process handles
--   (stdin, stdout and stderr)
initAllHandles :: HandleInitializer -> StdInit

-- | Set an environment variable. The environment is maintained in Sh
--   internally, and is passed to any external commands to be executed.
setenv :: Text -> Text -> Sh ()

-- | Fetch the current value of an environment variable. if non-existant or
--   empty text, will be Nothing
get_env :: Text -> Sh (Maybe Text)

-- | Fetch the current value of an environment variable. Both empty and
--   non-existent variables give empty string as a result.
get_env_text :: Text -> Sh Text

-- | deprecated

-- | <i>Deprecated: use get_env or get_env_text</i>
getenv :: Text -> Sh Text

-- | Fetch the current value of an environment variable. Both empty and
--   non-existent variables give the default Text value as a result

-- | <i>Deprecated: use fromMaybe DEFAULT get_env</i>
get_env_def :: Text -> Text -> Sh Text

-- | get the full environment
get_env_all :: Sh [(String, String)]

-- | <i>Deprecated: use get_env_all</i>
get_environment :: Sh [(String, String)]

-- | add the filepath onto the PATH env variable
appendToPath :: FilePath -> Sh ()

-- | prepend the filepath to the PATH env variable similar to
--   <a>appendToPath</a> but gives high priority to the filepath instead of
--   low priority.
prependToPath :: FilePath -> Sh ()

-- | Change current working directory of Sh. This does *not* change the
--   working directory of the process we are running it. Instead, Sh keeps
--   track of its own working directory and builds absolute paths
--   internally instead of passing down relative paths.
cd :: FilePath -> Sh ()

-- | <a>cd</a>, execute a Sh action in the new directory and then pop back
--   to the original directory
chdir :: FilePath -> Sh a -> Sh a

-- | <a>chdir</a>, but first create the directory if it does not exit
chdir_p :: FilePath -> Sh a -> Sh a

-- | Obtain the current (Sh) working directory.
pwd :: Sh FilePath

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_n :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_err :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_n_err :: Text -> Sh ()

-- | a print lifted into <a>Sh</a>
inspect :: Show s => s -> Sh ()

-- | a print lifted into <a>Sh</a> using stderr
inspect_err :: Show s => s -> Sh ()

-- | same as <a>trace</a>, but use it combinator style
tag :: Sh a -> Text -> Sh a

-- | internally log what occurred. Log will be re-played on failure.
trace :: Text -> Sh ()
show_command :: FilePath -> [Text] -> Text

-- | List directory contents. Does *not* include "." and "..", but it does
--   include (other) hidden files.
ls :: FilePath -> Sh [FilePath]

-- | Get back [Text] instead of [FilePath]
lsT :: FilePath -> Sh [Text]

-- | Does a path point to an existing filesystem object?
test_e :: FilePath -> Sh Bool

-- | Does a path point to an existing file?
test_f :: FilePath -> Sh Bool

-- | Does a path point to an existing directory?
test_d :: FilePath -> Sh Bool

-- | Does a path point to a symlink?
test_s :: FilePath -> Sh Bool

-- | Test that a file is in the PATH and also executable
test_px :: FilePath -> Sh Bool

-- | Get a full path to an executable by looking at the <tt>PATH</tt>
--   environement variable. Windows normally looks in additional places
--   besides the <tt>PATH</tt>: this does not duplicate that behavior.
which :: FilePath -> Sh (Maybe FilePath)

-- | Make a relative path absolute by combining with the working directory.
--   An absolute path is returned as is. To create a relative path, use
--   <a>relPath</a>.
absPath :: FilePath -> Sh FilePath

-- | uses System.FilePath, but can automatically convert a Text
(</>) :: (ToFilePath filepath1, ToFilePath filepath2) => filepath1 -> filepath2 -> FilePath

-- | uses System.FilePath, but can automatically convert a Text
(<.>) :: ToFilePath filepath => filepath -> Text -> FilePath

-- | makes an absolute path. Like <a>canonicalize</a>, but on an exception
--   returns <a>absPath</a>
canonic :: FilePath -> Sh FilePath

-- | Obtain a (reasonably) canonic file path to a filesystem object. Based
--   on "canonicalizePath" in system-fileio.
canonicalize :: FilePath -> Sh FilePath

-- | Makes a relative path relative to the current Sh working directory. An
--   absolute path is returned as is. To create an absolute path, use
--   <a>absPath</a>
relPath :: FilePath -> Sh FilePath

-- | make the second path relative to the first Uses <a>stripPrefix</a>,
--   but will canonicalize the paths if necessary
relativeTo :: FilePath -> FilePath -> Sh FilePath

-- | deprecated

-- | <i>Deprecated: use absPath, canonic, or relPath instead</i>
path :: FilePath -> Sh FilePath

-- | flipped hasExtension for Text
hasExt :: Text -> FilePath -> Bool

-- | Move a file. The second path could be a directory, in which case the
--   original file is moved into that directory. wraps directory
--   <a>renameFile</a>, which may not work across FS boundaries
mv :: FilePath -> FilePath -> Sh ()

-- | Remove a file. Does fail if the file does not exist (use <a>rm_f</a>
--   instead) or is not a file.
rm :: FilePath -> Sh ()

-- | Remove a file. Does not fail if the file does not exist. Does fail if
--   the file is not a file.
rm_f :: FilePath -> Sh ()

-- | A swiss army cannon for removing things. Actually this goes farther
--   than a normal rm -rf, as it will circumvent permission problems for
--   the files we own. Use carefully. Uses <a>removeDirectoryRecursive</a>
rm_rf :: FilePath -> Sh ()

-- | Copy a file. The second path could be a directory, in which case the
--   original file name is used, in that directory.
cp :: FilePath -> FilePath -> Sh ()

-- | Copy a file, or a directory recursively. uses <a>cp</a>
cp_r :: FilePath -> FilePath -> Sh ()

-- | Create a new directory (fails if the directory exists).
mkdir :: FilePath -> Sh ()

-- | Create a new directory, including parents (succeeds if the directory
--   already exists).
mkdir_p :: FilePath -> Sh ()

-- | Create a new directory tree. You can describe a bunch of directories
--   as a tree and this function will create all subdirectories. An
--   example:
--   
--   <pre>
--   exec = mkTree $
--             "package" # [
--                  "src" # [
--                      "Data" # leaves ["Tree", "List", "Set", "Map"]
--                  ],
--                  "test" # leaves ["QuickCheck", "HUnit"],
--                  "dist/doc/html" # []
--              ]
--           where (#) = Node
--                 leaves = map (# [])
--   </pre>
mkdirTree :: Tree FilePath -> Sh ()
readfile :: FilePath -> Sh Text

-- | wraps ByteSting readFile
readBinary :: FilePath -> Sh ByteString

-- | Write a Text to a file.
writefile :: FilePath -> Text -> Sh ()
writeBinary :: FilePath -> ByteString -> Sh ()

-- | Append a Text to a file.
appendfile :: FilePath -> Text -> Sh ()

-- | Update a file, creating (a blank file) if it does not exist.
touchfile :: FilePath -> Sh ()

-- | Create a temporary directory and pass it as a parameter to a Sh
--   computation. The directory is nuked afterwards.
withTmpDir :: (FilePath -> Sh a) -> Sh a

-- | exit 0 means no errors, all other codes are error conditions
exit :: Int -> Sh a

-- | echo a message and exit with status 1
errorExit :: Text -> Sh a

-- | for exiting with status &gt; 0 without printing debug information
quietExit :: Int -> Sh a

-- | fail that takes a Text
terror :: Text -> Sh a
bracket_sh :: Sh a -> (a -> Sh b) -> (a -> Sh c) -> Sh c

-- | A helper to catch any exception (same as <tt>... <a>catch</a> (e ::
--   SomeException) -&gt; ...</tt>).
catchany :: IO a -> (SomeException -> IO a) -> IO a

-- | Same as a normal <a>catch</a> but specialized for the Sh monad.
catch_sh :: Exception e => Sh a -> (e -> Sh a) -> Sh a

-- | Same as a normal <a>handle</a> but specialized for the Sh monad.
handle_sh :: Exception e => (e -> Sh a) -> Sh a -> Sh a

-- | Handle any exception in the Sh monad.
handleany_sh :: (SomeException -> Sh a) -> Sh a -> Sh a

-- | Same as a normal <a>finally</a> but specialized for the <a>Sh</a>
--   monad.
finally_sh :: Sh a -> Sh b -> Sh a

-- | You need to wrap exception handlers with this when using
--   <a>catches_sh</a>.
data ShellyHandler a
ShellyHandler :: (e -> Sh a) -> ShellyHandler a

-- | Same as a normal <a>catches</a>, but specialized for the <a>Sh</a>
--   monad.
catches_sh :: Sh a -> [ShellyHandler a] -> Sh a

-- | Catch any exception in the Sh monad.
catchany_sh :: Sh a -> (SomeException -> Sh a) -> Sh a

-- | Shelly's wrapper around exceptions thrown in its monad
data ReThrownException e
ReThrownException :: e -> String -> ReThrownException e
data RunFailed
RunFailed :: FilePath -> [Text] -> Int -> Text -> RunFailed

-- | silently uses the Right or Left value of
--   "Filesystem.Path.CurrentOS.toText"
toTextIgnore :: FilePath -> Text
toTextWarn :: FilePath -> Sh Text

-- | Convert Text to a FilePath-
fromText :: Text -> FilePath

-- | A monadic-conditional version of the "when" guard.
whenM :: Monad m => m Bool -> m () -> m ()

-- | A monadic-conditional version of the <a>unless</a> guard.
unlessM :: Monad m => m Bool -> m () -> m ()

-- | Run a Sh computation and collect timing information. The value
--   returned is the amount of _real_ time spent running the computation in
--   seconds, as measured by the system clock. The precision is determined
--   by the resolution of <a>getCurrentTime</a>.
time :: Sh a -> Sh (Double, a)

-- | threadDelay wrapper that uses seconds
sleep :: Int -> Sh ()

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>
get :: Sh State
put :: State -> Sh ()

-- | List directory recursively (like the POSIX utility "find"). listing is
--   relative if the path given is relative. If you want to filter out some
--   results or fold over them you can do that with the returned files. A
--   more efficient approach is to use one of the other find functions.
find :: FilePath -> Sh [FilePath]

-- | <a>find</a> that filters the found files as it finds. Files must
--   satisfy the given filter to be returned in the result.
findWhen :: (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | Fold an arbitrary folding function over files froma a <a>find</a>.
--   Like <a>findWhen</a> but use a more general fold rather than a filter.
findFold :: (a -> FilePath -> Sh a) -> a -> FilePath -> Sh a

-- | <a>find</a> that filters out directories as it finds Filtering out
--   directories can make a find much more efficient by avoiding entire
--   trees of files.
findDirFilter :: (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | similar <a>findWhen</a>, but also filter out directories
--   Alternatively, similar to <a>findDirFilter</a>, but also filter out
--   files Filtering out directories makes the find much more efficient
findDirFilterWhen :: (FilePath -> Sh Bool) -> (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | like <a>findDirFilterWhen</a> but use a folding function rather than a
--   filter The most general finder: you likely want a more specific one
findFoldDirFilter :: (a -> FilePath -> Sh a) -> a -> (FilePath -> Sh Bool) -> FilePath -> Sh a

-- | <a>find</a>-command follows symbolic links. Defaults to
--   <tt>False</tt>. When <tt>True</tt>, follow symbolic links. When
--   <tt>False</tt>, never follow symbolic links.
followSymlink :: Bool -> Sh a -> Sh a
instance GHC.Show.Show Shelly.QuietExit
instance GHC.Exception.Type.Exception e => GHC.Exception.Type.Exception (Shelly.ReThrownException e)
instance GHC.Exception.Type.Exception e => GHC.Show.Show (Shelly.ReThrownException e)
instance GHC.Exception.Type.Exception Shelly.QuietExit
instance GHC.Show.Show Shelly.RunFailed
instance GHC.Exception.Type.Exception Shelly.RunFailed
instance Shelly.ToFilePath GHC.IO.FilePath
instance Shelly.ToFilePath Data.Text.Internal.Text
instance Shelly.ShellCmd (Shelly.Base.Sh Data.Text.Internal.Text)
instance (s GHC.Types.~ Data.Text.Internal.Text, GHC.Show.Show s) => Shelly.ShellCmd (Shelly.Base.Sh s)
instance Shelly.ShellCmd (Shelly.Base.Sh ())
instance (Shelly.CmdArg arg, Shelly.ShellCmd result) => Shelly.ShellCmd (arg -> result)
instance (Shelly.CmdArg arg, Shelly.ShellCmd result) => Shelly.ShellCmd ([arg] -> result)
instance Shelly.CmdArg Data.Text.Internal.Text
instance Shelly.CmdArg GHC.Base.String


-- | A module for shell-like programming in Haskell. Shelly's focus is
--   entirely on ease of use for those coming from shell scripting.
--   However, it also tries to use modern libraries and techniques to keep
--   things efficient.
--   
--   The functionality provided by this module is (unlike standard Haskell
--   filesystem functionality) thread-safe: each Sh maintains its own
--   environment and its own working directory.
--   
--   Recommended usage includes putting the following at the top of your
--   program, otherwise you will likely need either type annotations or
--   type conversions
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE ExtendedDefaultRules #-}
--   {-# OPTIONS_GHC -fno-warn-type-defaults #-}
--   import Shelly
--   import qualified Data.Text as T
--   default (T.Text)
--   </pre>
module Shelly.Lifted
class Monad m => MonadSh m
liftSh :: MonadSh m => Sh a -> m a
class Monad m => MonadShControl m where {
    data family ShM m a :: *;
}
liftShWith :: MonadShControl m => ((forall x. m x -> Sh (ShM m x)) -> Sh a) -> m a
restoreSh :: MonadShControl m => ShM m a -> m a
data Sh a

-- | ShIO is Deprecated in favor of <a>Sh</a>, which is easier to type.

-- | <i>Deprecated: Use Sh instead of ShIO</i>
type ShIO a = Sh a

-- | Enter a Sh from (Monad)IO. The environment and working directories are
--   inherited from the current process-wide values. Any subsequent changes
--   in processwide working directory or environment are not reflected in
--   the running Sh.
shelly :: MonadIO m => Sh a -> m a

-- | Deprecated now, just use <a>shelly</a>, whose default has been
--   changed. Using this entry point does not create a <tt>.shelly</tt>
--   directory in the case of failure. Instead it logs directly into the
--   standard error stream (<tt>stderr</tt>).

-- | <i>Deprecated: Just use shelly. The default settings have changed</i>
shellyNoDir :: MonadIO m => Sh a -> m a

-- | Using this entry point creates a <tt>.shelly</tt> directory in the
--   case of failure where errors are recorded.
shellyFailDir :: MonadIO m => Sh a -> m a
sub :: MonadShControl m => m a -> m a
silently :: MonadShControl m => m a -> m a
verbosely :: MonadShControl m => m a -> m a
escaping :: MonadShControl m => Bool -> m a -> m a
print_stdout :: MonadShControl m => Bool -> m a -> m a
print_stderr :: MonadShControl m => Bool -> m a -> m a
print_commands :: MonadShControl m => Bool -> m a -> m a
tracing :: MonadShControl m => Bool -> m a -> m a
errExit :: MonadShControl m => Bool -> m a -> m a
log_stdout_with :: MonadShControl m => (Text -> IO ()) -> m a -> m a
log_stderr_with :: MonadShControl m => (Text -> IO ()) -> m a -> m a
run :: MonadSh m => FilePath -> [Text] -> m Text
run_ :: MonadSh m => FilePath -> [Text] -> m ()
runFoldLines :: MonadSh m => a -> FoldCallback a -> FilePath -> [Text] -> m a

-- | variadic argument version of <a>run</a>. Please see the documenation
--   for <a>run</a>.
--   
--   The syntax is more convenient, but more importantly it also allows the
--   use of a FilePath as a command argument. So an argument can be a Text
--   or a FilePath without manual conversions. a FilePath is automatically
--   converted to Text with <a>toTextIgnore</a>.
--   
--   Convenient usage of <a>cmd</a> requires the following:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE ExtendedDefaultRules #-}
--   {-# OPTIONS_GHC -fno-warn-type-defaults #-}
--   import Shelly
--   import qualified Data.Text as T
--   default (T.Text)
--   </pre>
cmd :: ShellCmd result => FilePath -> result
type FoldCallback a = (a -> Text -> a)
(-|-) :: (MonadShControl m, MonadSh m) => m Text -> m b -> m b
lastStderr :: MonadSh m => m Text
setStdin :: MonadSh m => Text -> m ()
lastExitCode :: MonadSh m => m Int
command :: MonadSh m => FilePath -> [Text] -> [Text] -> m Text
command_ :: MonadSh m => FilePath -> [Text] -> [Text] -> m ()
command1 :: MonadSh m => FilePath -> [Text] -> Text -> [Text] -> m Text
command1_ :: MonadSh m => FilePath -> [Text] -> Text -> [Text] -> m ()
sshPairs :: MonadSh m => Text -> [(FilePath, [Text])] -> m Text
sshPairs_ :: MonadSh m => Text -> [(FilePath, [Text])] -> m ()

-- | For the variadic function <a>cmd</a>
--   
--   partially applied variadic functions require type signatures
class ShellCmd t
cmdAll :: ShellCmd t => FilePath -> [Text] -> t

-- | Argument converter for the variadic argument version of <a>run</a>
--   called <a>cmd</a>. Useful for a type signature of a function that uses
--   <a>cmd</a>
class CmdArg a
toTextArg :: CmdArg a => a -> Text
runHandle :: MonadShControl m => FilePath -> [Text] -> (Handle -> m a) -> m a
runHandles :: MonadShControl m => FilePath -> [Text] -> [StdHandle] -> (Handle -> Handle -> Handle -> m a) -> m a
transferLinesAndCombine :: MonadIO m => Handle -> (Text -> IO ()) -> m Text

-- | Transfer from one handle to another For example, send contents of a
--   process output to stdout. does not close the write handle.
--   
--   Also, fold over the contents being streamed line by line
transferFoldHandleLines :: a -> FoldCallback a -> Handle -> (Text -> IO ()) -> IO a
data StdHandle
InHandle :: StdStream -> StdHandle
OutHandle :: StdStream -> StdHandle
ErrorHandle :: StdStream -> StdHandle
data StdStream

-- | Inherit Handle from parent
Inherit :: StdStream

-- | Use the supplied Handle
UseHandle :: Handle -> StdStream

-- | Create a new pipe. The returned <tt>Handle</tt> will use the default
--   encoding and newline translation mode (just like <tt>Handle</tt>s
--   created by <tt>openFile</tt>).
CreatePipe :: StdStream

-- | Close the stream's file descriptor without passing a Handle. On POSIX
--   systems this may lead to strange behavior in the child process because
--   attempting to read or write after the file has been closed throws an
--   error. This should only be used with child processes that don't use
--   the file descriptor at all. If you wish to ignore the child process's
--   output you should either create a pipe and drain it manually or pass a
--   <tt>Handle</tt> that writes to <tt>/dev/null</tt>.
NoStream :: StdStream
setenv :: MonadSh m => Text -> Text -> m ()
get_env :: MonadSh m => Text -> m (Maybe Text)
get_env_text :: MonadSh m => Text -> m Text
get_env_all :: MonadSh m => m [(String, String)]
appendToPath :: MonadSh m => FilePath -> m ()
prependToPath :: MonadSh m => FilePath -> m ()
cd :: MonadSh m => FilePath -> m ()
chdir :: MonadShControl m => FilePath -> m a -> m a
chdir_p :: MonadShControl m => FilePath -> m a -> m a
pwd :: MonadSh m => m FilePath
echo :: MonadSh m => Text -> m ()
echo_n :: MonadSh m => Text -> m ()
echo_err :: MonadSh m => Text -> m ()
echo_n_err :: MonadSh m => Text -> m ()
inspect :: (Show s, MonadSh m) => s -> m ()
inspect_err :: (Show s, MonadSh m) => s -> m ()
tag :: (MonadShControl m, MonadSh m) => m a -> Text -> m a
trace :: MonadSh m => Text -> m ()
show_command :: FilePath -> [Text] -> Text
ls :: MonadSh m => FilePath -> m [FilePath]
lsT :: MonadSh m => FilePath -> m [Text]
test_e :: MonadSh m => FilePath -> m Bool
test_f :: MonadSh m => FilePath -> m Bool
test_d :: MonadSh m => FilePath -> m Bool
test_s :: MonadSh m => FilePath -> m Bool
test_px :: MonadSh m => FilePath -> m Bool
which :: MonadSh m => FilePath -> m (Maybe FilePath)
absPath :: MonadSh m => FilePath -> m FilePath

-- | uses System.FilePath, but can automatically convert a Text
(</>) :: (ToFilePath filepath1, ToFilePath filepath2) => filepath1 -> filepath2 -> FilePath

-- | uses System.FilePath, but can automatically convert a Text
(<.>) :: ToFilePath filepath => filepath -> Text -> FilePath
canonic :: MonadSh m => FilePath -> m FilePath

-- | Obtain a (reasonably) canonic file path to a filesystem object. Based
--   on "canonicalizePath" in system-fileio.
canonicalize :: MonadSh m => FilePath -> m FilePath
relPath :: MonadSh m => FilePath -> m FilePath
relativeTo :: MonadSh m => FilePath -> FilePath -> m FilePath

-- | flipped hasExtension for Text
hasExt :: Text -> FilePath -> Bool
mv :: MonadSh m => FilePath -> FilePath -> m ()
rm :: MonadSh m => FilePath -> m ()
rm_f :: MonadSh m => FilePath -> m ()
rm_rf :: MonadSh m => FilePath -> m ()
cp :: MonadSh m => FilePath -> FilePath -> m ()
cp_r :: MonadSh m => FilePath -> FilePath -> m ()
mkdir :: MonadSh m => FilePath -> m ()
mkdir_p :: MonadSh m => FilePath -> m ()
mkdirTree :: MonadSh m => Tree FilePath -> m ()
readfile :: MonadSh m => FilePath -> m Text
readBinary :: MonadSh m => FilePath -> m ByteString
writefile :: MonadSh m => FilePath -> Text -> m ()
appendfile :: MonadSh m => FilePath -> Text -> m ()
touchfile :: MonadSh m => FilePath -> m ()
withTmpDir :: MonadShControl m => (FilePath -> m a) -> m a
exit :: MonadSh m => Int -> m a
errorExit :: MonadSh m => Text -> m a
quietExit :: MonadSh m => Int -> m a
terror :: MonadSh m => Text -> m a

-- | <i>Deprecated: use Control.Exception.Lifted.bracket instead</i>
bracket_sh :: Sh a -> (a -> Sh b) -> (a -> Sh c) -> Sh c
catchany :: MonadBaseControl IO m => m a -> (SomeException -> m a) -> m a

-- | <i>Deprecated: use Control.Exception.Lifted.catch instead</i>
catch_sh :: Exception e => Sh a -> (e -> Sh a) -> Sh a

-- | <i>Deprecated: use Control.Exception.Lifted.handle instead</i>
handle_sh :: Exception e => (e -> Sh a) -> Sh a -> Sh a

-- | <i>Deprecated: use Control.Exception.Enclosed.handleAny instead</i>
handleany_sh :: (SomeException -> Sh a) -> Sh a -> Sh a

-- | <i>Deprecated: use Control.Exception.Lifted.finally instead</i>
finally_sh :: Sh a -> Sh b -> Sh a

-- | <i>Deprecated: use Control.Exception.Lifted.catches instead</i>
catches_sh :: Sh a -> [Handler Sh a] -> Sh a

-- | <i>Deprecated: use Control.Exception.Enclosed.catchAny instead</i>
catchany_sh :: Sh a -> (SomeException -> Sh a) -> Sh a

-- | silently uses the Right or Left value of
--   "Filesystem.Path.CurrentOS.toText"
toTextIgnore :: FilePath -> Text
toTextWarn :: MonadSh m => FilePath -> m Text

-- | Convert Text to a FilePath-
fromText :: Text -> FilePath

-- | A monadic-conditional version of the "when" guard.
whenM :: Monad m => m Bool -> m () -> m ()

-- | A monadic-conditional version of the <a>unless</a> guard.
unlessM :: Monad m => m Bool -> m () -> m ()
time :: MonadShControl m => m a -> m (Double, a)
sleep :: MonadSh m => Int -> m ()

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>
get :: MonadSh m => m State
put :: MonadSh m => State -> m ()

-- | List directory recursively (like the POSIX utility "find"). listing is
--   relative if the path given is relative. If you want to filter out some
--   results or fold over them you can do that with the returned files. A
--   more efficient approach is to use one of the other find functions.
find :: FilePath -> Sh [FilePath]

-- | <a>find</a> that filters the found files as it finds. Files must
--   satisfy the given filter to be returned in the result.
findWhen :: (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | Fold an arbitrary folding function over files froma a <a>find</a>.
--   Like <a>findWhen</a> but use a more general fold rather than a filter.
findFold :: (a -> FilePath -> Sh a) -> a -> FilePath -> Sh a

-- | <a>find</a> that filters out directories as it finds Filtering out
--   directories can make a find much more efficient by avoiding entire
--   trees of files.
findDirFilter :: (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | similar <a>findWhen</a>, but also filter out directories
--   Alternatively, similar to <a>findDirFilter</a>, but also filter out
--   files Filtering out directories makes the find much more efficient
findDirFilterWhen :: (FilePath -> Sh Bool) -> (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]

-- | like <a>findDirFilterWhen</a> but use a folding function rather than a
--   filter The most general finder: you likely want a more specific one
findFoldDirFilter :: (a -> FilePath -> Sh a) -> a -> (FilePath -> Sh Bool) -> FilePath -> Sh a
followSymlink :: MonadShControl m => Bool -> m a -> m a
instance Shelly.Lifted.MonadShControl Shelly.Base.Sh
instance Shelly.Lifted.MonadShControl m => Shelly.Lifted.MonadShControl (Control.Monad.Trans.List.ListT m)
instance Shelly.Lifted.MonadShControl m => Shelly.Lifted.MonadShControl (Control.Monad.Trans.Maybe.MaybeT m)
instance Shelly.Lifted.MonadShControl m => Shelly.Lifted.MonadShControl (Control.Monad.Trans.Identity.IdentityT m)
instance (Shelly.Lifted.MonadShControl m, GHC.Base.Monoid w) => Shelly.Lifted.MonadShControl (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Shelly.Lifted.MonadShControl m, GHC.Base.Monoid w) => Shelly.Lifted.MonadShControl (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Shelly.Lifted.MonadShControl m, Control.Monad.Trans.Error.Error e) => Shelly.Lifted.MonadShControl (Control.Monad.Trans.Error.ErrorT e m)
instance Shelly.Lifted.MonadShControl m => Shelly.Lifted.MonadShControl (Control.Monad.Trans.State.Lazy.StateT s m)
instance Shelly.Lifted.MonadShControl m => Shelly.Lifted.MonadShControl (Control.Monad.Trans.State.Strict.StateT s m)
instance Shelly.Lifted.MonadShControl m => Shelly.Lifted.MonadShControl (Control.Monad.Trans.Reader.ReaderT r m)
instance (Shelly.Lifted.MonadShControl m, GHC.Base.Monoid w) => Shelly.Lifted.MonadShControl (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Shelly.Lifted.MonadShControl m, GHC.Base.Monoid w) => Shelly.Lifted.MonadShControl (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Shelly.Lifted.MonadSh Shelly.Base.Sh
instance Shelly.Lifted.MonadSh m => Shelly.Lifted.MonadSh (Control.Monad.Trans.Identity.IdentityT m)
instance Shelly.Lifted.MonadSh m => Shelly.Lifted.MonadSh (Control.Monad.Trans.List.ListT m)
instance Shelly.Lifted.MonadSh m => Shelly.Lifted.MonadSh (Control.Monad.Trans.Maybe.MaybeT m)
instance Shelly.Lifted.MonadSh m => Shelly.Lifted.MonadSh (Control.Monad.Trans.Cont.ContT r m)
instance (Control.Monad.Trans.Error.Error e, Shelly.Lifted.MonadSh m) => Shelly.Lifted.MonadSh (Control.Monad.Trans.Error.ErrorT e m)
instance Shelly.Lifted.MonadSh m => Shelly.Lifted.MonadSh (Control.Monad.Trans.Reader.ReaderT r m)
instance Shelly.Lifted.MonadSh m => Shelly.Lifted.MonadSh (Control.Monad.Trans.State.Lazy.StateT s m)
instance Shelly.Lifted.MonadSh m => Shelly.Lifted.MonadSh (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Shelly.Lifted.MonadSh m) => Shelly.Lifted.MonadSh (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Shelly.Lifted.MonadSh m) => Shelly.Lifted.MonadSh (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Shelly.Lifted.MonadSh m) => Shelly.Lifted.MonadSh (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, Shelly.Lifted.MonadSh m) => Shelly.Lifted.MonadSh (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Shelly.Lifted.MonadSh m => Shelly.ShellCmd (m Data.Text.Internal.Text)
instance (Shelly.Lifted.MonadSh m, s GHC.Types.~ Data.Text.Internal.Text, GHC.Show.Show s) => Shelly.ShellCmd (m s)
instance Shelly.Lifted.MonadSh m => Shelly.ShellCmd (m ())


-- | This module is a wrapper for the module <a>Shelly</a>. The only
--   difference is a main type <a>Sh</a>. In this module <a>Sh</a> contains
--   a list of results. Actual definition of the type <a>Sh</a> is:
--   
--   <pre>
--   import qualified Shelly as S
--   
--   newtype Sh a = Sh { unSh :: S.Sh [a] }
--   </pre>
--   
--   This definition can simplify some filesystem commands. A monad bind
--   operator becomes a pipe operator and we can write
--   
--   <pre>
--   findExt ext = findWhen (pure . hasExt ext)
--   
--   main :: IO ()
--   main = shs $ do
--       mkdir "new"
--       findExt "hs"  "." &gt;&gt;= flip cp "new"
--       findExt "cpp" "." &gt;&gt;= rm_f 
--       liftIO $ putStrLn "done"
--   </pre>
--   
--   Monad methods "return" and "&gt;&gt;=" behave like methods for
--   <tt>ListT Shelly.Sh</tt>, but "&gt;&gt;" forgets the number of the
--   empty effects. So the last line prints <tt>"done"</tt> only once.
--   
--   Documentation in this module mostly just reference documentation from
--   the main <a>Shelly</a> module.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE ExtendedDefaultRules #-}
--   {-# OPTIONS_GHC -fno-warn-type-defaults #-}
--   import Shelly
--   import Data.Text as T
--   default (T.Text)
--   </pre>
module Shelly.Pipe

-- | This type is a simple wrapper for a type <tt>Shelly.Sh</tt>. <a>Sh</a>
--   contains a list of results.
data Sh a

-- | Performs <a>shelly</a> and then an empty action <tt>return ()</tt>.
shs :: MonadIO m => Sh () -> m ()

-- | see <a>shelly</a>
shelly :: MonadIO m => Sh a -> m [a]

-- | see <a>shellyFailDir</a>
shellyFailDir :: MonadIO m => Sh a -> m [a]

-- | Performs <a>shellyFailDir</a> and then an empty action <tt>return
--   ()</tt>.
shsFailDir :: MonadIO m => Sh () -> m ()

-- | see <a>sub</a>
sub :: Sh a -> Sh a
silently :: Sh a -> Sh a
verbosely :: Sh a -> Sh a

-- | see <a>escaping</a>
escaping :: Bool -> Sh a -> Sh a

-- | see <a>print_stdout</a>
print_stdout :: Bool -> Sh a -> Sh a

-- | see 'S.print_commands
print_commands :: Bool -> Sh a -> Sh a

-- | see <a>tracing</a>
tracing :: Bool -> Sh a -> Sh a

-- | see <a>errExit</a>
errExit :: Bool -> Sh a -> Sh a

-- | see <a>log_stdout_with</a>
log_stdout_with :: (Text -> IO ()) -> Sh a -> Sh a

-- | see <a>log_stderr_with</a>
log_stderr_with :: (Text -> IO ()) -> Sh a -> Sh a

-- | Pack list of results. It performs <tt>concat</tt> inside <a>Sh</a>.
roll :: Sh [a] -> Sh a

-- | Unpack list of results.
unroll :: Sh a -> Sh [a]

-- | Transform result as list. It can be useful for filtering.
liftSh :: ([a] -> [b]) -> Sh a -> Sh b
type FoldCallback a = (a -> Text -> a)

-- | see <a>run</a>
run :: FilePath -> [Text] -> Sh Text

-- | see <a>run_</a>
run_ :: FilePath -> [Text] -> Sh ()

-- | see <a>runFoldLines</a>
runFoldLines :: a -> FoldCallback a -> FilePath -> [Text] -> Sh a

-- | see <a>cmd</a>
cmd :: ShellCommand result => FilePath -> result

-- | see <a>-|-</a>
(-|-) :: Sh Text -> Sh b -> Sh b

-- | see <a>lastStderr</a>
lastStderr :: Sh Text

-- | see <a>setStdin</a>
setStdin :: Text -> Sh ()

-- | see <a>lastExitCode</a>
lastExitCode :: Sh Int

-- | see <a>command</a>
command :: FilePath -> [Text] -> [Text] -> Sh Text

-- | see <a>command_</a>
command_ :: FilePath -> [Text] -> [Text] -> Sh ()

-- | see <a>command1</a>
command1 :: FilePath -> [Text] -> Text -> [Text] -> Sh Text

-- | see <a>command1_</a>
command1_ :: FilePath -> [Text] -> Text -> [Text] -> Sh ()

-- | see <a>sshPairs</a>
sshPairs :: Text -> [(FilePath, [Text])] -> Sh Text

-- | see <a>sshPairs_</a>
sshPairs_ :: Text -> [(FilePath, [Text])] -> Sh ()

-- | see <a>setenv</a>
setenv :: Text -> Text -> Sh ()

-- | see <a>get_env</a>
get_env :: Text -> Sh (Maybe Text)

-- | see <a>get_env_text</a>
get_env_text :: Text -> Sh Text

-- | see <a>get_env_def</a>

-- | <i>Deprecated: use fromMaybe DEFAULT get_env</i>
get_env_def :: Text -> Text -> Sh Text

-- | see <a>appendToPath</a>
appendToPath :: FilePath -> Sh ()

-- | see <a>prependToPath</a>
prependToPath :: FilePath -> Sh ()

-- | see <a>cd</a>
cd :: FilePath -> Sh ()

-- | see <a>chdir</a>
chdir :: FilePath -> Sh a -> Sh a

-- | see <a>pwd</a>
pwd :: Sh FilePath

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_n :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_err :: Text -> Sh ()

-- | Echo text to standard (error, when using _err variants) output. The _n
--   variants do not print a final newline.
echo_n_err :: Text -> Sh ()

-- | see <a>inspect</a>
inspect :: Show s => s -> Sh ()

-- | see <a>inspect_err</a>
inspect_err :: Show s => s -> Sh ()

-- | see <a>tag</a>
tag :: Sh a -> Text -> Sh a

-- | see <a>trace</a>
trace :: Text -> Sh ()

-- | see <a>show_command</a>
show_command :: FilePath -> [Text] -> Text

-- | see <a>ls</a>
ls :: FilePath -> Sh FilePath

-- | see <a>lsT</a>
lsT :: FilePath -> Sh Text

-- | see <a>test_e</a>
test_e :: FilePath -> Sh Bool

-- | see <a>test_f</a>
test_f :: FilePath -> Sh Bool

-- | see <a>test_d</a>
test_d :: FilePath -> Sh Bool

-- | see <a>test_s</a>
test_s :: FilePath -> Sh Bool

-- | see 'S.which
which :: FilePath -> Sh (Maybe FilePath)

-- | see <a>absPath</a>
absPath :: FilePath -> Sh FilePath

-- | uses System.FilePath, but can automatically convert a Text
(</>) :: (ToFilePath filepath1, ToFilePath filepath2) => filepath1 -> filepath2 -> FilePath

-- | uses System.FilePath, but can automatically convert a Text
(<.>) :: ToFilePath filepath => filepath -> Text -> FilePath

-- | see <a>canonic</a>
canonic :: FilePath -> Sh FilePath

-- | see <a>canonicalize</a>
canonicalize :: FilePath -> Sh FilePath

-- | see <a>relPath</a>
relPath :: FilePath -> Sh FilePath

-- | see <a>relativeTo</a>
relativeTo :: FilePath -> FilePath -> Sh FilePath

-- | flipped hasExtension for Text
hasExt :: Text -> FilePath -> Bool

-- | see <a>mv</a>
mv :: FilePath -> FilePath -> Sh ()

-- | see <a>rm</a>
rm :: FilePath -> Sh ()

-- | see <a>rm_f</a>
rm_f :: FilePath -> Sh ()

-- | see <a>rm_rf</a>
rm_rf :: FilePath -> Sh ()

-- | see <a>cp</a>
cp :: FilePath -> FilePath -> Sh ()

-- | see <a>cp_r</a>
cp_r :: FilePath -> FilePath -> Sh ()

-- | see <a>mkdir</a>
mkdir :: FilePath -> Sh ()

-- | see <a>mkdir_p</a>
mkdir_p :: FilePath -> Sh ()

-- | see <a>mkdirTree</a>
mkdirTree :: Tree FilePath -> Sh ()

-- | see <a>readFile</a>
readfile :: FilePath -> Sh Text

-- | see <a>readBinary</a>
readBinary :: FilePath -> Sh ByteString

-- | see <a>writeFile</a>
writefile :: FilePath -> Text -> Sh ()

-- | see <a>appendFile</a>
appendfile :: FilePath -> Text -> Sh ()

-- | see <a>touchFile</a>
touchfile :: FilePath -> Sh ()

-- | see <a>withTmpDir</a>
withTmpDir :: (FilePath -> Sh a) -> Sh a

-- | see <a>exit</a>
exit :: Int -> Sh ()

-- | see <a>errorExit</a>
errorExit :: Text -> Sh ()

-- | see <a>quietExit</a>
quietExit :: Int -> Sh ()

-- | see <a>terror</a>
terror :: Text -> Sh a

-- | A helper to catch any exception (same as <tt>... <a>catch</a> (e ::
--   SomeException) -&gt; ...</tt>).
catchany :: IO a -> (SomeException -> IO a) -> IO a

-- | see <a>catch_sh</a>
catch_sh :: Exception e => Sh a -> (e -> Sh a) -> Sh a

-- | see <a>finally_sh</a>
finally_sh :: Sh a -> Sh b -> Sh a

-- | see <a>ShellyHandler</a>
data ShellyHandler a
ShellyHandler :: (e -> Sh a) -> ShellyHandler a

-- | see <a>catches_sh</a>
catches_sh :: Sh a -> [ShellyHandler a] -> Sh a

-- | see <a>catchany_sh</a>
catchany_sh :: Sh a -> (SomeException -> Sh a) -> Sh a

-- | silently uses the Right or Left value of
--   "Filesystem.Path.CurrentOS.toText"
toTextIgnore :: FilePath -> Text

-- | see <a>toTextWarn</a>
toTextWarn :: FilePath -> Sh Text

-- | Convert Text to a FilePath-
fromText :: Text -> FilePath

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | A monadic-conditional version of the "when" guard.
whenM :: Monad m => m Bool -> m () -> m ()

-- | A monadic-conditional version of the <a>unless</a> guard.
unlessM :: Monad m => m Bool -> m () -> m ()

-- | see <a>time</a>
time :: Sh a -> Sh (Double, a)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String
get :: Sh State
put :: State -> Sh ()

-- | see <a>find</a>
find :: FilePath -> Sh FilePath

-- | see <a>findWhen</a>
findWhen :: (FilePath -> Sh Bool) -> FilePath -> Sh FilePath

-- | see <a>findFold</a>
findFold :: (a -> FilePath -> Sh a) -> a -> FilePath -> Sh a

-- | see <a>findDirFilter</a>
findDirFilter :: (FilePath -> Sh Bool) -> FilePath -> Sh FilePath

-- | see <a>findDirFilterWhen</a>
findDirFilterWhen :: (FilePath -> Sh Bool) -> (FilePath -> Sh Bool) -> FilePath -> Sh FilePath

-- | see <a>findFoldDirFilterWhen</a>
findFoldDirFilter :: (a -> FilePath -> Sh a) -> a -> (FilePath -> Sh Bool) -> FilePath -> Sh a

-- | see <a>followSymlink</a>
followSymlink :: Bool -> Sh a -> Sh a
instance Shelly.Pipe.ShellCommand (Shelly.Pipe.Sh Data.Text.Internal.Text)
instance (s GHC.Types.~ Data.Text.Internal.Text, GHC.Show.Show s) => Shelly.Pipe.ShellCommand (Shelly.Pipe.Sh s)
instance Shelly.Pipe.ShellCommand (Shelly.Pipe.Sh ())
instance (Shelly.Pipe.ShellArg arg, Shelly.Pipe.ShellCommand result) => Shelly.Pipe.ShellCommand (arg -> result)
instance Shelly.Pipe.ShellArg Data.Text.Internal.Text
instance Shelly.Pipe.ShellArg GHC.IO.FilePath
instance GHC.Base.Functor Shelly.Pipe.Sh
instance GHC.Base.Monad Shelly.Pipe.Sh
instance GHC.Base.Applicative Shelly.Pipe.Sh
instance GHC.Base.Alternative Shelly.Pipe.Sh
instance GHC.Base.MonadPlus Shelly.Pipe.Sh
instance Control.Monad.IO.Class.MonadIO Shelly.Pipe.Sh


-- | commands that only work on Unix
module Shelly.Unix
kill :: Int -> Sh ()
